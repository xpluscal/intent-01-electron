{"version":3,"file":"index.js","sources":["../../electron/main/update.ts","../../electron/main/server/config.ts","../../electron/main/server/logger.ts","../../electron/main/server/db.ts","../../electron/main/server/constants.ts","../../electron/main/server/services/WorkspaceManager.ts","../../electron/main/server/processManager.ts","../../electron/main/server/streamHandler.ts","../../electron/main/server/services/RefManager.ts","../../electron/main/server/services/ExecutionContextManager.ts","../../electron/main/server/services/ChangeManager.ts","../../electron/main/server/services/IntegrationManager.ts","../../electron/main/server/services/ResourceMonitor.ts","../../electron/main/server/services/AuditLogger.ts","../../electron/main/server/services/PerformanceMonitor.ts","../../electron/main/server/claudeSDKManager.ts","../../electron/main/server/preview/portAllocator.ts","../../electron/main/server/preview/projectAnalyzer.ts","../../electron/main/server/preview/healthChecker.ts","../../electron/main/server/preview/previewManager.ts","../../electron/main/server/errors.ts","../../electron/main/server/validators.ts","../../electron/main/server/routes/execute.ts","../../electron/main/server/routes/status.ts","../../electron/main/server/routes/message.ts","../../electron/main/server/routes/logs.ts","../../electron/main/server/routes/files.ts","../../electron/main/server/routes/preview.ts","../../electron/main/server/routes/refs.ts","../../electron/main/server/routes/refPreview.ts","../../electron/main/server/services/CleanupManager.ts","../../electron/main/server/routes/cleanup.ts","../../electron/main/server/routes/resources.ts","../../electron/main/server/routes/monitoring.ts","../../electron/main/server/routes/executionFiles.ts","../../electron/main/serverIntegration.ts","../../electron/main/index.ts"],"sourcesContent":["import { app, ipcMain } from 'electron'\nimport { createRequire } from 'node:module'\nimport type {\n  ProgressInfo,\n  UpdateDownloadedEvent,\n  UpdateInfo,\n} from 'electron-updater'\n\nconst { autoUpdater } = createRequire(import.meta.url)('electron-updater');\n\nexport function update(win: Electron.BrowserWindow) {\n\n  // When set to false, the update download will be triggered through the API\n  autoUpdater.autoDownload = false\n  autoUpdater.disableWebInstaller = false\n  autoUpdater.allowDowngrade = false\n\n  // start check\n  autoUpdater.on('checking-for-update', function () { })\n  // update available\n  autoUpdater.on('update-available', (arg: UpdateInfo) => {\n    win.webContents.send('update-can-available', { update: true, version: app.getVersion(), newVersion: arg?.version })\n  })\n  // update not available\n  autoUpdater.on('update-not-available', (arg: UpdateInfo) => {\n    win.webContents.send('update-can-available', { update: false, version: app.getVersion(), newVersion: arg?.version })\n  })\n\n  // Checking for updates\n  ipcMain.handle('check-update', async () => {\n    if (!app.isPackaged) {\n      const error = new Error('The update feature is only available after the package.')\n      return { message: error.message, error }\n    }\n\n    try {\n      return await autoUpdater.checkForUpdatesAndNotify()\n    } catch (error) {\n      return { message: 'Network error', error }\n    }\n  })\n\n  // Start downloading and feedback on progress\n  ipcMain.handle('start-download', (event: Electron.IpcMainInvokeEvent) => {\n    startDownload(\n      (error, progressInfo) => {\n        if (error) {\n          // feedback download error message\n          event.sender.send('update-error', { message: error.message, error })\n        } else {\n          // feedback update progress message\n          event.sender.send('download-progress', progressInfo)\n        }\n      },\n      () => {\n        // feedback update downloaded message\n        event.sender.send('update-downloaded')\n      }\n    )\n  })\n\n  // Install now\n  ipcMain.handle('quit-and-install', () => {\n    autoUpdater.quitAndInstall(false, true)\n  })\n}\n\nfunction startDownload(\n  callback: (error: Error | null, info: ProgressInfo | null) => void,\n  complete: (event: UpdateDownloadedEvent) => void,\n) {\n  autoUpdater.on('download-progress', (info: ProgressInfo) => callback(null, info))\n  autoUpdater.on('error', (error: Error) => callback(error, null))\n  autoUpdater.on('update-downloaded', complete)\n  autoUpdater.downloadUpdate()\n}\n","import path from 'node:path';\nimport dotenv from 'dotenv';\n\n// Load environment variables from .env file if it exists\ntry {\n  dotenv.config();\n} catch (err) {\n  // .env file is optional\n}\n\ninterface ServerConfig {\n  port: number;\n  corsOrigins: string[];\n}\n\ninterface WorkspaceConfig {\n  path: string;\n  cleanupAge: number;\n  maxConcurrent: number;\n}\n\ninterface DatabaseConfig {\n  path: string;\n}\n\ninterface AgentConfig {\n  command: string;\n  defaultArgs: string[];\n}\n\ninterface AgentsConfig {\n  claude: AgentConfig;\n  gemini: AgentConfig;\n  [key: string]: AgentConfig;\n}\n\ninterface ExecutionConfig {\n  defaultWorkingDir: string;\n  maxConcurrentExecutions: number;\n  processTimeout: number;\n}\n\ninterface LoggingConfig {\n  level: string;\n  maxLogLength: number;\n}\n\ninterface StreamingConfig {\n  heartbeatInterval: number;\n  maxBufferSize: number;\n}\n\nexport interface Config {\n  server: ServerConfig;\n  workspace: WorkspaceConfig;\n  database: DatabaseConfig;\n  agents: AgentsConfig;\n  execution: ExecutionConfig;\n  logging: LoggingConfig;\n  streaming: StreamingConfig;\n}\n\nexport const config: Config = {\n  server: {\n    port: parseInt(process.env.PORT || '3010'),\n    corsOrigins: process.env.CORS_ORIGINS \n      ? process.env.CORS_ORIGINS.split(',') \n      : ['http://localhost:3000', 'http://localhost:3001', 'http://localhost:3002', 'https://intentos.me', 'https://www.intentos.me']\n  },\n  workspace: {\n    // Workspace can be set via CLI arg, env var, or config\n    path: process.env.WORKSPACE_DIR || './workspace',\n    // Auto-cleanup executions older than this (in hours)\n    cleanupAge: process.env.WORKSPACE_CLEANUP_AGE !== undefined \n      ? parseInt(process.env.WORKSPACE_CLEANUP_AGE) \n      : 24,\n    // Maximum concurrent executions\n    maxConcurrent: process.env.WORKSPACE_MAX_CONCURRENT !== undefined\n      ? parseInt(process.env.WORKSPACE_MAX_CONCURRENT)\n      : 10\n  },\n  database: {\n    // Database path is now relative to workspace/data by default\n    // Can be overridden with absolute path\n    path: process.env.DB_PATH || 'agent-wrapper.db'\n  },\n  agents: {\n    claude: {\n      command: process.env.CLAUDE_COMMAND || 'claude',\n      defaultArgs: [\n        '--dangerously-skip-permissions',\n        '--verbose',\n        '--output-format',\n        'stream-json'\n      ]\n    },\n    gemini: {\n      command: process.env.GEMINI_COMMAND || 'gemini',\n      defaultArgs: []\n    }\n  },\n  execution: {\n    defaultWorkingDir: process.cwd(),\n    maxConcurrentExecutions: parseInt(process.env.MAX_CONCURRENT_EXECUTIONS || '10'),\n    processTimeout: parseInt(process.env.PROCESS_TIMEOUT || '0') // 0 = no timeout\n  },\n  logging: {\n    level: process.env.LOG_LEVEL || 'info',\n    maxLogLength: parseInt(process.env.MAX_LOG_LENGTH || '10000')\n  },\n  streaming: {\n    heartbeatInterval: parseInt(process.env.SSE_HEARTBEAT_INTERVAL || '30000'), // 30 seconds\n    maxBufferSize: parseInt(process.env.MAX_BUFFER_SIZE || '65536') // 64KB\n  }\n};\n\n// Validate configuration\nfunction validateConfig(): boolean {\n  if (config.server.port < 1 || config.server.port > 65535) {\n    throw new Error(`Invalid port number: ${config.server.port}`);\n  }\n\n  if (!['claude', 'gemini'].every(agent => config.agents[agent])) {\n    throw new Error('Missing agent configuration');\n  }\n\n  if (config.execution.maxConcurrentExecutions < 1) {\n    throw new Error('maxConcurrentExecutions must be at least 1');\n  }\n\n  if (config.workspace.cleanupAge < 0) {\n    throw new Error('workspace.cleanupAge must be non-negative');\n  }\n\n  if (config.workspace.maxConcurrent < 1) {\n    throw new Error('workspace.maxConcurrent must be at least 1');\n  }\n\n  return true;\n}\n\n// Validate on module load\nvalidateConfig();\n\nexport default config;","import { config } from './config.js';\n\nconst LOG_LEVELS = {\n  error: 0,\n  warn: 1,\n  info: 2,\n  debug: 3\n} as const;\n\ntype LogLevel = keyof typeof LOG_LEVELS;\n\nexport class Logger {\n  private name: string;\n  private level: number;\n\n  constructor(name: string) {\n    this.name = name;\n    this.level = LOG_LEVELS[config.logging.level as LogLevel] || LOG_LEVELS.info;\n  }\n\n  private formatMessage(level: LogLevel, message: string, ...args: any[]): string {\n    const timestamp = new Date().toISOString();\n    const prefix = `[${timestamp}] [${level.toUpperCase()}] [${this.name}]`;\n    \n    // Handle objects and errors specially\n    const formattedArgs = args.map(arg => {\n      if (arg instanceof Error) {\n        return `${arg.message}\\n${arg.stack}`;\n      }\n      if (typeof arg === 'object') {\n        return JSON.stringify(arg, null, 2);\n      }\n      return arg;\n    });\n\n    return `${prefix} ${message} ${formattedArgs.join(' ')}`.trim();\n  }\n\n  private log(level: LogLevel, message: string, ...args: any[]): void {\n    if (LOG_LEVELS[level] <= this.level) {\n      const formatted = this.formatMessage(level, message, ...args);\n      \n      if (level === 'error') {\n        console.error(formatted);\n      } else if (level === 'warn') {\n        console.warn(formatted);\n      } else {\n        console.log(formatted);\n      }\n    }\n  }\n\n  error(message: string, ...args: any[]): void {\n    this.log('error', message, ...args);\n  }\n\n  warn(message: string, ...args: any[]): void {\n    this.log('warn', message, ...args);\n  }\n\n  info(message: string, ...args: any[]): void {\n    this.log('info', message, ...args);\n  }\n\n  debug(message: string, ...args: any[]): void {\n    this.log('debug', message, ...args);\n  }\n}\n\n// Factory function to create loggers\nexport function createLogger(name: string): Logger {\n  return new Logger(name);\n}","import sqlite3 from 'sqlite3';\nimport path from 'node:path';\nimport fs from 'node:fs';\nimport { createLogger } from './logger.js';\n\nconst logger = createLogger('database');\n\ninterface RunResult {\n  id: number;\n  changes: number;\n}\n\nexport class Database {\n  private dbPath: string;\n  private db: sqlite3.Database | null = null;\n\n  constructor(dbPath: string = './data/agent-wrapper.db') {\n    this.dbPath = dbPath;\n  }\n\n  async connect(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const dir = path.dirname(this.dbPath);\n      if (!fs.existsSync(dir)) {\n        fs.mkdirSync(dir, { recursive: true });\n      }\n\n      const sqlite = sqlite3.verbose();\n      this.db = new sqlite.Database(this.dbPath, (err) => {\n        if (err) {\n          reject(err);\n        } else {\n          logger.info('Connected to SQLite database');\n          resolve();\n        }\n      });\n    });\n  }\n\n  async initialize(): Promise<void> {\n    await this.connect();\n    await this.createTables();\n    await this.runMigrations();\n  }\n\n  async createTables(): Promise<void> {\n    const executionsSchema = `\n      CREATE TABLE IF NOT EXISTS executions (\n        id TEXT PRIMARY KEY,\n        agent_type TEXT NOT NULL,\n        status TEXT NOT NULL,\n        working_dir TEXT NOT NULL,\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n        completed_at TIMESTAMP,\n        pid INTEGER,\n        workspace_path TEXT,\n        cleanup_status TEXT,\n        cleanup_at TIMESTAMP,\n        rolled_back BOOLEAN DEFAULT 0,\n        rollback_reason TEXT,\n        needs_review BOOLEAN DEFAULT 0,\n        review_reason TEXT,\n        conflict_details TEXT,\n        session_id TEXT,\n        message_count INTEGER DEFAULT 0,\n        total_cost REAL DEFAULT 0.0,\n        phase TEXT DEFAULT 'starting',\n        auto_preview BOOLEAN DEFAULT 1,\n        last_heartbeat TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      )\n    `;\n\n    const logsSchema = `\n      CREATE TABLE IF NOT EXISTS logs (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        execution_id TEXT NOT NULL,\n        timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n        type TEXT NOT NULL,\n        content TEXT NOT NULL,\n        FOREIGN KEY (execution_id) REFERENCES executions(id)\n      )\n    `;\n\n    const fileOperationsSchema = `\n      CREATE TABLE IF NOT EXISTS file_operations (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        execution_id TEXT NOT NULL,\n        operation TEXT NOT NULL,\n        path TEXT NOT NULL,\n        target_path TEXT,\n        size INTEGER,\n        success BOOLEAN NOT NULL,\n        error_message TEXT,\n        timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n        FOREIGN KEY (execution_id) REFERENCES executions(id)\n      )\n    `;\n\n    const previewProcessesSchema = `\n      CREATE TABLE IF NOT EXISTS preview_processes (\n        id TEXT PRIMARY KEY,\n        execution_id TEXT NOT NULL,\n        command TEXT NOT NULL,\n        port INTEGER,\n        pid INTEGER,\n        status TEXT NOT NULL,\n        urls TEXT,\n        started_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n        stopped_at TIMESTAMP,\n        error_message TEXT,\n        ref_type TEXT,\n        ref_id TEXT,\n        working_dir TEXT,\n        restart_attempts INTEGER DEFAULT 0,\n        last_health_check TIMESTAMP DEFAULT NULL,\n        FOREIGN KEY (execution_id) REFERENCES executions(id)\n      )\n    `;\n\n    const previewLogsSchema = `\n      CREATE TABLE IF NOT EXISTS preview_logs (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        preview_id TEXT NOT NULL,\n        timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n        type TEXT NOT NULL,\n        content TEXT NOT NULL,\n        FOREIGN KEY (preview_id) REFERENCES preview_processes(id)\n      )\n    `;\n\n    const portAllocationsSchema = `\n      CREATE TABLE IF NOT EXISTS port_allocations (\n        port INTEGER PRIMARY KEY,\n        preview_id TEXT NOT NULL,\n        allocated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n        FOREIGN KEY (preview_id) REFERENCES preview_processes(id)\n      )\n    `;\n\n    // Tables from migrations\n    const executionRefsSchema = `\n      CREATE TABLE IF NOT EXISTS execution_refs (\n        execution_id TEXT NOT NULL,\n        ref_id TEXT NOT NULL,\n        permission TEXT NOT NULL CHECK (permission IN ('read', 'mutate', 'create')),\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n        PRIMARY KEY (execution_id, ref_id, permission),\n        FOREIGN KEY (execution_id) REFERENCES executions(id)\n      )\n    `;\n\n    const refChangesSchema = `\n      CREATE TABLE IF NOT EXISTS ref_changes (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        execution_id TEXT NOT NULL,\n        ref_id TEXT,\n        change_type TEXT NOT NULL CHECK (change_type IN ('commit', 'merge', 'create', 'rollback')),\n        branch_name TEXT,\n        commit_hash TEXT,\n        commit_message TEXT,\n        merge_status TEXT CHECK (merge_status IN ('success', 'conflict', 'failed')),\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n        FOREIGN KEY (execution_id) REFERENCES executions(id)\n      )\n    `;\n\n    const resourceUsageSchema = `\n      CREATE TABLE IF NOT EXISTS resource_usage (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n        type TEXT NOT NULL CHECK (type IN ('disk_usage', 'concurrent_executions', 'system_resources')),\n        current_value REAL NOT NULL,\n        limit_value REAL NOT NULL,\n        exceeded BOOLEAN NOT NULL DEFAULT 0,\n        details TEXT,\n        execution_id TEXT\n      )\n    `;\n\n    const gitOperationsLogSchema = `\n      CREATE TABLE IF NOT EXISTS git_operations_log (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        execution_id TEXT,\n        ref_id TEXT,\n        operation TEXT NOT NULL,\n        branch TEXT,\n        command TEXT NOT NULL,\n        working_dir TEXT,\n        success BOOLEAN NOT NULL DEFAULT 1,\n        duration_ms INTEGER,\n        output TEXT,\n        error TEXT,\n        metadata TEXT,\n        timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n        FOREIGN KEY (execution_id) REFERENCES executions(id)\n      )\n    `;\n\n    const executionEventsLogSchema = `\n      CREATE TABLE IF NOT EXISTS execution_events_log (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        execution_id TEXT NOT NULL,\n        event TEXT NOT NULL,\n        phase TEXT,\n        details TEXT,\n        success BOOLEAN NOT NULL DEFAULT 1,\n        duration_ms INTEGER,\n        error TEXT,\n        timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n        FOREIGN KEY (execution_id) REFERENCES executions(id)\n      )\n    `;\n\n    const performanceMetricsSchema = `\n      CREATE TABLE IF NOT EXISTS performance_metrics (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        execution_id TEXT,\n        operation TEXT NOT NULL,\n        duration_ms INTEGER NOT NULL,\n        success BOOLEAN NOT NULL DEFAULT 1,\n        metadata TEXT,\n        timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n        FOREIGN KEY (execution_id) REFERENCES executions(id)\n      )\n    `;\n\n    const indexSchemas = [\n      'CREATE INDEX IF NOT EXISTS idx_logs_execution ON logs(execution_id)',\n      'CREATE INDEX IF NOT EXISTS idx_logs_timestamp ON logs(execution_id, timestamp)',\n      'CREATE INDEX IF NOT EXISTS idx_file_operations_execution ON file_operations(execution_id)',\n      'CREATE INDEX IF NOT EXISTS idx_file_operations_timestamp ON file_operations(execution_id, timestamp)',\n      'CREATE INDEX IF NOT EXISTS idx_preview_execution ON preview_processes(execution_id)',\n      'CREATE INDEX IF NOT EXISTS idx_preview_logs ON preview_logs(preview_id, timestamp)',\n      // Indexes from migrations\n      'CREATE INDEX IF NOT EXISTS idx_execution_refs_execution ON execution_refs(execution_id)',\n      'CREATE INDEX IF NOT EXISTS idx_execution_refs_ref ON execution_refs(ref_id)',\n      'CREATE INDEX IF NOT EXISTS idx_ref_changes_execution ON ref_changes(execution_id)',\n      'CREATE INDEX IF NOT EXISTS idx_ref_changes_ref ON ref_changes(ref_id)',\n      'CREATE INDEX IF NOT EXISTS idx_executions_heartbeat ON executions(status, last_heartbeat)',\n      'CREATE INDEX IF NOT EXISTS idx_git_operations_execution ON git_operations_log(execution_id)',\n      'CREATE INDEX IF NOT EXISTS idx_git_operations_ref ON git_operations_log(ref_id)',\n      'CREATE INDEX IF NOT EXISTS idx_execution_events_execution ON execution_events_log(execution_id)',\n      'CREATE INDEX IF NOT EXISTS idx_performance_metrics_execution ON performance_metrics(execution_id)'\n    ];\n\n    return new Promise((resolve, reject) => {\n      if (!this.db) {\n        reject(new Error('Database not connected'));\n        return;\n      }\n\n      this.db.serialize(() => {\n        this.db!.run(executionsSchema, (err) => {\n          if (err) reject(err);\n        });\n\n        this.db!.run(logsSchema, (err) => {\n          if (err) reject(err);\n        });\n\n        this.db!.run(fileOperationsSchema, (err) => {\n          if (err) reject(err);\n        });\n\n        this.db!.run(previewProcessesSchema, (err) => {\n          if (err) reject(err);\n        });\n\n        this.db!.run(previewLogsSchema, (err) => {\n          if (err) reject(err);\n        });\n\n        this.db!.run(portAllocationsSchema, (err) => {\n          if (err) reject(err);\n        });\n\n        // Create tables from migrations\n        this.db!.run(executionRefsSchema, (err) => {\n          if (err) reject(err);\n        });\n\n        this.db!.run(refChangesSchema, (err) => {\n          if (err) reject(err);\n        });\n\n        this.db!.run(resourceUsageSchema, (err) => {\n          if (err) reject(err);\n        });\n\n        this.db!.run(gitOperationsLogSchema, (err) => {\n          if (err) reject(err);\n        });\n\n        this.db!.run(executionEventsLogSchema, (err) => {\n          if (err) reject(err);\n        });\n\n        this.db!.run(performanceMetricsSchema, (err) => {\n          if (err) reject(err);\n        });\n\n        indexSchemas.forEach(schema => {\n          this.db!.run(schema, (err) => {\n            if (err) reject(err);\n          });\n        });\n\n        resolve();\n      });\n    });\n  }\n\n  async run(sql: string, params: any[] = []): Promise<RunResult> {\n    return new Promise((resolve, reject) => {\n      if (!this.db) {\n        reject(new Error('Database not connected'));\n        return;\n      }\n\n      this.db.run(sql, params, function(err) {\n        if (err) {\n          reject(err);\n        } else {\n          resolve({ id: this.lastID, changes: this.changes });\n        }\n      });\n    });\n  }\n\n  async get<T = any>(sql: string, params: any[] = []): Promise<T | undefined> {\n    return new Promise((resolve, reject) => {\n      if (!this.db) {\n        reject(new Error('Database not connected'));\n        return;\n      }\n\n      this.db.get(sql, params, (err, row) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(row as T);\n        }\n      });\n    });\n  }\n\n  async all<T = any>(sql: string, params: any[] = []): Promise<T[]> {\n    return new Promise((resolve, reject) => {\n      if (!this.db) {\n        reject(new Error('Database not connected'));\n        return;\n      }\n\n      this.db.all(sql, params, (err, rows) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(rows as T[]);\n        }\n      });\n    });\n  }\n\n  async runMigrations(): Promise<void> {\n    // All migrations have been consolidated into createTables()\n    // This method is kept for compatibility but does nothing\n    logger.info('All schema updates are handled in createTables()');\n  }\n\n  async close(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      if (!this.db) {\n        resolve();\n        return;\n      }\n\n      this.db.close((err) => {\n        if (err) {\n          reject(err);\n        } else {\n          logger.info('Database connection closed');\n          resolve();\n        }\n      });\n    });\n  }\n}\n\nexport default Database;","// Event names\nexport const Events = {\n  PROCESS_START: 'process:start',\n  PROCESS_EXIT: 'process:exit',\n  PROCESS_ERROR: 'process:error',\n  LOG_ENTRY: 'log:entry',\n  BUFFER_FLUSH: 'buffer:flush'\n} as const;\n\n// State transitions\nexport const ValidTransitions: Record<string, string[]> = {\n  'starting': ['running', 'failed'],\n  'running': ['completed', 'failed'],\n  'completed': [],  // terminal state\n  'failed': []      // terminal state\n};\n\n// Resource limits\nexport const Limits = {\n  MAX_BUFFER_SIZE: 1024 * 1024,  // 1MB per execution\n  MAX_LINE_LENGTH: 10000,         // 10KB per line\n  SPAWN_TIMEOUT: 5000             // 5s to start process\n} as const;\n\n// Error codes\nexport const ErrorCodes = {\n  // Validation\n  VALIDATION_ERROR: 'VALIDATION_ERROR',\n  INVALID_AGENT: 'INVALID_AGENT',\n  INVALID_PROMPT: 'INVALID_PROMPT',\n  INVALID_PATH: 'INVALID_PATH',\n  \n  // Not Found\n  EXECUTION_NOT_FOUND: 'EXECUTION_NOT_FOUND',\n  \n  // Process\n  SPAWN_FAILED: 'SPAWN_FAILED',\n  PROCESS_NOT_RUNNING: 'PROCESS_NOT_RUNNING',\n  PROCESS_TERMINATED: 'PROCESS_TERMINATED',\n  \n  // System\n  DATABASE_ERROR: 'DATABASE_ERROR',\n  FILESYSTEM_ERROR: 'FILESYSTEM_ERROR',\n  INTERNAL_ERROR: 'INTERNAL_ERROR',\n  \n  // File operations\n  FILE_NOT_FOUND: 'FILE_NOT_FOUND',\n  DIRECTORY_NOT_FOUND: 'DIRECTORY_NOT_FOUND',\n  PATH_TRAVERSAL_ATTEMPT: 'PATH_TRAVERSAL_ATTEMPT',\n  FILE_TOO_LARGE: 'FILE_TOO_LARGE',\n  PERMISSION_DENIED: 'PERMISSION_DENIED',\n  INVALID_ENCODING: 'INVALID_ENCODING',\n  DIRECTORY_NOT_EMPTY: 'DIRECTORY_NOT_EMPTY',\n  FILE_EXISTS: 'FILE_EXISTS',\n  INVALID_FILE_OPERATION: 'INVALID_FILE_OPERATION'\n} as const;\n\n// Execution statuses\nexport const ExecutionStatus = {\n  STARTING: 'starting',\n  RUNNING: 'running',\n  COMPLETED: 'completed',\n  FAILED: 'failed'\n} as const;\n\n// Log types\nexport const LogType = {\n  STDOUT: 'stdout',\n  STDERR: 'stderr',\n  SYSTEM: 'system'\n} as const;\n\n// File operations\nexport const FileOperations = {\n  READ: 'read',\n  WRITE: 'write',\n  CREATE: 'create',\n  DELETE: 'delete',\n  MOVE: 'move',\n  COPY: 'copy',\n  LIST: 'list',\n  SEARCH: 'search'\n} as const;\n\n// File types\nexport const FileTypes = {\n  FILE: 'file',\n  DIRECTORY: 'directory',\n  ALL: 'all'\n} as const;\n\n// Encoding types\nexport const FileEncodings = {\n  UTF8: 'utf8',\n  BASE64: 'base64',\n  BINARY: 'binary'\n} as const;\n\n// Search types\nexport const SearchTypes = {\n  FILENAME: 'filename',\n  CONTENT: 'content',\n  BOTH: 'both'\n} as const;\n\n// File operation limits\nexport const FileLimits = {\n  MAX_FILE_SIZE: 10 * 1024 * 1024,    // 10MB default\n  MAX_PATH_LENGTH: 255,                // Maximum path length\n  MAX_SEARCH_RESULTS: 100,             // Default search results limit\n  DEFAULT_LIST_LIMIT: 1000,            // Default directory listing limit\n  MAX_LINE_LENGTH: 10000               // Maximum line length for partial reads\n} as const;\n\n// Type exports\nexport type EventType = typeof Events[keyof typeof Events];\nexport type ErrorCode = typeof ErrorCodes[keyof typeof ErrorCodes];\nexport type ExecutionStatusType = typeof ExecutionStatus[keyof typeof ExecutionStatus];\nexport type LogTypeValue = typeof LogType[keyof typeof LogType];\nexport type FileOperation = typeof FileOperations[keyof typeof FileOperations];\nexport type FileType = typeof FileTypes[keyof typeof FileTypes];\nexport type FileEncoding = typeof FileEncodings[keyof typeof FileEncodings];\nexport type SearchType = typeof SearchTypes[keyof typeof SearchTypes];","import { promises as fs } from 'node:fs';\nimport path from 'node:path';\n\ninterface WorkspaceConfig {\n  workspace: string;\n  refsDir: string;\n  executionsDir: string;\n  dataDir: string;\n}\n\nexport class WorkspaceManager {\n  private workspacePath: string;\n\n  constructor(workspacePath?: string) {\n    // Use provided path, env variable, or default\n    this.workspacePath = workspacePath || \n                        process.env.WORKSPACE_DIR || \n                        path.join(process.cwd(), 'workspace');\n    \n    // Ensure absolute path\n    this.workspacePath = path.resolve(this.workspacePath);\n  }\n\n  async initialize(): Promise<WorkspaceConfig> {\n    console.log(`Initializing workspace at: ${this.workspacePath}`);\n    \n    // First ensure base workspace exists and is writable\n    if (!await this.exists(this.workspacePath)) {\n      await fs.mkdir(this.workspacePath, { recursive: true });\n      console.log(`Created workspace directory: ${this.workspacePath}`);\n    }\n    \n    // Verify write permissions before creating subdirectories\n    await this.verifyPermissions();\n    \n    // Create workspace structure\n    const subdirs = [\n      path.join(this.workspacePath, 'refs'),\n      path.join(this.workspacePath, '.execution'),\n      path.join(this.workspacePath, 'data')\n    ];\n    \n    for (const dir of subdirs) {\n      if (!await this.exists(dir)) {\n        await fs.mkdir(dir, { recursive: true });\n        console.log(`Created directory: ${dir}`);\n      }\n    }\n    \n    // Clean up any orphaned execution directories\n    await this.cleanupOrphanedExecutions();\n    \n    return {\n      workspace: this.workspacePath,\n      refsDir: path.join(this.workspacePath, 'refs'),\n      executionsDir: path.join(this.workspacePath, '.execution'),\n      dataDir: path.join(this.workspacePath, 'data')\n    };\n  }\n\n  private async exists(path: string): Promise<boolean> {\n    try {\n      await fs.access(path);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  private async verifyPermissions(): Promise<void> {\n    try {\n      // Try to create a test file to verify write permissions\n      const testFile = path.join(this.workspacePath, '.permission-test');\n      await fs.writeFile(testFile, 'test');\n      await fs.unlink(testFile);\n    } catch (error: any) {\n      if (error.code === 'EACCES') {\n        throw new Error(`No write permission for workspace directory: ${this.workspacePath}`);\n      }\n      throw error;\n    }\n  }\n\n  private async cleanupOrphanedExecutions(): Promise<void> {\n    const executionsDir = path.join(this.workspacePath, '.execution');\n    \n    try {\n      const dirs = await fs.readdir(executionsDir);\n      \n      for (const dir of dirs) {\n        if (dir.startsWith('exec-')) {\n          const execPath = path.join(executionsDir, dir);\n          const stats = await fs.stat(execPath);\n          \n          // Clean up executions older than 7 days\n          const ageInDays = (Date.now() - stats.mtime.getTime()) / (1000 * 60 * 60 * 24);\n          if (ageInDays > 7) {\n            await fs.rm(execPath, { recursive: true, force: true });\n            console.log(`Cleaned up old execution directory: ${dir}`);\n          }\n        }\n      }\n    } catch (error: any) {\n      // Directory might not exist yet\n      if (error.code !== 'ENOENT') {\n        console.error('Error cleaning up executions:', error);\n      }\n    }\n  }\n\n  async createExecutionWorkspace(executionId: string): Promise<string> {\n    const execPath = path.join(this.workspacePath, '.execution', `exec-${executionId}`);\n    await fs.mkdir(execPath, { recursive: true });\n    return execPath;\n  }\n\n  async createRefWorkspace(refId: string): Promise<string> {\n    const refPath = path.join(this.workspacePath, 'refs', refId);\n    await fs.mkdir(refPath, { recursive: true });\n    return refPath;\n  }\n\n  async cleanupExecution(executionId: string): Promise<void> {\n    const execPath = path.join(this.workspacePath, '.execution', `exec-${executionId}`);\n    \n    try {\n      await fs.rm(execPath, { recursive: true, force: true });\n      console.log(`Cleaned up execution workspace: ${executionId}`);\n    } catch (error: any) {\n      if (error.code !== 'ENOENT') {\n        console.error(`Failed to cleanup execution ${executionId}:`, error);\n      }\n    }\n  }\n\n  async cleanupOldExecutions(hoursOld: number = 24): Promise<number> {\n    const executionsDir = path.join(this.workspacePath, '.execution');\n    const cutoffTime = Date.now() - (hoursOld * 60 * 60 * 1000);\n    let cleanedCount = 0;\n    \n    try {\n      const dirs = await fs.readdir(executionsDir);\n      \n      for (const dir of dirs) {\n        if (dir.startsWith('exec-')) {\n          const execPath = path.join(executionsDir, dir);\n          const stats = await fs.stat(execPath);\n          \n          if (stats.mtime.getTime() < cutoffTime) {\n            await fs.rm(execPath, { recursive: true, force: true });\n            cleanedCount++;\n            console.log(`Cleaned up old execution: ${dir}`);\n          }\n        }\n      }\n    } catch (error: any) {\n      if (error.code !== 'ENOENT') {\n        console.error('Error cleaning up old executions:', error);\n      }\n    }\n    \n    return cleanedCount;\n  }\n\n  async getWorkspaceStats(): Promise<{\n    totalSize: number;\n    executionCount: number;\n    refCount: number;\n  }> {\n    const stats = {\n      totalSize: 0,\n      executionCount: 0,\n      refCount: 0\n    };\n    \n    // Count executions\n    try {\n      const execDirs = await fs.readdir(path.join(this.workspacePath, '.execution'));\n      stats.executionCount = execDirs.filter(d => d.startsWith('exec-')).length;\n    } catch (error) {\n      // Directory might not exist\n    }\n    \n    // Count refs\n    try {\n      const refDirs = await fs.readdir(path.join(this.workspacePath, 'refs'));\n      stats.refCount = refDirs.length;\n    } catch (error) {\n      // Directory might not exist\n    }\n    \n    // Calculate total size (simplified - just counting files)\n    stats.totalSize = await this.getDirectorySize(this.workspacePath);\n    \n    return stats;\n  }\n\n  private async getDirectorySize(dirPath: string): Promise<number> {\n    let totalSize = 0;\n    \n    try {\n      const entries = await fs.readdir(dirPath, { withFileTypes: true });\n      \n      for (const entry of entries) {\n        const fullPath = path.join(dirPath, entry.name);\n        \n        if (entry.isDirectory()) {\n          totalSize += await this.getDirectorySize(fullPath);\n        } else {\n          const stats = await fs.stat(fullPath);\n          totalSize += stats.size;\n        }\n      }\n    } catch (error) {\n      // Ignore errors for inaccessible files\n    }\n    \n    return totalSize;\n  }\n\n  getWorkspacePath(): string {\n    return this.workspacePath;\n  }\n\n  getRefPath(refId: string): string {\n    return path.join(this.workspacePath, 'refs', refId);\n  }\n\n  getExecutionPath(executionId: string): string {\n    return path.join(this.workspacePath, '.execution', `exec-${executionId}`);\n  }\n\n  getExecutionsDir(): string {\n    return path.join(this.workspacePath, '.execution');\n  }\n}\n\nexport default WorkspaceManager;","import { spawn, ChildProcess } from 'node:child_process';\nimport path from 'node:path';\nimport fs from 'node:fs';\nimport { \n  Events, \n  ValidTransitions, \n  ErrorCodes, \n  ExecutionStatus,\n  LogType,\n  Limits,\n  ExecutionStatusType\n} from './constants.js';\nimport { createLogger } from './logger.js';\nimport type { Database } from './db.js';\nimport type { EventEmitter } from 'node:events';\nimport type { Config } from './config.js';\n\nconst logger = createLogger('ProcessManager');\n\ninterface CommandConfig {\n  cmd: string;\n  args: string[];\n}\n\nexport class ProcessManager {\n  private db: Database;\n  private config: Config;\n  private eventEmitter: EventEmitter;\n  private activeProcesses: Map<string, ChildProcess>;\n\n  constructor(db: Database, config: Config, eventEmitter: EventEmitter) {\n    this.db = db;\n    this.config = config;\n    this.eventEmitter = eventEmitter;\n    this.activeProcesses = new Map();\n  }\n\n  async spawn(\n    executionId: string, \n    agent: string, \n    prompt: string, \n    workingDir: string | null = null, \n    isContinuation: boolean = false\n  ): Promise<ChildProcess> {\n    try {\n      // Validate agent type\n      if (!['claude', 'gemini'].includes(agent)) {\n        throw new Error(`Invalid agent type: ${agent}`);\n      }\n\n      // Validate and resolve working directory\n      const resolvedWorkingDir = this.validateWorkingDir(workingDir);\n\n      // Update database with starting status\n      await this.updateProcessStatus(executionId, ExecutionStatus.STARTING);\n      logger.info(`Spawning ${agent} process`, { executionId, workingDir: resolvedWorkingDir, isContinuation });\n\n      // Build command based on agent type\n      const { cmd, args } = this.buildCommand(agent, prompt, resolvedWorkingDir, isContinuation);\n\n      // Spawn the process\n      const childProcess = spawn(cmd, args, {\n        cwd: resolvedWorkingDir,\n        env: process.env,\n        shell: false,\n        stdio: ['pipe', 'pipe', 'pipe']\n      });\n\n      // Store process reference\n      this.activeProcesses.set(executionId, childProcess);\n\n      // Update with PID once process starts\n      childProcess.on('spawn', () => {\n        logger.info(`Process started`, { executionId, pid: childProcess.pid });\n        this.updateProcessStatus(executionId, ExecutionStatus.RUNNING, childProcess.pid);\n        this.eventEmitter.emit(Events.PROCESS_START, { executionId, pid: childProcess.pid });\n        \n        // For Claude in --print mode, stdin should be closed after providing prompt\n        if (agent === 'claude' && this.config.agents.claude.defaultArgs.includes('--print')) {\n          childProcess.stdin!.end();\n        }\n      });\n\n      // Handle process exit\n      childProcess.on('exit', (code, signal) => {\n        this.handleProcessExit(executionId, code, signal);\n      });\n\n      // Handle process errors\n      childProcess.on('error', (error) => {\n        this.handleProcessError(executionId, error);\n      });\n      \n      // Log the actual command being run\n      logger.info(`Spawning command`, { \n        executionId, \n        command: cmd, \n        args, \n        cwd: resolvedWorkingDir \n      });\n\n      // Set spawn timeout\n      const spawnTimeout = setTimeout(() => {\n        if (this.getProcess(executionId) && !childProcess.pid) {\n          childProcess.kill();\n          this.handleProcessError(executionId, new Error('Process spawn timeout'));\n        }\n      }, Limits.SPAWN_TIMEOUT);\n\n      childProcess.once('spawn', () => clearTimeout(spawnTimeout));\n\n      return childProcess;\n    } catch (error) {\n      logger.error(`Failed to spawn process`, { executionId, error });\n      await this.updateProcessStatus(executionId, ExecutionStatus.FAILED);\n      throw error;\n    }\n  }\n\n  private buildCommand(agent: string, prompt: string, workingDir: string, isContinuation: boolean = false): CommandConfig {\n    const agentConfig = this.config.agents[agent];\n    if (!agentConfig) {\n      throw new Error(`No configuration found for agent: ${agent}`);\n    }\n\n    const command = agentConfig.command;\n    const args = [...agentConfig.defaultArgs];\n    \n    if (agent === 'claude') {\n      // Add working directory if specified\n      if (workingDir) {\n        args.push('--cwd', workingDir);\n      }\n      \n      // If it's a continuation, we need to handle it differently\n      if (!isContinuation) {\n        // For initial prompts, pass the prompt as the last argument\n        args.push(prompt);\n      }\n      // For continuations, the prompt will be sent via stdin\n    } else if (agent === 'gemini') {\n      // Add Gemini-specific arguments\n      args.push(prompt);\n    }\n    \n    return { cmd: command, args };\n  }\n\n  private validateWorkingDir(workingDir: string | null): string {\n    if (!workingDir) {\n      return this.config.execution.defaultWorkingDir;\n    }\n    \n    // Resolve to absolute path\n    const resolved = path.resolve(workingDir);\n    \n    // Verify directory exists\n    if (!fs.existsSync(resolved)) {\n      throw new Error(`Working directory does not exist: ${resolved}`);\n    }\n    \n    if (!fs.statSync(resolved).isDirectory()) {\n      throw new Error(`Path is not a directory: ${resolved}`);\n    }\n    \n    return resolved;\n  }\n\n  async sendInput(executionId: string, input: string): Promise<void> {\n    const process = this.getProcess(executionId);\n    if (!process) {\n      throw new Error('Process not found');\n    }\n    \n    if (!process.stdin || process.stdin.destroyed) {\n      throw new Error('Process stdin is not available');\n    }\n    \n    return new Promise((resolve, reject) => {\n      process.stdin!.write(input + '\\n', (err) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve();\n        }\n      });\n    });\n  }\n\n  async terminate(executionId: string): Promise<void> {\n    const process = this.getProcess(executionId);\n    if (!process) {\n      logger.warn(`No process found for execution ${executionId}`);\n      return;\n    }\n    \n    logger.info(`Terminating process for execution ${executionId}`);\n    \n    // Try graceful shutdown first\n    process.kill('SIGTERM');\n    \n    // Force kill after timeout\n    setTimeout(() => {\n      if (this.getProcess(executionId)) {\n        logger.warn(`Force killing process for execution ${executionId}`);\n        process.kill('SIGKILL');\n      }\n    }, 5000);\n  }\n\n  getProcess(executionId: string): ChildProcess | undefined {\n    return this.activeProcesses.get(executionId);\n  }\n\n  isProcessRunning(executionId: string): boolean {\n    const process = this.getProcess(executionId);\n    return !!process && !process.killed;\n  }\n\n  private async updateProcessStatus(executionId: string, status: ExecutionStatusType, pid?: number): Promise<void> {\n    const updateFields: string[] = ['status = ?'];\n    const updateValues: any[] = [status];\n    \n    if (pid !== undefined) {\n      updateFields.push('pid = ?');\n      updateValues.push(pid);\n    }\n    \n    if (status === ExecutionStatus.COMPLETED || status === ExecutionStatus.FAILED) {\n      updateFields.push('completed_at = CURRENT_TIMESTAMP');\n    }\n    \n    updateValues.push(executionId);\n    \n    await this.db.run(\n      `UPDATE executions SET ${updateFields.join(', ')} WHERE id = ?`,\n      updateValues\n    );\n  }\n\n  private async handleProcessExit(executionId: string, code: number | null, signal: NodeJS.Signals | null): Promise<void> {\n    logger.info(`Process exited`, { executionId, code, signal });\n    \n    // Remove from active processes\n    this.activeProcesses.delete(executionId);\n    \n    // Update status based on exit code\n    const status = code === 0 ? ExecutionStatus.COMPLETED : ExecutionStatus.FAILED;\n    await this.updateProcessStatus(executionId, status);\n    \n    // Emit exit event\n    this.eventEmitter.emit(Events.PROCESS_EXIT, { executionId, code, signal });\n    \n    // Also emit a flush buffer event to ensure all output is saved\n    this.eventEmitter.emit(Events.BUFFER_FLUSH, { executionId });\n  }\n\n  private async handleProcessError(executionId: string, error: Error): Promise<void> {\n    logger.error(`Process error`, { executionId, error });\n    \n    // Remove from active processes\n    this.activeProcesses.delete(executionId);\n    \n    // Update status\n    await this.updateProcessStatus(executionId, ExecutionStatus.FAILED);\n    \n    // Save error to logs\n    await this.db.run(\n      'INSERT INTO logs (execution_id, type, content) VALUES (?, ?, ?)',\n      [executionId, LogType.SYSTEM, `Process error: ${error.message}`]\n    );\n    \n    // Emit error event\n    this.eventEmitter.emit(Events.PROCESS_ERROR, { executionId, error });\n  }\n\n  async getAllActiveProcesses(): Promise<string[]> {\n    return Array.from(this.activeProcesses.keys());\n  }\n\n  async terminateAll(): Promise<void> {\n    const executionIds = await this.getAllActiveProcesses();\n    \n    for (const executionId of executionIds) {\n      try {\n        await this.terminate(executionId);\n      } catch (error) {\n        logger.error(`Failed to terminate process ${executionId}:`, error);\n      }\n    }\n  }\n}\n\nexport default ProcessManager;","import { Events, Limits, LogType, LogTypeValue } from './constants.js';\nimport { createLogger } from './logger.js';\nimport type { Database } from './db.js';\nimport { EventEmitter } from 'node:events';\n\nconst logger = createLogger('StreamHandler');\n\ninterface LogEntry {\n  timestamp: string;\n  type: LogTypeValue;\n  content: string;\n}\n\nexport class StreamHandler {\n  private db: Database;\n  private eventEmitter: EventEmitter;\n  private buffers: Map<string, string>;\n\n  constructor(db: Database, eventEmitter: EventEmitter) {\n    this.db = db;\n    this.eventEmitter = eventEmitter;\n    this.buffers = new Map();\n  }\n\n  async handleOutput(executionId: string, stream: LogTypeValue, data: Buffer): Promise<void> {\n    try {\n      const content = data.toString('utf8');\n      \n      // Log output in verbose mode\n      if (process.env.SHOW_PROCESS_OUTPUT === 'true') {\n        logger.debug(`Process ${stream}`, { executionId, content: content.trim() });\n      }\n      \n      // Append to buffer\n      this.appendToBuffer(executionId, content);\n      \n      // Process complete lines\n      await this.processCompleteLines(executionId, stream);\n      \n    } catch (error) {\n      logger.error(`Error handling output`, { executionId, error });\n    }\n  }\n\n  private appendToBuffer(executionId: string, data: string): void {\n    let buffer = this.buffers.get(executionId) || '';\n    buffer += data;\n    \n    // Check buffer size limit\n    if (buffer.length > Limits.MAX_BUFFER_SIZE) {\n      logger.warn(`Buffer size exceeded, truncating`, { executionId, size: buffer.length });\n      buffer = buffer.slice(-Limits.MAX_BUFFER_SIZE);\n    }\n    \n    this.buffers.set(executionId, buffer);\n  }\n\n  private async processCompleteLines(executionId: string, streamType: LogTypeValue): Promise<void> {\n    let buffer = this.buffers.get(executionId) || '';\n    const lines = buffer.split('\\n');\n    \n    // Keep the last incomplete line in the buffer\n    const incomplete = lines.pop() || '';\n    this.buffers.set(executionId, incomplete);\n    \n    // Process complete lines\n    for (const line of lines) {\n      if (line.length > 0) {\n        await this.saveLog(executionId, streamType, line);\n        this.emitLogEvent(executionId, {\n          timestamp: new Date().toISOString(),\n          type: streamType,\n          content: line\n        });\n      }\n    }\n  }\n\n  async flushBuffer(executionId: string): Promise<void> {\n    const buffer = this.buffers.get(executionId);\n    \n    if (buffer && buffer.length > 0) {\n      logger.debug(`Flushing buffer`, { executionId, length: buffer.length });\n      // Save any remaining content\n      await this.saveLog(executionId, LogType.STDOUT, buffer);\n      this.emitLogEvent(executionId, {\n        timestamp: new Date().toISOString(),\n        type: LogType.STDOUT,\n        content: buffer\n      });\n    }\n    \n    this.clearBuffer(executionId);\n  }\n\n  clearBuffer(executionId: string): void {\n    this.buffers.delete(executionId);\n  }\n\n  private async saveLog(executionId: string, type: LogTypeValue, content: string): Promise<void> {\n    try {\n      // Truncate content if too long\n      const truncatedContent = content.length > Limits.MAX_LINE_LENGTH\n        ? content.substring(0, Limits.MAX_LINE_LENGTH) + '... [truncated]'\n        : content;\n      \n      await this.db.run(\n        'INSERT INTO logs (execution_id, type, content) VALUES (?, ?, ?)',\n        [executionId, type, truncatedContent]\n      );\n    } catch (error) {\n      logger.error(`Failed to save log`, { executionId, error });\n    }\n  }\n\n  private emitLogEvent(executionId: string, logEntry: LogEntry): void {\n    this.eventEmitter.emit(Events.LOG_ENTRY, {\n      executionId,\n      ...logEntry\n    });\n  }\n\n  parseOutput(data: Buffer): string {\n    // Basic parsing - can be extended for specific formats\n    return data.toString('utf8').trim();\n  }\n}\n\nexport default StreamHandler;","import { exec } from 'node:child_process';\nimport { promisify } from 'util';\nimport path from 'node:path';\nimport { promises as fs } from 'node:fs';\n\nconst execAsync = promisify(exec);\n\nclass RefManager {\n  constructor(workspacePath, performanceMonitor = null) {\n    this.workspacePath = workspacePath;\n    this.refsDir = path.join(workspacePath, 'refs');\n    console.log(`[RefManager] Initialized with workspace: ${workspacePath}`);\n    console.log(`[RefManager] Refs directory: ${this.refsDir}`);\n    this.performanceMonitor = performanceMonitor;\n  }\n\n  /**\n   * Execute a git command safely with proper escaping and performance monitoring\n   */\n  async execGit(cwd, command, options = {}) {\n    const { executionId = null, refId = null, operation = 'unknown' } = options;\n    \n    // Extract actual Git operation from command\n    const gitOperation = this.extractGitOperation(command);\n    \n    if (this.performanceMonitor) {\n      return await this.performanceMonitor.instrumentGitOperation({\n        executionId,\n        refId,\n        operation: gitOperation,\n        branch: options.branch || null,\n        command: `git ${command}`,\n        workingDir: cwd\n      }, async () => {\n        return await this._execGitInternal(cwd, command, options);\n      });\n    } else {\n      return await this._execGitInternal(cwd, command, options);\n    }\n  }\n\n  /**\n   * Internal Git execution without monitoring\n   */\n  async _execGitInternal(cwd, command, options = {}) {\n    try {\n      const { stdout, stderr } = await execAsync(`git ${command}`, {\n        cwd,\n        encoding: options.encoding || 'utf8',\n        maxBuffer: 10 * 1024 * 1024, // 10MB buffer\n        ...options\n      });\n      \n      // Handle buffer output when encoding is 'buffer'\n      if (options.encoding === 'buffer') {\n        return stdout;\n      }\n      \n      return stdout.trim();\n    } catch (error) {\n      // Include stderr in error message for better debugging\n      if (error.stderr) {\n        error.message = `${error.message}\\n${error.stderr}`;\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Extract Git operation name from command\n   */\n  extractGitOperation(command) {\n    const parts = command.trim().split(' ');\n    if (parts.length === 0) return 'unknown';\n    \n    const operation = parts[0];\n    \n    // Map some common compound operations\n    if (operation === 'worktree' && parts[1]) {\n      return `worktree_${parts[1]}`;\n    }\n    if (operation === 'ls-tree') {\n      return 'ls_tree';\n    }\n    \n    return operation;\n  }\n\n  /**\n   * List files in a reference without checkout using git ls-tree\n   */\n  async listFiles(refId, branch = 'main', dirPath = '') {\n    const refPath = path.join(this.refsDir, refId);\n    \n    // Verify reference exists\n    await this.verifyRefExists(refId);\n    \n    try {\n      let output;\n      if (dirPath) {\n        // When listing a subdirectory, we need to get the full paths\n        output = await this.execGit(refPath, \n          `ls-tree -r --name-only --full-tree ${this.escapeArg(branch)} ${this.escapeArg(dirPath)}`\n        );\n      } else {\n        // List all files from root\n        output = await this.execGit(refPath, \n          `ls-tree -r --name-only ${this.escapeArg(branch)}`\n        );\n      }\n      \n      return output.split('\\n').filter(Boolean);\n    } catch (error) {\n      if (error.message.includes('Not a valid object name')) {\n        throw new Error(`Branch '${branch}' not found in reference '${refId}'`);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Read file content from any branch using git show\n   */\n  async readFile(refId, branch, filePath) {\n    const refPath = path.join(this.refsDir, refId);\n    \n    // Verify reference exists\n    await this.verifyRefExists(refId);\n    \n    try {\n      // Get raw buffer for binary detection\n      const content = await this.execGit(refPath,\n        `show ${this.escapeArg(branch)}:${this.escapeArg(filePath)}`,\n        { encoding: 'buffer' }\n      );\n      \n      // Check if binary by looking for null bytes\n      const isBinary = content.includes(0x00);\n      \n      return {\n        content,\n        found: true,\n        isBinary,\n        encoding: isBinary ? 'base64' : 'utf8'\n      };\n    } catch (error) {\n      if (error.message.includes('does not exist')) {\n        return { found: false };\n      }\n      if (error.message.includes('Not a valid object name')) {\n        throw new Error(`Branch '${branch}' not found in reference '${refId}'`);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Get directory listing with file metadata\n   */\n  async listDirectory(refId, branch = 'main', dirPath = '') {\n    const refPath = path.join(this.refsDir, refId);\n    \n    // Verify reference exists\n    await this.verifyRefExists(refId);\n    \n    try {\n      const treeRef = dirPath ? `${branch}:${dirPath}` : branch;\n      const output = await this.execGit(refPath,\n        `ls-tree -l ${this.escapeArg(treeRef)}`\n      );\n      \n      const entries = [];\n      for (const line of output.split('\\n').filter(Boolean)) {\n        // Parse: \"mode type hash size name\"\n        const match = line.match(/^(\\d+)\\s+(blob|tree)\\s+([a-f0-9]+)\\s+(-|\\d+)\\s+(.+)$/);\n        if (match) {\n          entries.push({\n            name: match[5],\n            type: match[2] === 'tree' ? 'directory' : 'file',\n            size: match[4] === '-' ? null : parseInt(match[4]),\n            mode: match[1],\n            hash: match[3]\n          });\n        }\n      }\n      \n      return entries;\n    } catch (error) {\n      if (error.message.includes('Not a valid object name')) {\n        throw new Error(`Branch '${branch}' or path '${dirPath}' not found in reference '${refId}'`);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Get file metadata without reading content\n   */\n  async getFileInfo(refId, branch, filePath) {\n    const refPath = path.join(this.refsDir, refId);\n    \n    // Verify reference exists\n    await this.verifyRefExists(refId);\n    \n    try {\n      const info = await this.execGit(refPath,\n        `ls-tree -l ${this.escapeArg(branch)} -- ${this.escapeArg(filePath)}`\n      );\n      \n      if (!info.trim()) {\n        return null;\n      }\n      \n      const parts = info.trim().split(/\\s+/);\n      if (parts.length < 5) {\n        return null;\n      }\n      \n      const [mode, type, hash, size, ...nameParts] = parts;\n      const name = nameParts.join(' ');\n      \n      // Get last modified date from git log\n      const lastModified = await this.execGit(refPath,\n        `log -1 --format=%aI ${this.escapeArg(branch)} -- ${this.escapeArg(filePath)}`\n      );\n      \n      return {\n        name,\n        mode,\n        type,\n        size: parseInt(size),\n        hash,\n        lastModified: lastModified.trim()\n      };\n    } catch (error) {\n      if (error.message.includes('Not a valid object name')) {\n        throw new Error(`Branch '${branch}' not found in reference '${refId}'`);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Create a git worktree for execution\n   */\n  async createWorktree(refId, executionId, targetPath) {\n    const refPath = path.join(this.refsDir, refId);\n    const branchName = `exec-${executionId}`;\n    \n    // Verify reference exists\n    await this.verifyRefExists(refId);\n    \n    try {\n      // Create new branch and worktree in one command\n      const gitCommand = `worktree add -b ${this.escapeArg(branchName)} ${this.escapeArg(targetPath)}`;\n      console.log(`[RefManager] Creating worktree with command: git ${gitCommand}`);\n      await this.execGit(refPath, gitCommand);\n      console.log(`[RefManager] Worktree created successfully at ${targetPath} with branch ${branchName}`);\n      \n      return {\n        worktreePath: targetPath,\n        branch: branchName\n      };\n    } catch (error) {\n      if (error.message.includes('already exists')) {\n        throw new Error(`Worktree or branch for execution '${executionId}' already exists`);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Remove a git worktree\n   */\n  async removeWorktree(refId, worktreePath) {\n    const refPath = path.join(this.refsDir, refId);\n    \n    try {\n      // Force remove to handle any uncommitted changes\n      await this.execGit(refPath,\n        `worktree remove --force ${this.escapeArg(worktreePath)}`\n      );\n    } catch (error) {\n      // If worktree doesn't exist, that's fine\n      if (!error.message.includes('not a working tree')) {\n        throw error;\n      }\n    }\n  }\n\n  /**\n   * List all worktrees for a reference\n   */\n  async listWorktrees(refId) {\n    const refPath = path.join(this.refsDir, refId);\n    \n    // Verify reference exists\n    await this.verifyRefExists(refId);\n    \n    const output = await this.execGit(refPath, 'worktree list --porcelain');\n    \n    const worktrees = [];\n    let current = {};\n    \n    for (const line of output.split('\\n')) {\n      if (line.startsWith('worktree ')) {\n        if (current.path) {\n          worktrees.push(current);\n        }\n        current = { path: line.substring(9) };\n      } else if (line.startsWith('HEAD ')) {\n        current.head = line.substring(5);\n      } else if (line.startsWith('branch ')) {\n        current.branch = line.substring(7);\n      } else if (line === 'detached') {\n        current.detached = true;\n      } else if (line === '') {\n        // Empty line indicates end of current worktree info\n        if (current.path) {\n          worktrees.push(current);\n          current = {};\n        }\n      }\n    }\n    \n    // Don't forget the last one if there's no trailing empty line\n    if (current.path) {\n      worktrees.push(current);\n    }\n    \n    return worktrees;\n  }\n\n  /**\n   * List branches for a reference\n   */\n  async listBranches(refId) {\n    const refPath = path.join(this.refsDir, refId);\n    \n    // Verify reference exists\n    await this.verifyRefExists(refId);\n    \n    const output = await this.execGit(refPath, 'branch -a --format=\"%(refname:short)|%(objectname)|%(committerdate:iso)|%(subject)\"');\n    \n    const branches = [];\n    for (const line of output.split('\\n').filter(Boolean)) {\n      const [name, hash, date, ...subjectParts] = line.split('|');\n      branches.push({\n        name: name.replace('origin/', ''),\n        hash,\n        date,\n        subject: subjectParts.join('|')\n      });\n    }\n    \n    // Get current branch\n    const currentBranch = await this.execGit(refPath, 'rev-parse --abbrev-ref HEAD');\n    \n    return {\n      current: currentBranch,\n      branches\n    };\n  }\n\n  /**\n   * Create a new branch\n   */\n  async createBranch(refId, branchName, fromBranch = 'main') {\n    const refPath = path.join(this.refsDir, refId);\n    \n    // Verify reference exists\n    await this.verifyRefExists(refId);\n    \n    await this.execGit(refPath,\n      `checkout -b ${this.escapeArg(branchName)} ${this.escapeArg(fromBranch)}`\n    );\n  }\n\n  /**\n   * Delete a branch\n   */\n  async deleteBranch(refId, branchName, force = false) {\n    const refPath = path.join(this.refsDir, refId);\n    \n    // Verify reference exists\n    await this.verifyRefExists(refId);\n    \n    const flag = force ? '-D' : '-d';\n    await this.execGit(refPath, `branch ${flag} ${this.escapeArg(branchName)}`);\n  }\n\n  /**\n   * Initialize a new git repository\n   */\n  async initializeRepo(refId) {\n    const refPath = path.join(this.refsDir, refId);\n    \n    // Create directory\n    await fs.mkdir(refPath, { recursive: true });\n    \n    // Initialize git\n    await this.execGit(refPath, 'init');\n    \n    // Set initial branch name to 'main'\n    await this.execGit(refPath, 'config init.defaultBranch main');\n    \n    return refPath;\n  }\n\n  /**\n   * Check if a reference exists\n   */\n  async refExists(refId) {\n    const refPath = path.join(this.refsDir, refId);\n    console.log(`[RefManager] Checking if ref exists: ${refId} at path: ${refPath}`);\n    \n    try {\n      const stat = await fs.stat(refPath);\n      if (!stat.isDirectory()) {\n        console.log(`[RefManager] Path exists but is not a directory: ${refPath}`);\n        return false;\n      }\n      console.log(`[RefManager] Directory exists: ${refPath}`);\n      \n      // Check if it's a git repository\n      try {\n        await this.execGit(refPath, 'rev-parse --git-dir');\n        console.log(`[RefManager] Git repository confirmed: ${refPath}`);\n        return true;\n      } catch (gitError) {\n        console.log(`[RefManager] Directory exists but is not a git repository: ${refPath}`, gitError.message);\n        return false;\n      }\n    } catch (error) {\n      console.log(`[RefManager] Path does not exist: ${refPath}`, error.message);\n      return false;\n    }\n  }\n\n  /**\n   * Verify that a reference exists, throw if not\n   */\n  async verifyRefExists(refId) {\n    if (!await this.refExists(refId)) {\n      throw new Error(`Reference '${refId}' does not exist`);\n    }\n  }\n\n  /**\n   * Get all references\n   */\n  async listRefs() {\n    try {\n      const entries = await fs.readdir(this.refsDir, { withFileTypes: true });\n      const refs = [];\n      \n      for (const entry of entries) {\n        if (entry.isDirectory()) {\n          const refId = entry.name;\n          if (await this.refExists(refId)) {\n            refs.push(refId);\n          }\n        }\n      }\n      \n      return refs;\n    } catch (error) {\n      if (error.code === 'ENOENT') {\n        return [];\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Escape shell arguments to prevent injection\n   */\n  escapeArg(arg) {\n    if (!arg) return \"''\";\n    // Replace single quotes with '\\'' and wrap in single quotes\n    return `'${arg.replace(/'/g, \"'\\\\''\")}'`;\n  }\n}\n\nexport default RefManager;","import { promises as fs } from 'node:fs';\nimport path from 'node:path';\nimport { default as RefManager } from './RefManager.js';\nimport { v4 as uuidv4 } from 'uuid';\nimport { spawn } from 'node:child_process';\n\nclass ExecutionContextManager {\n  constructor(workspaceManager, refManager, previewManager) {\n    this.workspaceManager = workspaceManager;\n    const workspacePath = workspaceManager.getWorkspacePath();\n    console.log(`[ExecutionContextManager] Workspace path: ${workspacePath}`);\n    this.refManager = refManager || new RefManager(workspacePath);\n    this.executionsDir = workspaceManager.getExecutionsDir();\n    console.log(`[ExecutionContextManager] Executions directory: ${this.executionsDir}`);\n    this.previewManager = previewManager; // For auto-starting previews\n  }\n\n  /**\n   * Set up complete execution workspace with references\n   */\n  async setupExecutionWorkspace(executionId, refs = {}) {\n    const executionPath = path.join(this.executionsDir, `exec-${executionId}`);\n    \n    // Create execution directory structure\n    const dirs = {\n      root: executionPath,\n      read: path.join(executionPath, 'read'),\n      mutate: path.join(executionPath, 'mutate'),\n      create: path.join(executionPath, 'create')\n    };\n    \n    // Create all directories\n    for (const dir of Object.values(dirs)) {\n      await fs.mkdir(dir, { recursive: true });\n    }\n    \n    // Ensure refs object has all arrays\n    const normalizedRefs = {\n      read: refs.read || [],\n      mutate: refs.mutate || [],\n      create: refs.create || []\n    };\n    \n    // Create manifest\n    const manifest = {\n      executionId,\n      timestamp: new Date().toISOString(),\n      refs: normalizedRefs,\n      paths: dirs\n    };\n    \n    await fs.writeFile(\n      path.join(executionPath, 'manifest.json'),\n      JSON.stringify(manifest, null, 2)\n    );\n    \n    // Set up each type of reference\n    try {\n      const skippedRefs = {\n        read: [],\n        mutate: []\n      };\n      \n      if (refs.read && refs.read.length > 0) {\n        skippedRefs.read = await this.setupReadOnlyRefs(executionId, refs.read);\n      }\n      \n      if (refs.mutate && refs.mutate.length > 0) {\n        const result = await this.setupMutableRefs(executionId, refs.mutate);\n        manifest.worktrees = result.worktrees;\n        skippedRefs.mutate = result.skippedRefs;\n      }\n      \n      if (refs.create && refs.create.length > 0) {\n        await this.setupCreateDirs(executionId, refs.create);\n      }\n      \n      // Add skipped refs to manifest\n      manifest.skippedRefs = skippedRefs;\n      \n      // Update manifest with worktree and skipped refs info\n      await fs.writeFile(\n        path.join(executionPath, 'manifest.json'),\n        JSON.stringify(manifest, null, 2)\n      );\n      \n      return {\n        executionPath,\n        manifest,\n        paths: dirs,\n        skippedRefs\n      };\n    } catch (error) {\n      // Clean up on failure\n      await this.cleanupExecutionWorkspace(executionId);\n      throw error;\n    }\n  }\n\n  /**\n   * Set up read-only references using symlinks\n   */\n  async setupReadOnlyRefs(executionId, refIds) {\n    const executionPath = path.join(this.executionsDir, `exec-${executionId}`);\n    const readDir = path.join(executionPath, 'read');\n    const skippedRefs = [];\n    \n    for (const refId of refIds) {\n      // Verify reference exists\n      if (!await this.refManager.refExists(refId)) {\n        console.error(`[ExecutionContextManager] Read reference '${refId}' does not exist!`);\n        throw new Error(`Read reference '${refId}' does not exist. Please ensure all references are properly initialized.`);\n      }\n      \n      const sourcePath = path.join(this.refManager.refsDir, refId);\n      const linkPath = path.join(readDir, refId);\n      \n      // Create symlink\n      console.log(`[ExecutionContextManager] Creating read-only symlink from ${sourcePath} to ${linkPath}`);\n      await fs.symlink(sourcePath, linkPath, 'dir');\n    }\n    \n    return skippedRefs;\n  }\n\n  /**\n   * Set up mutable references using git worktrees\n   */\n  async setupMutableRefs(executionId, refIds) {\n    const executionPath = path.join(this.executionsDir, `exec-${executionId}`);\n    const mutateDir = path.join(executionPath, 'mutate');\n    const worktrees = {};\n    const skippedRefs = [];\n    \n    for (const refId of refIds) {\n      // Verify reference exists\n      if (!await this.refManager.refExists(refId)) {\n        console.error(`[ExecutionContextManager] Mutate reference '${refId}' does not exist!`);\n        throw new Error(`Mutate reference '${refId}' does not exist. Please ensure all references are properly initialized.`);\n      }\n      \n      const worktreePath = path.join(mutateDir, refId);\n      \n      try {\n        console.log(`[ExecutionContextManager] Creating worktree for ref ${refId} at ${worktreePath}`);\n        const result = await this.refManager.createWorktree(refId, executionId, worktreePath);\n        console.log(`[ExecutionContextManager] Worktree created successfully:`, result);\n        worktrees[refId] = result;\n        \n        // Store the refId for later auto-preview start (after workspace_path is updated)\n        if (!this.pendingPreviews) {\n          this.pendingPreviews = [];\n        }\n        this.pendingPreviews.push({\n          executionId,\n          refType: 'mutate',\n          refId: refId\n        });\n      } catch (error) {\n        // Clean up any worktrees we already created\n        for (const [createdRefId, worktreeInfo] of Object.entries(worktrees)) {\n          try {\n            await this.refManager.removeWorktree(createdRefId, worktreeInfo.worktreePath);\n            // Also try to delete the branch\n            await this.refManager.deleteBranch(createdRefId, worktreeInfo.branch, true);\n          } catch (cleanupError) {\n            console.error(`Failed to clean up worktree for ${createdRefId}:`, cleanupError);\n          }\n        }\n        throw error;\n      }\n    }\n    \n    return { worktrees, skippedRefs };\n  }\n\n  /**\n   * Set up directories for new references to be created\n   */\n  async setupCreateDirs(executionId, refIds) {\n    const executionPath = path.join(this.executionsDir, `exec-${executionId}`);\n    const createDir = path.join(executionPath, 'create');\n    \n    for (const refId of refIds) {\n      // Check that reference doesn't already exist\n      if (await this.refManager.refExists(refId)) {\n        throw new Error(`Reference '${refId}' already exists`);\n      }\n      \n      // Create empty directory\n      const refDir = path.join(createDir, refId);\n      await fs.mkdir(refDir, { recursive: true });\n      console.log(`[ExecutionContextManager] Created directory for new reference: ${refDir}`);\n      \n      // Create a marker file to indicate this is a new reference\n      await fs.writeFile(\n        path.join(refDir, '.new-reference'),\n        JSON.stringify({\n          refId,\n          createdAt: new Date().toISOString(),\n          executionId,\n          type: 'create'\n        })\n      );\n      \n      // Store the refId for later auto-preview start (after workspace_path is updated)\n      if (!this.pendingPreviews) {\n        this.pendingPreviews = [];\n      }\n      this.pendingPreviews.push({\n        executionId,\n        refType: 'create',\n        refId: refId\n      });\n    }\n  }\n\n  /**\n   * Start pending previews after workspace_path is updated in database\n   */\n  async startPendingPreviews() {\n    if (!this.pendingPreviews || this.pendingPreviews.length === 0) {\n      return;\n    }\n\n    for (const preview of this.pendingPreviews) {\n      if (this.previewManager) {\n        console.log(`[ExecutionContextManager] Auto-starting preview for ${preview.refId}...`);\n        try {\n          const previewResult = await this.previewManager.startPreview(preview.executionId, {\n            refType: preview.refType,\n            refId: preview.refId,\n            installDependencies: false // Already installed by create-next-app\n          });\n          console.log(`[ExecutionContextManager] Preview started successfully:`, previewResult);\n        } catch (error) {\n          console.error(`[ExecutionContextManager] Failed to auto-start preview for ${preview.refId}:`, error);\n          // Don't throw - preview failure shouldn't stop execution\n        }\n      }\n    }\n\n    // Clear pending previews\n    this.pendingPreviews = [];\n  }\n\n  /**\n   * Get execution manifest\n   */\n  async getExecutionManifest(executionId) {\n    const manifestPath = path.join(this.executionsDir, `exec-${executionId}`, 'manifest.json');\n    \n    try {\n      const content = await fs.readFile(manifestPath, 'utf8');\n      return JSON.parse(content);\n    } catch (error) {\n      if (error.code === 'ENOENT') {\n        return null;\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Clean up execution workspace\n   */\n  async cleanupExecutionWorkspace(executionId) {\n    const manifest = await this.getExecutionManifest(executionId);\n    \n    // Remove worktrees if any\n    if (manifest && manifest.worktrees) {\n      for (const [refId, worktreeInfo] of Object.entries(manifest.worktrees)) {\n        try {\n          await this.refManager.removeWorktree(refId, worktreeInfo.worktreePath);\n          // NOTE: We intentionally keep the execution branch for audit trail\n          // The exec-{executionId} branch should remain in the refs folder\n          console.log(`Preserved execution branch ${worktreeInfo.branch} for audit trail`);\n        } catch (error) {\n          console.error(`Failed to remove worktree for ${refId}:`, error);\n        }\n      }\n    }\n    \n    // Remove execution directory\n    const executionPath = path.join(this.executionsDir, `exec-${executionId}`);\n    try {\n      await fs.rm(executionPath, { recursive: true, force: true });\n    } catch (error) {\n      if (error.code !== 'ENOENT') {\n        throw error;\n      }\n    }\n  }\n\n  /**\n   * List all active executions\n   */\n  async listExecutions() {\n    try {\n      const entries = await fs.readdir(this.executionsDir, { withFileTypes: true });\n      const executions = [];\n      \n      for (const entry of entries) {\n        if (entry.isDirectory() && entry.name.startsWith('exec-')) {\n          const executionId = entry.name.substring(5); // Remove 'exec-' prefix\n          const manifest = await this.getExecutionManifest(executionId);\n          if (manifest) {\n            executions.push({\n              executionId,\n              timestamp: manifest.timestamp,\n              refs: manifest.refs\n            });\n          }\n        }\n      }\n      \n      return executions.sort((a, b) => \n        new Date(b.timestamp) - new Date(a.timestamp)\n      );\n    } catch (error) {\n      if (error.code === 'ENOENT') {\n        return [];\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Get changes in mutable references\n   */\n  async getExecutionChanges(executionId) {\n    const manifest = await this.getExecutionManifest(executionId);\n    if (!manifest || !manifest.worktrees) {\n      return {};\n    }\n    \n    const changes = {};\n    \n    for (const [refId, worktreeInfo] of Object.entries(manifest.worktrees)) {\n      try {\n        // Get git status in worktree\n        const status = await this.refManager.execGit(\n          worktreeInfo.worktreePath,\n          'status --porcelain'\n        );\n        \n        const files = {\n          added: [],\n          modified: [],\n          deleted: []\n        };\n        \n        if (status) {\n          for (const line of status.split('\\n').filter(Boolean)) {\n            const statusCode = line.substring(0, 2);\n            const filePath = line.substring(2).trim();\n            \n            // First character is index status, second is working tree status\n            const indexStatus = statusCode[0];\n            const workingStatus = statusCode[1];\n            \n            if (statusCode === '??') {\n              // Untracked file\n              files.added.push(filePath);\n            } else if (indexStatus === 'A' || workingStatus === 'A') {\n              // Added to index or working tree\n              files.added.push(filePath);\n            } else if (indexStatus === 'M' || workingStatus === 'M') {\n              // Modified in index or working tree\n              files.modified.push(filePath);\n            } else if (indexStatus === 'D' || workingStatus === 'D') {\n              // Deleted from index or working tree\n              files.deleted.push(filePath);\n            } else if (indexStatus === 'R') {\n              // Renamed - git shows \"R  old -> new\"\n              const renameParts = filePath.split(' -> ');\n              if (renameParts.length === 2) {\n                files.deleted.push(renameParts[0]);\n                files.added.push(renameParts[1]);\n              }\n            }\n          }\n        }\n        \n        changes[refId] = {\n          branch: worktreeInfo.branch,\n          files,\n          hasChanges: files.added.length > 0 || files.modified.length > 0 || files.deleted.length > 0\n        };\n      } catch (error) {\n        console.error(`Failed to get changes for ${refId}:`, error);\n        changes[refId] = {\n          error: error.message\n        };\n      }\n    }\n    \n    return changes;\n  }\n}\n\nexport default ExecutionContextManager;","import { default as RefManager } from './RefManager.js';\nimport { default as ExecutionContextManager } from './ExecutionContextManager.js';\nimport { promises as fs } from 'node:fs';\nimport path from 'node:path';\nimport { exec } from 'node:child_process';\nimport { promisify } from 'node:util';\n\nconst execAsync = promisify(exec);\n\nclass ChangeManager {\n  constructor(workspaceManager, refManager, contextManager) {\n    this.workspaceManager = workspaceManager;\n    this.refManager = refManager || new RefManager(workspaceManager.getWorkspacePath());\n    this.contextManager = contextManager || new ExecutionContextManager(workspaceManager, this.refManager);\n  }\n\n  /**\n   * Commit changes in a worktree\n   */\n  async commitChanges(executionId, refId, message) {\n    const manifest = await this.contextManager.getExecutionManifest(executionId);\n    if (!manifest || !manifest.worktrees || !manifest.worktrees[refId]) {\n      throw new Error(`No worktree found for reference '${refId}' in execution '${executionId}'`);\n    }\n    \n    const worktreePath = manifest.worktrees[refId].worktreePath;\n    \n    // Check if there are any changes to commit\n    const status = await this.refManager.execGit(worktreePath, 'status --porcelain');\n    if (!status.trim()) {\n      return {\n        committed: false,\n        message: 'No changes to commit'\n      };\n    }\n    \n    // Stage all changes\n    await this.refManager.execGit(worktreePath, 'add -A');\n    \n    // Create commit with execution metadata\n    const fullMessage = `${message}\\n\\nExecution: ${executionId}`;\n    const commitCommand = `commit -m ${this.refManager.escapeArg(fullMessage)}`;\n    \n    try {\n      const output = await this.refManager.execGit(worktreePath, commitCommand);\n      \n      // Get the commit hash\n      const commitHash = await this.refManager.execGit(worktreePath, 'rev-parse HEAD');\n      \n      return {\n        committed: true,\n        hash: commitHash,\n        message: fullMessage,\n        output\n      };\n    } catch (error) {\n      // Check if it's just \"nothing to commit\" after staging\n      if (error.message.includes('nothing to commit')) {\n        return {\n          committed: false,\n          message: 'No changes to commit after staging'\n        };\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Sync execution branch to refs directory (preserves both main and exec branches separately)\n   */\n  async syncExecutionBranch(refId, executionBranch) {\n    const refPath = path.join(this.refManager.refsDir, refId);\n    \n    try {\n      // The execution branch already exists in the ref repository via worktree\n      // We should preserve BOTH branches independently - do NOT update main\n      \n      // Verify the execution branch exists\n      const branches = await this.refManager.execGit(refPath, 'branch -a');\n      const branchExists = branches.includes(executionBranch);\n      \n      if (!branchExists) {\n        throw new Error(`Execution branch '${executionBranch}' not found in repository`);\n      }\n      \n      // Get the commit hash of the execution branch\n      const execBranchHash = await this.refManager.execGit(refPath, `rev-parse ${this.refManager.escapeArg(executionBranch)}`);\n      \n      // Get the commit hash of main branch for comparison\n      const mainBranchHash = await this.refManager.execGit(refPath, 'rev-parse main');\n      \n      // Ensure we're on main branch for consistency\n      await this.refManager.execGit(refPath, 'checkout main');\n      \n      return {\n        synced: true,\n        preservedBranches: ['main', executionBranch],\n        execBranchHash,\n        mainBranchHash,\n        mainUpdated: false, // We intentionally do NOT update main for audit trail\n        message: `Preserved execution branch '${executionBranch}' alongside unchanged main branch for complete audit trail`\n      };\n    } catch (error) {\n      return {\n        synced: false,\n        error: error.message,\n        message: `Failed to sync execution branch '${executionBranch}': ${error.message}`\n      };\n    }\n  }\n\n  /**\n   * Initialize a new reference from created content\n   */\n  async initializeNewRef(executionId, refId) {\n    const manifest = await this.contextManager.getExecutionManifest(executionId);\n    if (!manifest) {\n      throw new Error(`Execution '${executionId}' not found`);\n    }\n    \n    // Check if this ref was in the create list\n    if (!manifest.refs.create || !manifest.refs.create.includes(refId)) {\n      throw new Error(`Reference '${refId}' was not marked for creation in execution '${executionId}'`);\n    }\n    \n    // Check if ref already exists\n    if (await this.refManager.refExists(refId)) {\n      throw new Error(`Reference '${refId}' already exists`);\n    }\n    \n    const sourcePath = path.join(manifest.paths.create, refId);\n    \n    // Check if any files were created (excluding marker file)\n    const allFiles = await this.listDirectoryRecursive(sourcePath);\n    const files = allFiles.filter(f => f !== '.new-reference');\n    \n    if (files.length === 0) {\n      throw new Error(`No files found in create directory for reference '${refId}'`);\n    }\n    \n    // Initialize the repository\n    const refPath = await this.refManager.initializeRepo(refId);\n    \n    // Copy all files\n    for (const file of files) {\n      \n      const sourceFile = path.join(sourcePath, file);\n      const destFile = path.join(refPath, file);\n      \n      // Create directory if needed\n      const destDir = path.dirname(destFile);\n      await fs.mkdir(destDir, { recursive: true });\n      \n      // Copy file\n      await fs.copyFile(sourceFile, destFile);\n    }\n    \n    // Create initial commit\n    await this.refManager.execGit(refPath, 'add -A');\n    const commitMessage = `Initial commit\\n\\nCreated from execution: ${executionId}`;\n    await this.refManager.execGit(refPath, `commit -m ${this.refManager.escapeArg(commitMessage)}`);\n    \n    const commitHash = await this.refManager.execGit(refPath, 'rev-parse HEAD');\n    \n    return {\n      refId,\n      refPath,\n      files,\n      commitHash\n    };\n  }\n\n  /**\n   * Process all changes from an execution\n   */\n  async processExecutionChanges(executionId, options = {}) {\n    const manifest = await this.contextManager.getExecutionManifest(executionId);\n    if (!manifest) {\n      throw new Error(`Execution '${executionId}' not found`);\n    }\n    \n    const results = {\n      commits: {},\n      merges: {},\n      creates: {},\n      errors: {}\n    };\n    \n    // Commit changes in mutable refs\n    if (manifest.worktrees) {\n      for (const [refId, worktreeInfo] of Object.entries(manifest.worktrees)) {\n        try {\n          const commitResult = await this.commitChanges(\n            executionId, \n            refId, \n            options.commitMessage || `Changes from execution ${executionId}`\n          );\n          results.commits[refId] = commitResult;\n          \n          // Sync execution branch if commit was successful and sync is requested\n          if (commitResult.committed && options.merge !== false) {\n            const syncResult = await this.syncExecutionBranch(\n              refId, \n              worktreeInfo.branch\n            );\n            results.merges[refId] = syncResult;\n          }\n        } catch (error) {\n          results.errors[refId] = {\n            phase: results.commits[refId] ? 'merge' : 'commit',\n            error: error.message\n          };\n        }\n      }\n    }\n    \n    // Initialize new refs\n    if (manifest.refs.create && manifest.refs.create.length > 0) {\n      for (const refId of manifest.refs.create) {\n        try {\n          const createResult = await this.initializeNewRef(executionId, refId);\n          results.creates[refId] = createResult;\n        } catch (error) {\n          results.errors[refId] = {\n            phase: 'create',\n            error: error.message\n          };\n        }\n      }\n    }\n    \n    return results;\n  }\n\n  /**\n   * List all files in a directory recursively\n   */\n  async listDirectoryRecursive(dir, basePath = '') {\n    const files = [];\n    \n    try {\n      const entries = await fs.readdir(dir, { withFileTypes: true });\n      \n      for (const entry of entries) {\n        const fullPath = path.join(dir, entry.name);\n        const relativePath = path.join(basePath, entry.name);\n        \n        if (entry.isDirectory()) {\n          const subFiles = await this.listDirectoryRecursive(fullPath, relativePath);\n          files.push(...subFiles);\n        } else {\n          files.push(relativePath);\n        }\n      }\n    } catch (error) {\n      if (error.code !== 'ENOENT') {\n        throw error;\n      }\n    }\n    \n    return files;\n  }\n}\n\nexport default ChangeManager;","import { default as ChangeManager } from './ChangeManager.js';\nimport { default as ExecutionContextManager } from './ExecutionContextManager.js';\nimport { createLogger } from '../logger.js';\n\nconst logger = createLogger('IntegrationManager');\n\nclass IntegrationManager {\n  constructor(workspaceManager, refManager, contextManager, changeManager, db) {\n    this.workspaceManager = workspaceManager;\n    this.refManager = refManager;\n    this.contextManager = contextManager || new ExecutionContextManager(workspaceManager, refManager);\n    this.changeManager = changeManager || new ChangeManager(workspaceManager, refManager, this.contextManager);\n    this.db = db;\n  }\n\n  /**\n   * Process all changes from an execution and integrate them\n   */\n  async integrateExecutionChanges(executionId, options = {}) {\n    try {\n      logger.info(`Starting integration for execution ${executionId}`);\n      \n      // Get execution manifest\n      const manifest = await this.contextManager.getExecutionManifest(executionId);\n      if (!manifest) {\n        logger.warn(`No manifest found for execution ${executionId}`);\n        return { success: false, message: 'No execution manifest found' };\n      }\n      \n      // Process all changes\n      const results = await this.changeManager.processExecutionChanges(executionId, {\n        commitMessage: options.commitMessage || `Changes from execution ${executionId}`,\n        merge: options.merge !== false,\n        mergeStrategy: options.mergeStrategy || 'merge'\n      });\n      \n      // Save change records to database\n      await this.saveChangeRecords(executionId, results);\n      \n      // Check if any syncs failed (conflicts should not occur with branch preservation)\n      const hasSyncFailures = Object.values(results.merges || {}).some(m => !m.synced);\n      if (hasSyncFailures) {\n        logger.warn(`Execution ${executionId} had sync failures`);\n        await this.markExecutionNeedsReview(executionId, 'sync_failures');\n        \n        // Provide detailed failure information\n        const failureDetails = Object.entries(results.merges || {})\n          .filter(([refId, result]) => !result.synced)\n          .reduce((acc, [refId, result]) => {\n            acc[refId] = {\n              error: result.error || 'Unknown sync failure',\n              message: result.message || 'Sync operation failed',\n              branch: `exec-${executionId}`\n            };\n            return acc;\n          }, {});\n          \n        // Store failure details in execution record\n        await this.db.run(\n          'UPDATE executions SET conflict_details = ? WHERE id = ?',\n          [JSON.stringify(failureDetails), executionId]\n        );\n      }\n      \n      // Clean up execution workspace\n      if (options.cleanup !== false && !hasSyncFailures) {\n        try {\n          await this.contextManager.cleanupExecutionWorkspace(executionId);\n          logger.info(`Cleaned up workspace for execution ${executionId}`);\n        } catch (error) {\n          logger.error(`Failed to clean up workspace for execution ${executionId}:`, error);\n          // Don't fail the integration if cleanup fails\n        }\n      }\n      \n      logger.info(`Integration completed for execution ${executionId}`, results);\n      return {\n        success: true,\n        results\n      };\n      \n    } catch (error) {\n      logger.error(`Integration failed for execution ${executionId}:`, error);\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n  }\n  \n  /**\n   * Save change records to the database\n   */\n  async saveChangeRecords(executionId, results) {\n    const inserts = [];\n    \n    // Save commit records\n    for (const [refId, commitResult] of Object.entries(results.commits || {})) {\n      if (commitResult.committed) {\n        inserts.push(this.db.run(\n          `INSERT INTO ref_changes (execution_id, ref_id, change_type, branch_name, commit_hash, commit_message) \n           VALUES (?, ?, ?, ?, ?, ?)`,\n          [executionId, refId, 'commit', `exec-${executionId}`, commitResult.hash, commitResult.message]\n        ));\n      }\n    }\n    \n    // Save merge records (branch preservation operations)\n    for (const [refId, syncResult] of Object.entries(results.merges || {})) {\n      inserts.push(this.db.run(\n        `INSERT INTO ref_changes (execution_id, ref_id, change_type, branch_name, commit_hash, merge_status) \n         VALUES (?, ?, ?, ?, ?, ?)`,\n        [executionId, refId, 'merge', `exec-${executionId}`, syncResult.execBranchHash || null, \n         syncResult.synced ? 'success' : 'failed']\n      ));\n    }\n    \n    // Save create records\n    for (const [refId, createResult] of Object.entries(results.creates || {})) {\n      inserts.push(this.db.run(\n        `INSERT INTO ref_changes (execution_id, ref_id, change_type, commit_hash, commit_message) \n         VALUES (?, ?, ?, ?, ?)`,\n        [executionId, refId, 'create', createResult.commitHash, `Initial commit\\n\\nCreated from execution: ${executionId}`]\n      ));\n    }\n    \n    await Promise.all(inserts);\n  }\n  \n  /**\n   * Mark an execution as needing manual review\n   */\n  async markExecutionNeedsReview(executionId, reason) {\n    try {\n      await this.db.run(\n        'UPDATE executions SET status = ?, needs_review = 1, review_reason = ? WHERE id = ?',\n        ['needs_review', reason, executionId]\n      );\n      logger.info(`Marked execution ${executionId} as needing review: ${reason}`);\n    } catch (error) {\n      logger.error(`Failed to mark execution ${executionId} as needing review:`, error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Get integration status for an execution\n   */\n  async getIntegrationStatus(executionId) {\n    const changes = await this.db.all(\n      'SELECT * FROM ref_changes WHERE execution_id = ? ORDER BY created_at',\n      [executionId]\n    );\n    \n    const refs = await this.db.all(\n      'SELECT * FROM execution_refs WHERE execution_id = ?',\n      [executionId]\n    );\n    \n    return {\n      executionId,\n      refs: refs.reduce((acc, ref) => {\n        if (!acc[ref.ref_id]) {\n          acc[ref.ref_id] = { permissions: [] };\n        }\n        acc[ref.ref_id].permissions.push(ref.permission);\n        return acc;\n      }, {}),\n      changes: changes.reduce((acc, change) => {\n        if (!acc[change.ref_id]) {\n          acc[change.ref_id] = [];\n        }\n        acc[change.ref_id].push({\n          type: change.change_type,\n          branch: change.branch_name,\n          commit: change.commit_hash,\n          message: change.commit_message,\n          mergeStatus: change.merge_status,\n          timestamp: change.created_at\n        });\n        return acc;\n      }, {})\n    };\n  }\n}\n\nexport default IntegrationManager;","import { promises as fs } from 'node:fs';\nimport path from 'node:path';\nimport { createLogger } from '../logger.js';\n\nconst logger = createLogger('ResourceMonitor');\n\nclass ResourceMonitor {\n  constructor(workspaceManager, db, options = {}) {\n    this.workspaceManager = workspaceManager;\n    this.db = db;\n    \n    // Resource limits (configurable)\n    this.limits = {\n      maxConcurrentExecutions: options.maxConcurrentExecutions || 10,\n      maxDiskUsageMB: options.maxDiskUsageMB || 10000, // 1GB\n      maxExecutionTimeMinutes: options.maxExecutionTimeMinutes || 60,\n      maxWorkspaceAgeDays: options.maxWorkspaceAgeDays || 7\n    };\n    \n    // Monitoring intervals\n    this.monitoringEnabled = true;\n    this.checkInterval = options.checkInterval || 300000; // 5 minutes\n    this.intervalId = null;\n  }\n\n  /**\n   * Start resource monitoring\n   */\n  start() {\n    if (this.intervalId) {\n      logger.warn('Resource monitoring already started');\n      return;\n    }\n    \n    logger.info('Starting resource monitoring with limits:', this.limits);\n    this.intervalId = setInterval(() => {\n      this.performResourceCheck().catch(error => {\n        logger.error('Resource check failed:', error);\n      });\n    }, this.checkInterval);\n  }\n\n  /**\n   * Stop resource monitoring\n   */\n  stop() {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n      this.intervalId = null;\n      logger.info('Resource monitoring stopped');\n    }\n  }\n\n  /**\n   * Check if a new execution can be started\n   */\n  async canStartExecution() {\n    const checks = await Promise.all([\n      this.checkConcurrentExecutions(),\n      this.checkDiskUsage(),\n      this.checkSystemResources()\n    ]);\n\n    console.log('Resource checks:', checks);\n    \n    return checks.every(check => check.allowed);\n  }\n\n  /**\n   * Check concurrent execution limit\n   */\n  async checkConcurrentExecutions() {\n    try {\n      const runningExecutions = await this.db.all(\n        \"SELECT COUNT(*) as count FROM executions WHERE status IN ('running', 'starting')\"\n      );\n      \n      const currentCount = runningExecutions[0]?.count || 0;\n      const allowed = currentCount < this.limits.maxConcurrentExecutions;\n      \n      return {\n        type: 'concurrent_executions',\n        allowed,\n        current: currentCount,\n        limit: this.limits.maxConcurrentExecutions,\n        message: allowed ? null : `Maximum concurrent executions (${this.limits.maxConcurrentExecutions}) reached`\n      };\n    } catch (error) {\n      logger.error('Failed to check concurrent executions:', error);\n      return { type: 'concurrent_executions', allowed: false, error: error.message };\n    }\n  }\n\n  /**\n   * Check disk usage in workspace\n   */\n  async checkDiskUsage() {\n    try {\n      const workspacePath = this.workspaceManager.getWorkspacePath();\n      const usage = await this.calculateDirectorySize(workspacePath);\n      const usageMB = usage / (1024 * 1024);\n      const allowed = usageMB < this.limits.maxDiskUsageMB;\n      \n      return {\n        type: 'disk_usage',\n        allowed,\n        current: usageMB,\n        limit: this.limits.maxDiskUsageMB,\n        message: allowed ? null : `Disk usage (${usageMB.toFixed(2)}MB) exceeds limit (${this.limits.maxDiskUsageMB}MB)`\n      };\n    } catch (error) {\n      logger.error('Failed to check disk usage:', error);\n      return { type: 'disk_usage', allowed: true, error: error.message }; // Allow on error\n    }\n  }\n\n  /**\n   * Check system resources (memory, CPU if available)\n   */\n  async checkSystemResources() {\n    try {\n      const memUsage = process.memoryUsage();\n      const memUsageMB = memUsage.heapUsed / (1024 * 1024);\n      \n      // Basic memory check - warn if using more than 512MB\n      const memoryOk = memUsageMB < 512;\n      \n      return {\n        type: 'system_resources',\n        allowed: memoryOk,\n        memory: {\n          heapUsed: memUsageMB,\n          heapTotal: memUsage.heapTotal / (1024 * 1024),\n          external: memUsage.external / (1024 * 1024)\n        },\n        message: memoryOk ? null : `High memory usage: ${memUsageMB.toFixed(2)}MB`\n      };\n    } catch (error) {\n      logger.error('Failed to check system resources:', error);\n      return { type: 'system_resources', allowed: true, error: error.message };\n    }\n  }\n\n  /**\n   * Perform periodic resource check and cleanup\n   */\n  async performResourceCheck() {\n    logger.debug('Performing resource check');\n    \n    try {\n      // Check and log current resource usage\n      const checks = await Promise.all([\n        this.checkConcurrentExecutions(),\n        this.checkDiskUsage(),\n        this.checkSystemResources()\n      ]);\n      \n      // Log warnings for resources near limits\n      checks.forEach(check => {\n        if (!check.allowed && check.message) {\n          logger.warn(`Resource limit warning: ${check.message}`);\n        }\n      });\n      \n      // Check for long-running executions\n      await this.checkLongRunningExecutions();\n      \n      // Clean up old workspace data\n      await this.cleanupOldWorkspaces();\n      \n    } catch (error) {\n      logger.error('Resource check failed:', error);\n    }\n  }\n\n  /**\n   * Check for executions that have been running too long\n   */\n  async checkLongRunningExecutions() {\n    try {\n      const cutoffTime = new Date(Date.now() - (this.limits.maxExecutionTimeMinutes * 60 * 1000));\n      const longRunning = await this.db.all(\n        \"SELECT id, created_at FROM executions WHERE status = 'running' AND created_at < ?\",\n        [cutoffTime.toISOString()]\n      );\n      \n      if (longRunning.length > 0) {\n        logger.warn(`Found ${longRunning.length} long-running executions`);\n        \n        for (const execution of longRunning) {\n          logger.warn(`Execution ${execution.id} has been running since ${execution.created_at}`);\n          \n          // Mark for review rather than auto-terminate\n          await this.db.run(\n            'UPDATE executions SET needs_review = 1, review_reason = ? WHERE id = ?',\n            [`Long-running execution (>${this.limits.maxExecutionTimeMinutes} minutes)`, execution.id]\n          );\n        }\n      }\n    } catch (error) {\n      logger.error('Failed to check long-running executions:', error);\n    }\n  }\n\n  /**\n   * Clean up old workspace data\n   */\n  async cleanupOldWorkspaces() {\n    try {\n      const cutoffTime = new Date(Date.now() - (this.limits.maxWorkspaceAgeDays * 24 * 60 * 60 * 1000));\n      const executionsDir = path.join(this.workspaceManager.getWorkspacePath(), '.execution');\n      \n      if (!await this.exists(executionsDir)) {\n        return;\n      }\n      \n      const entries = await fs.readdir(executionsDir, { withFileTypes: true });\n      let cleanedCount = 0;\n      \n      for (const entry of entries) {\n        if (entry.isDirectory() && entry.name.startsWith('exec-')) {\n          const executionPath = path.join(executionsDir, entry.name);\n          const stat = await fs.stat(executionPath);\n          \n          if (stat.mtime < cutoffTime) {\n            const executionId = entry.name.substring(5);\n            \n            // Check if execution is completed\n            const execution = await this.db.get(\n              'SELECT status FROM executions WHERE id = ?',\n              [executionId]\n            );\n            \n            if (!execution || ['completed', 'failed', 'rolled_back'].includes(execution.status)) {\n              logger.info(`Cleaning up old workspace: ${entry.name}`);\n              await fs.rm(executionPath, { recursive: true, force: true });\n              cleanedCount++;\n            }\n          }\n        }\n      }\n      \n      if (cleanedCount > 0) {\n        logger.info(`Cleaned up ${cleanedCount} old workspace directories`);\n      }\n    } catch (error) {\n      logger.error('Failed to cleanup old workspaces:', error);\n    }\n  }\n\n  /**\n   * Calculate total size of a directory\n   */\n  async calculateDirectorySize(dirPath) {\n    let totalSize = 0;\n    \n    try {\n      const entries = await fs.readdir(dirPath, { withFileTypes: true });\n      \n      for (const entry of entries) {\n        const fullPath = path.join(dirPath, entry.name);\n        \n        if (entry.isDirectory()) {\n          totalSize += await this.calculateDirectorySize(fullPath);\n        } else {\n          const stat = await fs.stat(fullPath);\n          totalSize += stat.size;\n        }\n      }\n    } catch (error) {\n      logger.debug(`Error calculating directory size for ${dirPath}:`, error.message);\n    }\n    \n    return totalSize;\n  }\n\n  /**\n   * Check if file/directory exists\n   */\n  async exists(filePath) {\n    try {\n      await fs.access(filePath);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Get current resource usage report\n   */\n  async getResourceReport() {\n    const checks = await Promise.all([\n      this.checkConcurrentExecutions(),\n      this.checkDiskUsage(),\n      this.checkSystemResources()\n    ]);\n    \n    return {\n      timestamp: new Date().toISOString(),\n      limits: this.limits,\n      usage: checks.reduce((acc, check) => {\n        acc[check.type] = check;\n        return acc;\n      }, {}),\n      healthy: checks.every(check => check.allowed)\n    };\n  }\n}\n\nexport default ResourceMonitor;","import { createLogger } from '../logger.js';\n\nconst logger = createLogger('AuditLogger');\n\nclass AuditLogger {\n  constructor(db) {\n    this.db = db;\n  }\n\n  /**\n   * Log a Git operation with full context\n   */\n  async logGitOperation(operationData) {\n    const {\n      executionId = null,\n      refId,\n      operation, // 'clone', 'checkout', 'commit', 'merge', 'push', 'fetch', etc.\n      branch = null,\n      command,\n      workingDir,\n      success,\n      duration,\n      output = null,\n      error = null,\n      metadata = {}\n    } = operationData;\n\n    try {\n      await this.db.run(`\n        INSERT INTO git_operations_log (\n          execution_id, ref_id, operation, branch, command, \n          working_dir, success, duration_ms, output, error, \n          metadata, timestamp\n        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)\n      `, [\n        executionId, refId, operation, branch, command,\n        workingDir, success ? 1 : 0, duration, output, error,\n        JSON.stringify(metadata)\n      ]);\n\n      logger.info(`Git operation logged: ${operation} on ${refId}`, {\n        executionId,\n        refId,\n        operation,\n        success,\n        duration: `${duration}ms`\n      });\n\n    } catch (dbError) {\n      logger.error('Failed to log Git operation:', dbError);\n    }\n  }\n\n  /**\n   * Log execution lifecycle events\n   */\n  async logExecutionEvent(eventData) {\n    const {\n      executionId,\n      event, // 'started', 'workspace_setup', 'refs_configured', 'process_spawned', 'completed', 'failed', 'cleanup'\n      phase = null, // 'initialization', 'execution', 'integration', 'cleanup'\n      details = {},\n      success = true,\n      duration = null,\n      error = null\n    } = eventData;\n\n    try {\n      await this.db.run(`\n        INSERT INTO execution_events_log (\n          execution_id, event, phase, details, success, \n          duration_ms, error, timestamp\n        ) VALUES (?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)\n      `, [\n        executionId, event, phase, JSON.stringify(details),\n        success ? 1 : 0, duration, error\n      ]);\n\n      logger.info(`Execution event logged: ${event}`, {\n        executionId,\n        event,\n        phase,\n        success\n      });\n\n    } catch (dbError) {\n      logger.error('Failed to log execution event:', dbError);\n    }\n  }\n\n  /**\n   * Log resource usage metrics\n   */\n  async logResourceUsage(usageData) {\n    const {\n      type, // 'disk_usage', 'concurrent_executions', 'system_resources', 'execution_duration'\n      currentValue,\n      limitValue,\n      exceeded,\n      executionId = null,\n      details = {}\n    } = usageData;\n\n    try {\n      await this.db.run(`\n        INSERT INTO resource_usage (\n          type, current_value, limit_value, exceeded, \n          execution_id, details, timestamp\n        ) VALUES (?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)\n      `, [\n        type, currentValue, limitValue, exceeded ? 1 : 0,\n        executionId, JSON.stringify(details)\n      ]);\n\n      if (exceeded) {\n        logger.warn(`Resource limit exceeded: ${type}`, {\n          type,\n          current: currentValue,\n          limit: limitValue,\n          executionId\n        });\n      } else {\n        logger.debug(`Resource usage logged: ${type}`, {\n          type,\n          current: currentValue,\n          limit: limitValue\n        });\n      }\n\n    } catch (dbError) {\n      logger.error('Failed to log resource usage:', dbError);\n    }\n  }\n\n  /**\n   * Log performance metrics\n   */\n  async logPerformanceMetric(metricData) {\n    const {\n      executionId = null,\n      operation, // 'git_operation', 'workspace_setup', 'file_read', 'integration', etc.\n      duration,\n      success,\n      metadata = {}\n    } = metricData;\n\n    try {\n      await this.db.run(`\n        INSERT INTO performance_metrics (\n          execution_id, operation, duration_ms, success, \n          metadata, timestamp\n        ) VALUES (?, ?, ?, ?, ?, CURRENT_TIMESTAMP)\n      `, [\n        executionId, operation, duration, success ? 1 : 0,\n        JSON.stringify(metadata)\n      ]);\n\n      // Log slow operations as warnings\n      if (duration > 5000) { // 5 seconds\n        logger.warn(`Slow operation detected: ${operation}`, {\n          executionId,\n          operation,\n          duration: `${duration}ms`,\n          success\n        });\n      } else {\n        logger.debug(`Performance metric logged: ${operation}`, {\n          duration: `${duration}ms`,\n          success\n        });\n      }\n\n    } catch (dbError) {\n      logger.error('Failed to log performance metric:', dbError);\n    }\n  }\n\n  /**\n   * Get audit trail for an execution\n   */\n  async getExecutionAuditTrail(executionId) {\n    try {\n      const [gitOps, events, resources, performance] = await Promise.all([\n        this.db.all(`\n          SELECT * FROM git_operations_log \n          WHERE execution_id = ? \n          ORDER BY timestamp\n        `, [executionId]),\n        \n        this.db.all(`\n          SELECT * FROM execution_events_log \n          WHERE execution_id = ? \n          ORDER BY timestamp\n        `, [executionId]),\n        \n        this.db.all(`\n          SELECT * FROM resource_usage \n          WHERE execution_id = ? \n          ORDER BY timestamp\n        `, [executionId]),\n        \n        this.db.all(`\n          SELECT * FROM performance_metrics \n          WHERE execution_id = ? \n          ORDER BY timestamp\n        `, [executionId])\n      ]);\n\n      return {\n        executionId,\n        gitOperations: gitOps.map(this.parseLogRecord),\n        events: events.map(this.parseLogRecord),\n        resourceUsage: resources.map(this.parseLogRecord),\n        performanceMetrics: performance.map(this.parseLogRecord)\n      };\n\n    } catch (error) {\n      logger.error(`Failed to get audit trail for execution ${executionId}:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get system-wide metrics summary\n   */\n  async getSystemMetrics(timeWindow = '24 hours') {\n    try {\n      const [gitOpStats, executionStats, resourceStats, perfStats] = await Promise.all([\n        this.db.all(`\n          SELECT \n            operation,\n            COUNT(*) as total_operations,\n            SUM(CASE WHEN success = 1 THEN 1 ELSE 0 END) as successful_operations,\n            AVG(duration_ms) as avg_duration_ms,\n            MAX(duration_ms) as max_duration_ms\n          FROM git_operations_log \n          WHERE timestamp > datetime('now', '-${timeWindow}')\n          GROUP BY operation\n        `),\n        \n        this.db.all(`\n          SELECT \n            event,\n            phase,\n            COUNT(*) as total_events,\n            SUM(CASE WHEN success = 1 THEN 1 ELSE 0 END) as successful_events,\n            AVG(duration_ms) as avg_duration_ms\n          FROM execution_events_log \n          WHERE timestamp > datetime('now', '-${timeWindow}')\n          GROUP BY event, phase\n        `),\n        \n        this.db.all(`\n          SELECT \n            type,\n            AVG(current_value) as avg_usage,\n            MAX(current_value) as peak_usage,\n            COUNT(CASE WHEN exceeded = 1 THEN 1 END) as violations\n          FROM resource_usage \n          WHERE timestamp > datetime('now', '-${timeWindow}')\n          GROUP BY type\n        `),\n        \n        this.db.all(`\n          SELECT \n            operation,\n            COUNT(*) as total_operations,\n            AVG(duration_ms) as avg_duration_ms,\n            MAX(duration_ms) as max_duration_ms,\n            COUNT(CASE WHEN duration_ms > 5000 THEN 1 END) as slow_operations\n          FROM performance_metrics \n          WHERE timestamp > datetime('now', '-${timeWindow}')\n          GROUP BY operation\n        `)\n      ]);\n\n      return {\n        timeWindow,\n        gitOperations: gitOpStats,\n        executionEvents: executionStats,\n        resourceUsage: resourceStats,\n        performance: perfStats,\n        generatedAt: new Date().toISOString()\n      };\n\n    } catch (error) {\n      logger.error('Failed to get system metrics:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Parse log record and handle JSON fields\n   */\n  parseLogRecord(record) {\n    const parsed = { ...record };\n    \n    // Parse JSON fields\n    ['metadata', 'details'].forEach(field => {\n      if (parsed[field]) {\n        try {\n          parsed[field] = JSON.parse(parsed[field]);\n        } catch (e) {\n          logger.warn(`Failed to parse ${field} in log record:`, e);\n        }\n      }\n    });\n    \n    return parsed;\n  }\n\n  /**\n   * Clean up old audit logs\n   */\n  async cleanupOldLogs(retentionDays = 30) {\n    const cutoffDate = `datetime('now', '-${retentionDays} days')`;\n    \n    try {\n      const results = await Promise.all([\n        this.db.run(`DELETE FROM git_operations_log WHERE timestamp < ${cutoffDate}`),\n        this.db.run(`DELETE FROM execution_events_log WHERE timestamp < ${cutoffDate}`),\n        this.db.run(`DELETE FROM resource_usage WHERE timestamp < ${cutoffDate}`),\n        this.db.run(`DELETE FROM performance_metrics WHERE timestamp < ${cutoffDate}`)\n      ]);\n\n      const totalDeleted = results.reduce((sum, result) => sum + (result.changes || 0), 0);\n      \n      logger.info(`Cleaned up ${totalDeleted} old audit log records older than ${retentionDays} days`);\n      \n      return { deletedRecords: totalDeleted, retentionDays };\n\n    } catch (error) {\n      logger.error('Failed to cleanup old audit logs:', error);\n      throw error;\n    }\n  }\n}\n\nexport default AuditLogger;","import { createLogger } from '../logger.js';\n\nconst logger = createLogger('PerformanceMonitor');\n\nclass PerformanceMonitor {\n  constructor(auditLogger = null) {\n    this.auditLogger = auditLogger;\n    this.activeOperations = new Map(); // Track ongoing operations\n    this.metrics = {\n      operationCounts: new Map(),\n      averageDurations: new Map(),\n      errorCounts: new Map()\n    };\n  }\n\n  /**\n   * Start timing an operation\n   */\n  startTiming(operationId, operation, metadata = {}) {\n    const startTime = Date.now();\n    \n    this.activeOperations.set(operationId, {\n      operation,\n      startTime,\n      metadata\n    });\n\n    logger.debug(`Started timing operation: ${operation}`, {\n      operationId,\n      operation,\n      metadata\n    });\n\n    return operationId;\n  }\n\n  /**\n   * End timing an operation\n   */\n  async endTiming(operationId, success = true, error = null, additionalMetadata = {}) {\n    const operationData = this.activeOperations.get(operationId);\n    \n    if (!operationData) {\n      logger.warn(`Operation ${operationId} not found in active operations`);\n      return null;\n    }\n\n    const endTime = Date.now();\n    const duration = endTime - operationData.startTime;\n    \n    // Update in-memory metrics\n    this.updateMetrics(operationData.operation, duration, success);\n    \n    // Log to audit system if available\n    if (this.auditLogger) {\n      const executionId = operationData.metadata.executionId || null;\n      \n      await this.auditLogger.logPerformanceMetric({\n        executionId,\n        operation: operationData.operation,\n        duration,\n        success,\n        metadata: {\n          ...operationData.metadata,\n          ...additionalMetadata,\n          error: error?.message || null\n        }\n      });\n    }\n\n    // Clean up\n    this.activeOperations.delete(operationId);\n\n    logger.debug(`Completed timing operation: ${operationData.operation}`, {\n      operationId,\n      operation: operationData.operation,\n      duration: `${duration}ms`,\n      success\n    });\n\n    return {\n      operation: operationData.operation,\n      duration,\n      success,\n      metadata: { ...operationData.metadata, ...additionalMetadata }\n    };\n  }\n\n  /**\n   * Instrument a function with automatic timing\n   */\n  async instrument(operation, fn, metadata = {}) {\n    const operationId = this.generateOperationId();\n    \n    this.startTiming(operationId, operation, metadata);\n    \n    try {\n      const result = await fn();\n      await this.endTiming(operationId, true, null, { resultType: typeof result });\n      return result;\n    } catch (error) {\n      await this.endTiming(operationId, false, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Instrument a Git operation specifically\n   */\n  async instrumentGitOperation(gitOperationData, fn) {\n    const {\n      executionId,\n      refId,\n      operation,\n      branch,\n      command,\n      workingDir\n    } = gitOperationData;\n\n    const operationId = this.generateOperationId();\n    const startTime = Date.now();\n    \n    this.startTiming(operationId, `git_${operation}`, {\n      executionId,\n      refId,\n      operation,\n      branch,\n      command,\n      workingDir\n    });\n\n    let output = null;\n    let error = null;\n    let success = false;\n\n    try {\n      output = await fn();\n      success = true;\n      return output;\n    } catch (err) {\n      error = err;\n      success = false;\n      throw err;\n    } finally {\n      const duration = Date.now() - startTime;\n      \n      // Log to audit system\n      if (this.auditLogger) {\n        await this.auditLogger.logGitOperation({\n          ...gitOperationData,\n          success,\n          duration,\n          output: typeof output === 'string' ? output : null,\n          error: error?.message || null,\n          metadata: {\n            commandLength: command.length,\n            hasOutput: !!output\n          }\n        });\n      }\n\n      await this.endTiming(operationId, success, error);\n    }\n  }\n\n  /**\n   * Update in-memory metrics\n   */\n  updateMetrics(operation, duration, success) {\n    // Update operation counts\n    const currentCount = this.metrics.operationCounts.get(operation) || 0;\n    this.metrics.operationCounts.set(operation, currentCount + 1);\n\n    // Update average durations\n    const currentAvg = this.metrics.averageDurations.get(operation) || { total: 0, count: 0 };\n    currentAvg.total += duration;\n    currentAvg.count += 1;\n    this.metrics.averageDurations.set(operation, currentAvg);\n\n    // Update error counts\n    if (!success) {\n      const currentErrors = this.metrics.errorCounts.get(operation) || 0;\n      this.metrics.errorCounts.set(operation, currentErrors + 1);\n    }\n  }\n\n  /**\n   * Get current performance metrics\n   */\n  getMetrics() {\n    const metrics = {};\n\n    for (const [operation, count] of this.metrics.operationCounts) {\n      const avgData = this.metrics.averageDurations.get(operation) || { total: 0, count: 0 };\n      const errorCount = this.metrics.errorCounts.get(operation) || 0;\n      \n      metrics[operation] = {\n        totalOperations: count,\n        averageDuration: avgData.count > 0 ? Math.round(avgData.total / avgData.count) : 0,\n        totalDuration: avgData.total,\n        errorCount,\n        successRate: count > 0 ? ((count - errorCount) / count * 100).toFixed(2) + '%' : '100%'\n      };\n    }\n\n    return {\n      metrics,\n      activeOperations: this.activeOperations.size,\n      generatedAt: new Date().toISOString()\n    };\n  }\n\n  /**\n   * Get slow operations report\n   */\n  getSlowOperations(thresholdMs = 5000) {\n    const slowOps = [];\n\n    for (const [operation, avgData] of this.metrics.averageDurations) {\n      const avgDuration = avgData.count > 0 ? avgData.total / avgData.count : 0;\n      \n      if (avgDuration > thresholdMs) {\n        slowOps.push({\n          operation,\n          averageDuration: Math.round(avgDuration),\n          totalOperations: avgData.count,\n          totalDuration: avgData.total\n        });\n      }\n    }\n\n    return slowOps.sort((a, b) => b.averageDuration - a.averageDuration);\n  }\n\n  /**\n   * Reset metrics (useful for testing or periodic resets)\n   */\n  resetMetrics() {\n    this.metrics = {\n      operationCounts: new Map(),\n      averageDurations: new Map(),\n      errorCounts: new Map()\n    };\n    \n    logger.info('Performance metrics reset');\n  }\n\n  /**\n   * Generate unique operation ID\n   */\n  generateOperationId() {\n    return `op_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  /**\n   * Get summary of active operations\n   */\n  getActiveOperations() {\n    const operations = [];\n    const now = Date.now();\n\n    for (const [operationId, data] of this.activeOperations) {\n      operations.push({\n        operationId,\n        operation: data.operation,\n        duration: now - data.startTime,\n        metadata: data.metadata\n      });\n    }\n\n    return operations.sort((a, b) => b.duration - a.duration);\n  }\n\n  /**\n   * Check for stuck operations (running too long)\n   */\n  getStuckOperations(thresholdMs = 300000) { // 5 minutes\n    const now = Date.now();\n    const stuckOps = [];\n\n    for (const [operationId, data] of this.activeOperations) {\n      const duration = now - data.startTime;\n      if (duration > thresholdMs) {\n        stuckOps.push({\n          operationId,\n          operation: data.operation,\n          duration,\n          startTime: new Date(data.startTime).toISOString(),\n          metadata: data.metadata\n        });\n      }\n    }\n\n    if (stuckOps.length > 0) {\n      logger.warn(`Found ${stuckOps.length} potentially stuck operations`, { stuckOps });\n    }\n\n    return stuckOps;\n  }\n}\n\nexport default PerformanceMonitor;","// Claude SDK uses ES modules, so we need to use dynamic import\nimport path from 'node:path';\nimport fs from 'node:fs';\nimport { \n  Events, \n  ExecutionStatus,\n  LogType,\n  ErrorCodes\n} from './constants.js';\nimport { createLogger } from './logger.js';\n\nlet query: any;\n\nconst logger = createLogger('ClaudeSDKManager');\n\nclass ClaudeSDKManager {\n  constructor(db, config, eventEmitter, workspaceManager) {\n    this.db = db;\n    this.config = config;\n    this.eventEmitter = eventEmitter;\n    this.workspaceManager = workspaceManager;\n    this.activeSessions = new Map(); // executionId -> { sessionId, abortController }\n    this.pendingMessages = new Map(); // executionId -> originalMessage (for compact retry)\n    this.sdkLoaded = false;\n    this.loadSDK();\n  }\n\n  async loadSDK() {\n    try {\n      const claudeSDK = await import('@anthropic-ai/claude-code');\n      query = claudeSDK.query;\n      this.sdkLoaded = true;\n      logger.info('Claude SDK loaded successfully');\n    } catch (error) {\n      logger.error('Failed to load Claude SDK', { error });\n      throw new Error('Claude SDK not available');\n    }\n  }\n\n  /**\n   * Emit execution phase updates for frontend tracking\n   */\n  async emitPhaseUpdate(executionId, phase, message) {\n    const phaseMessage = {\n      type: 'system',\n      subtype: 'phase',\n      phase,\n      message,\n      timestamp: new Date().toISOString()\n    };\n    \n    // Log to database for SSE streaming\n    await this.db.run(\n      'INSERT INTO logs (execution_id, type, content) VALUES (?, ?, ?)',\n      [executionId, LogType.SYSTEM, JSON.stringify(phaseMessage)]\n    );\n    \n    // Also emit through event emitter\n    this.eventEmitter.emit(Events.LOG_ENTRY, {\n      executionId,\n      timestamp: phaseMessage.timestamp,\n      type: LogType.SYSTEM,\n      content: JSON.stringify(phaseMessage)\n    });\n    \n    logger.info('Emitted phase update', { executionId, phase, message });\n  }\n\n  async updateHeartbeat(executionId) {\n    await this.db.run(\n      'UPDATE executions SET last_heartbeat = CURRENT_TIMESTAMP WHERE id = ?',\n      [executionId]\n    );\n  }\n\n  async startExecution(executionId, prompt, workingDir, options = {}) {\n    // Ensure SDK is loaded\n    if (!this.sdkLoaded) {\n      await this.loadSDK();\n    }\n    \n    // Check if there's already an active session for this execution\n    if (this.activeSessions.has(executionId)) {\n      if (options.isResume) {\n        logger.info('Cleaning up existing session for resume', { executionId });\n      } else {\n        logger.warn('Execution already has an active session, stopping existing and starting new', { executionId });\n      }\n      await this.stopExecution(executionId);\n    }\n    \n    try {\n      // Always use the execution workspace directory\n      const workspacePath = this.workspaceManager ? this.workspaceManager.getWorkspacePath() : process.cwd();\n      const executionCwd = path.join(workspacePath, '.execution', `exec-${executionId}`);\n      \n      // Create the execution directory if it doesn't exist\n      fs.mkdirSync(executionCwd, { recursive: true });\n      \n      if (options.isResume) {\n        logger.info('Resuming Claude SDK execution', { \n          executionId, \n          executionCwd, \n          sessionId: options.sessionId,\n          action: 'session_resume'\n        });\n      } else {\n        logger.info('Starting Claude SDK execution', { \n          executionId, \n          executionCwd, \n          providedWorkingDir: workingDir,\n          action: 'new_execution'\n        });\n      }\n\n      // Create abort controller for this execution\n      const abortController = new AbortController();\n      \n      // Prepare query options\n      const queryOptions = {\n        prompt,\n        abortController,\n        options: {\n          verbose: true,\n          print: true,\n          outputFormat: 'stream-json',\n          permissionMode: 'bypassPermissions',\n          cwd: executionCwd,\n          ...options\n        }\n      };\n      \n      logger.info('Claude SDK query options', { \n        executionId, \n        cwd: executionCwd,\n        queryOptions\n      });\n\n      // If resuming a session, add the session ID\n      if (options.sessionId) {\n        queryOptions.options.resume = options.sessionId;\n        logger.info('Resuming existing session', { executionId, sessionId: options.sessionId });\n      }\n\n      // Store session info\n      this.activeSessions.set(executionId, {\n        sessionId: null,\n        abortController,\n        messageCount: 0,\n        startTime: Date.now()\n      });\n\n      // Update execution status\n      await this.updateExecutionStatus(executionId, ExecutionStatus.RUNNING);\n\n      // Start the query and process messages\n      this.processExecution(executionId, queryOptions).catch(error => {\n        logger.error('Execution processing error', { executionId, error });\n        this.handleExecutionError(executionId, error);\n      });\n\n      return true;\n    } catch (error) {\n      logger.error('Failed to start execution', { executionId, error });\n      await this.updateExecutionStatus(executionId, ExecutionStatus.FAILED);\n      throw error;\n    }\n  }\n\n  async processExecution(executionId, queryOptions) {\n    const session = this.activeSessions.get(executionId);\n    if (!session) {\n      throw new Error('Session not found');\n    }\n\n    try {\n      let heartbeatCounter = 0;\n      \n      for await (const message of query(queryOptions)) {\n        // Update message count\n        session.messageCount++;\n\n        // Update heartbeat every 10 messages\n        heartbeatCounter++;\n        if (heartbeatCounter % 10 === 0) {\n          await this.updateHeartbeat(executionId);\n        }\n\n        // Handle different message types\n        await this.handleMessage(executionId, message);\n\n        // Capture session ID from init message\n        if (message.type === 'system' && message.subtype === 'init' && message.session_id) {\n          session.sessionId = message.session_id;\n          \n          // Update database with session ID\n          await this.db.run(\n            'UPDATE executions SET session_id = ? WHERE id = ?',\n            [message.session_id, executionId]\n          );\n        }\n\n        // Handle completion\n        if (message.type === 'result') {\n          await this.handleExecutionComplete(executionId, message);\n        }\n      }\n    } catch (error) {\n      if (error.name === 'AbortError') {\n        logger.info('Execution aborted', { executionId });\n        await this.updateExecutionStatus(executionId, ExecutionStatus.CANCELLED);\n        // Note: ready_for_preview phase is now emitted earlier for create refs\n      } else {\n        throw error;\n      }\n    }\n  }\n\n  async handleMessage(executionId, message) {\n    const timestamp = new Date().toISOString();\n    \n    // Log the raw message for debugging\n    logger.debug('Received message', { \n      executionId, \n      type: message.type,\n      subtype: message.subtype,\n      message: message \n    });\n\n    // Check if this message contains \"Prompt is too long\" error\n    const messageStr = JSON.stringify(message).toLowerCase();\n    if (messageStr.includes('prompt is too long')) {\n      logger.warn('DEBUG: Found \"Prompt is too long\" in message', {\n        executionId,\n        messageType: message.type,\n        messageSubtype: message.subtype,\n        messageContent: JSON.stringify(message, null, 2)\n      });\n    }\n\n    // Determine log type based on message type\n    let logType = LogType.STDOUT;\n    \n    switch (message.type) {\n      case 'system':\n      case 'result':\n        logType = LogType.SYSTEM;\n        break;\n      case 'error':\n        logType = LogType.STDERR;\n        break;\n      default:\n        logType = LogType.STDOUT;\n        break;\n    }\n\n    // Save to database with structured content\n    await this.db.run(\n      'INSERT INTO logs (execution_id, type, content) VALUES (?, ?, ?)',\n      [executionId, logType, JSON.stringify(message)]\n    );\n\n    // Emit log event for SSE streaming with structured message\n    this.eventEmitter.emit(Events.LOG_ENTRY, {\n      executionId,\n      timestamp,\n      type: logType,\n      content: JSON.stringify(message)\n    });\n  }\n\n  async sendMessage(executionId, message) {\n\n    console.log('Sending message to execution', { executionId, message });\n\n    const execution = await this.db.get(\n      'SELECT * FROM executions WHERE id = ?',\n      [executionId]\n    );\n\n    console.log('Execution found', { execution });\n\n    if (!execution) {\n      throw new Error(ErrorCodes.EXECUTION_NOT_FOUND);\n    }\n\n    // Check if we have a session ID\n    if (!execution.session_id) {\n      throw new Error('No session ID found for execution');\n    }\n\n    // Store the original message for potential compact retry\n    this.pendingMessages.set(executionId, message);\n\n    // Start a new execution with the message as prompt, resuming the session\n    // Note: working_dir is ignored - we always use the execution workspace\n    await this.startExecution(executionId, message, null, {\n      sessionId: execution.session_id,\n    });\n\n    return true;\n  }\n\n  async stopExecution(executionId) {\n    const session = this.activeSessions.get(executionId);\n    \n    if (!session) {\n      return false;\n    }\n\n    logger.info('Stopping execution', { executionId });\n    \n    // Abort the query\n    if (session.abortController) {\n      session.abortController.abort();\n    }\n\n    // Clean up\n    this.activeSessions.delete(executionId);\n    \n    return true;\n  }\n\n  async cleanup(executionId) {\n    await this.stopExecution(executionId);\n    this.pendingMessages.delete(executionId);\n    this.eventEmitter.emit(Events.BUFFER_FLUSH, { executionId });\n  }\n\n  isExecutionRunning(executionId) {\n    return this.activeSessions.has(executionId);\n  }\n\n  /**\n   * Check if an execution is currently active (alias for isExecutionRunning)\n   */\n  isExecutionActive(executionId) {\n    return this.activeSessions.has(executionId);\n  }\n\n  /**\n   * Check if an error indicates the prompt is too long\n   */\n  isPromptTooLongError(error) {\n    if (!error) return false;\n    \n    // Check if error message contains \"Prompt is too long\"\n    const errorMessage = error.message || error.toString() || '';\n    return errorMessage.toLowerCase().includes('prompt is too long');\n  }\n\n  /**\n   * Wait for compact operation to complete\n   */\n  async waitForCompactCompletion(executionId) {\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        logger.error('Compact operation timed out', { executionId });\n        reject(new Error('Compact operation timed out'));\n      }, 120000); // 2 minute timeout for compact\n\n      logger.info('Setting up compact completion listener', { executionId });\n\n      // Listen for completion events - we need to wait for the result message type\n      const completionHandler = ({ executionId: completedId, code, result }) => {\n        logger.info('Received PROCESS_EXIT event', { \n          completedId, \n          targetExecutionId: executionId, \n          code, \n          hasResult: !!result \n        });\n        \n        if (completedId === executionId) {\n          clearTimeout(timeout);\n          this.eventEmitter.off(Events.PROCESS_EXIT, completionHandler);\n          \n          if (code === 0 || (result && !result.is_error)) {\n            logger.info('Compact operation completed successfully', { executionId });\n            resolve();\n          } else {\n            logger.error('Compact operation failed', { executionId, code, result });\n            reject(new Error('Compact operation failed'));\n          }\n        }\n      };\n\n      // Also listen for the session to be removed from activeSessions (which happens when execution completes)\n      const checkCompletion = setInterval(() => {\n        if (!this.activeSessions.has(executionId)) {\n          logger.info('Compact session no longer active, assuming completion', { executionId });\n          clearTimeout(timeout);\n          clearInterval(checkCompletion);\n          this.eventEmitter.off(Events.PROCESS_EXIT, completionHandler);\n          resolve();\n        }\n      }, 1000); // Check every second\n\n      this.eventEmitter.on(Events.PROCESS_EXIT, completionHandler);\n    });\n  }\n\n  /**\n   * Compact conversation and retry with original message\n   */\n  async compactAndRetry(executionId, originalMessage, sessionId) {\n    const timestamp = new Date().toISOString();\n    \n    try {\n      // Log compacting start to database for frontend display\n      const compactStartMessage = {\n        type: 'assistant',\n        message: {\n          id: `msg_compact_start_${Date.now()}`,\n          type: 'message',\n          role: 'assistant',\n          model: 'claude-code-system',\n          content: [{\n            type: 'text',\n            text: ' Compacting conversation to reduce context length...'\n          }],\n          stop_reason: null,\n          stop_sequence: null,\n          usage: null\n        },\n        parent_tool_use_id: null,\n        session_id: sessionId\n      };\n      \n      await this.db.run(\n        'INSERT INTO logs (execution_id, type, content) VALUES (?, ?, ?)',\n        [executionId, LogType.SYSTEM, JSON.stringify(compactStartMessage)]\n      );\n      \n      // Emit for SSE streaming\n      this.eventEmitter.emit(Events.LOG_ENTRY, {\n        executionId,\n        timestamp,\n        type: LogType.SYSTEM,\n        content: JSON.stringify(compactStartMessage)\n      });\n      \n      logger.info('Starting conversation compact', { executionId, action: 'compact_start' });\n      \n      // Send /compact command\n      logger.info('Sending /compact command', { executionId, sessionId });\n      await this.startExecution(executionId, '/compact', null, { \n        sessionId: sessionId,\n        isCompact: true \n      });\n      \n      logger.info('Compact command sent, waiting for completion...', { executionId });\n      \n      // Wait for compact to complete\n      await this.waitForCompactCompletion(executionId);\n      \n      logger.info('Compact wait completed', { executionId });\n      \n      // Log completion\n      const compactCompleteMessage = {\n        type: 'assistant',\n        message: {\n          id: `msg_compact_complete_${Date.now()}`,\n          type: 'message',\n          role: 'assistant',\n          model: 'claude-code-system',\n          content: [{\n            type: 'text',\n            text: ' Conversation compacted successfully. Sending original message...'\n          }],\n          stop_reason: null,\n          stop_sequence: null,\n          usage: null\n        },\n        parent_tool_use_id: null,\n        session_id: sessionId\n      };\n      \n      await this.db.run(\n        'INSERT INTO logs (execution_id, type, content) VALUES (?, ?, ?)',\n        [executionId, LogType.SYSTEM, JSON.stringify(compactCompleteMessage)]\n      );\n      \n      this.eventEmitter.emit(Events.LOG_ENTRY, {\n        executionId,\n        timestamp: new Date().toISOString(),\n        type: LogType.SYSTEM,\n        content: JSON.stringify(compactCompleteMessage)\n      });\n      \n      logger.info('Compact completed, sending original message', { executionId, action: 'compact_complete' });\n      \n      // Send original message after compact\n      await this.startExecution(executionId, originalMessage, null, { sessionId: sessionId });\n      \n    } catch (error) {\n      logger.error('Compact and retry failed', { executionId, error });\n      \n      // Log error to database\n      const errorMessage = {\n        type: 'assistant',\n        message: {\n          id: `msg_compact_error_${Date.now()}`,\n          type: 'message',\n          role: 'assistant',\n          model: 'claude-code-system',\n          content: [{\n            type: 'text',\n            text: ` Compact failed: ${error.message}`\n          }],\n          stop_reason: null,\n          stop_sequence: null,\n          usage: null\n        },\n        parent_tool_use_id: null,\n        session_id: sessionId\n      };\n      \n      await this.db.run(\n        'INSERT INTO logs (execution_id, type, content) VALUES (?, ?, ?)',\n        [executionId, LogType.SYSTEM, JSON.stringify(errorMessage)]\n      );\n      \n      this.eventEmitter.emit(Events.LOG_ENTRY, {\n        executionId,\n        timestamp: new Date().toISOString(),\n        type: LogType.SYSTEM,\n        content: JSON.stringify(errorMessage)\n      });\n      \n      throw error;\n    }\n  }\n\n  async updateExecutionStatus(executionId, status) {\n    const updates = ['status = ?'];\n    const params = [status];\n\n    if (status === ExecutionStatus.COMPLETED || status === ExecutionStatus.FAILED) {\n      updates.push('completed_at = CURRENT_TIMESTAMP');\n    }\n\n    params.push(executionId);\n\n    await this.db.run(\n      `UPDATE executions SET ${updates.join(', ')} WHERE id = ?`,\n      params\n    );\n  }\n\n  async handleExecutionComplete(executionId, result) {\n    logger.info('Execution completed', { \n      executionId, \n      turns: result.num_turns,\n      duration: result.duration_ms,\n      cost: result.total_cost_usd \n    });\n\n    // Add comprehensive logging to debug prompt length detection\n    logger.info('DEBUG: Complete result object structure', {\n      executionId,\n      resultKeys: Object.keys(result),\n      resultType: typeof result,\n      isError: result.is_error,\n      hasResult: !!result.result,\n      resultValueType: typeof result.result,\n      resultContent: result.result ? result.result.toString().substring(0, 200) : 'null',\n      resultIncludes: result.result ? result.result.toLowerCase().includes('prompt is too long') : false,\n      fullResult: JSON.stringify(result, null, 2)\n    });\n\n    // Check if this is a \"Prompt is too long\" error\n    const isPromptTooLong = result.is_error && \n                           result.result && \n                           result.result.toLowerCase().includes('prompt is too long');\n\n    logger.info('DEBUG: Prompt too long check', {\n      executionId,\n      isPromptTooLong,\n      isError: result.is_error,\n      hasResult: !!result.result,\n      resultLowerCase: result.result ? result.result.toLowerCase() : 'null'\n    });\n\n    if (isPromptTooLong) {\n      logger.warn('Detected prompt too long error, attempting compact and retry', { executionId });\n      \n      // Get the original message that caused this issue\n      const originalMessage = this.pendingMessages.get(executionId);\n      \n      if (originalMessage) {\n        try {\n          // Get execution details for session ID\n          const execution = await this.db.get(\n            'SELECT session_id FROM executions WHERE id = ?',\n            [executionId]\n          );\n          \n          if (execution && execution.session_id) {\n            // Clean up current tracking\n            this.activeSessions.delete(executionId);\n            this.pendingMessages.delete(executionId);\n            \n            // Attempt compact and retry\n            await this.compactAndRetry(executionId, originalMessage, execution.session_id);\n            return; // Don't complete the execution yet\n          }\n        } catch (error) {\n          logger.error('Failed to compact and retry', { executionId, error });\n          // Fall through to normal completion handling\n        }\n      }\n    }\n\n    // Clean up pending message\n    this.pendingMessages.delete(executionId);\n\n    // Update execution with completion details\n    await this.db.run(\n      `UPDATE executions SET \n        status = ?, \n        completed_at = CURRENT_TIMESTAMP,\n        message_count = ?,\n        total_cost = ?\n      WHERE id = ?`,\n      [ExecutionStatus.COMPLETED, result.num_turns, result.total_cost_usd, executionId]\n    );\n\n    // Note: ready_for_preview phase is now emitted earlier for create refs\n\n    // Emit completion event\n    this.eventEmitter.emit(Events.PROCESS_EXIT, { \n      executionId, \n      code: 0, \n      signal: null,\n      result \n    });\n\n    // Clean up\n    this.activeSessions.delete(executionId);\n  }\n\n  async handleExecutionError(executionId, error) {\n    logger.error('Execution error', { executionId, error });\n    \n    await this.updateExecutionStatus(executionId, ExecutionStatus.FAILED);\n    \n    await this.db.run(\n      'INSERT INTO logs (execution_id, type, content) VALUES (?, ?, ?)',\n      [executionId, LogType.SYSTEM, `Execution error: ${error.message}`]\n    );\n\n    // Note: ready_for_preview phase is now emitted earlier for create refs\n\n    this.eventEmitter.emit(Events.PROCESS_ERROR, { executionId, error });\n    \n    // Clean up\n    this.activeSessions.delete(executionId);\n    this.pendingMessages.delete(executionId);\n  }\n\n  /**\n   * Resume a Claude SDK session after server restart\n   */\n  async resumeSession(executionId, sessionId) {\n    logger.info('Resuming Claude SDK session', { executionId, sessionId });\n    \n    try {\n      // Get execution details\n      const execution = await this.db.get(\n        'SELECT * FROM executions WHERE id = ?',\n        [executionId]\n      );\n      \n      if (!execution) {\n        throw new Error(`Execution ${executionId} not found`);\n      }\n      \n      // Get the execution workspace directory\n      const workspacePath = this.workspaceManager ? this.workspaceManager.getWorkspacePath() : process.cwd();\n      const executionCwd = path.join(workspacePath, '.execution', `exec-${executionId}`);\n      \n      // Create a placeholder prompt for resumption\n      const resumePrompt = 'Resuming session after server restart. Continue with the current task.';\n      \n      // Start execution with the session ID\n      await this.startExecution(executionId, resumePrompt, executionCwd, {\n        sessionId: sessionId,\n        maxTurns: 50, // Allow more turns for resumed sessions\n        isResume: true // Flag this as a session resumption\n      });\n      \n      logger.info('Successfully resumed session', { executionId, sessionId });\n      return true;\n    } catch (error) {\n      logger.error('Failed to resume session', { executionId, sessionId, error });\n      \n      // Update execution status to failed if resume fails\n      await this.updateExecutionStatus(executionId, ExecutionStatus.FAILED);\n      \n      throw error;\n    }\n  }\n}\n\nexport default ClaudeSDKManager;","import net from 'node:net';\nimport { createLogger } from '../logger.js';\n\nconst logger = createLogger('portAllocator');\n\nclass PortAllocator {\n  constructor(db) {\n    this.db = db;\n    this.basePort = 3000;\n    this.maxPort = 9000;\n  }\n\n  async allocatePort(preferredPort = null) {\n    try {\n      if (preferredPort) {\n        logger.info(`Checking if preferred port ${preferredPort} is available`);\n        const isAvailable = await this.isPortAvailable(preferredPort);\n        logger.info(`Port ${preferredPort} available: ${isAvailable}`);\n        \n        if (isAvailable) {\n          await this.markPortAllocated(preferredPort);\n          return preferredPort;\n        }\n      }\n\n      logger.info(`Searching for available port starting from ${this.basePort}`);\n      for (let port = this.basePort; port <= this.maxPort; port++) {\n        const isAvailable = await this.isPortAvailable(port);\n        if (isAvailable) {\n          logger.info(`Found available port: ${port}`);\n          await this.markPortAllocated(port);\n          return port;\n        }\n      }\n\n      throw new Error('No available ports in the configured range');\n    } catch (error) {\n      logger.error('Error allocating port:', error);\n      throw error;\n    }\n  }\n\n  async releasePort(port) {\n    try {\n      await this.db.run('DELETE FROM port_allocations WHERE port = ?', [port]);\n      logger.info(`Released port ${port}`);\n    } catch (error) {\n      logger.error(`Error releasing port ${port}:`, error);\n      throw error;\n    }\n  }\n\n  async releasePortsByPreviewId(previewId) {\n    try {\n      await this.db.run('DELETE FROM port_allocations WHERE preview_id = ?', [previewId]);\n      logger.info(`Released all ports for preview ${previewId}`);\n    } catch (error) {\n      logger.error(`Error releasing ports for preview ${previewId}:`, error);\n      throw error;\n    }\n  }\n\n  async isPortAvailable(port) {\n    const dbAllocated = await this.isPortAllocatedInDb(port);\n    if (dbAllocated) {\n      return false;\n    }\n\n    // Test both localhost and all interfaces to be thorough\n    const interfacesToTest = ['127.0.0.1', '0.0.0.0'];\n    \n    for (const host of interfacesToTest) {\n      const available = await this.checkPortOnInterface(port, host);\n      if (!available) {\n        logger.info(`Port ${port} is not available on ${host}`);\n        return false;\n      }\n    }\n    \n    return true;\n  }\n\n  async checkPortOnInterface(port, host) {\n    return new Promise((resolve) => {\n      const server = net.createServer();\n      \n      server.once('error', (err) => {\n        if (err.code === 'EADDRINUSE') {\n          resolve(false);\n        } else {\n          // Other errors also mean the port is not available\n          resolve(false);\n        }\n      });\n\n      server.once('listening', () => {\n        server.close(() => {\n          resolve(true);\n        });\n      });\n\n      try {\n        server.listen(port, host);\n      } catch (error) {\n        resolve(false);\n      }\n    });\n  }\n\n  async isPortAllocatedInDb(port) {\n    const result = await this.db.get(\n      'SELECT port FROM port_allocations WHERE port = ?',\n      [port]\n    );\n    return !!result;\n  }\n\n  async markPortAllocated(port, previewId) {\n    await this.db.run(\n      'INSERT INTO port_allocations (port, preview_id) VALUES (?, ?)',\n      [port, previewId || 'pending']\n    );\n  }\n\n  async updatePortAllocation(port, previewId) {\n    await this.db.run(\n      'UPDATE port_allocations SET preview_id = ? WHERE port = ?',\n      [previewId, port]\n    );\n  }\n\n  async getAllocatedPorts() {\n    const rows = await this.db.all(\n      'SELECT port, preview_id, allocated_at FROM port_allocations ORDER BY port'\n    );\n    return rows;\n  }\n\n  async cleanupStaleAllocations() {\n    try {\n      const staleAllocations = await this.db.all(`\n        SELECT pa.port, pa.preview_id\n        FROM port_allocations pa\n        LEFT JOIN preview_processes pp ON pa.preview_id = pp.id\n        WHERE pp.id IS NULL OR pp.status IN ('stopped', 'failed')\n      `);\n\n      for (const allocation of staleAllocations) {\n        await this.releasePort(allocation.port);\n      }\n\n      logger.info(`Cleaned up ${staleAllocations.length} stale port allocations`);\n      return staleAllocations.length;\n    } catch (error) {\n      logger.error('Error cleaning up stale allocations:', error);\n      throw error;\n    }\n  }\n}\n\nexport default PortAllocator;","import { promises as fs } from 'node:fs';\nimport path from 'node:path';\nimport { createLogger } from '../logger.js';\n\nconst logger = createLogger('projectAnalyzer');\n\nclass ProjectAnalyzer {\n  constructor() {\n    this.frameworkDetection = {\n      node: {\n        react: ['react', 'react-dom', 'react-scripts'],\n        vue: ['vue', '@vue/cli-service'],\n        angular: ['@angular/core', '@angular/cli'],\n        nextjs: ['next', 'react', 'react-dom'],\n        express: ['express'],\n        nestjs: ['@nestjs/core', '@nestjs/common'],\n        gatsby: ['gatsby'],\n        nuxt: ['nuxt'],\n        svelte: ['svelte', '@sveltejs/kit'],\n        vite: ['vite']\n      }\n    };\n\n    this.defaultPorts = {\n      react: 3000,\n      vue: 8080,\n      angular: 4200,\n      nextjs: 3000,\n      express: 3000,\n      nestjs: 3000,\n      gatsby: 8000,\n      nuxt: 3000,\n      svelte: 5173,\n      vite: 5173,\n      django: 8000,\n      flask: 5000,\n      fastapi: 8000\n    };\n\n    this.scriptPriority = ['dev', 'develop', 'start', 'serve', 'preview'];\n  }\n\n  async detectProjectType(workingDir) {\n    try {\n      const analysis = {\n        projectType: 'unknown',\n        framework: null,\n        configFiles: {\n          packageJson: false,\n          packageLock: false,\n          yarnLock: false,\n          pnpmLock: false,\n          requirements: false,\n          pipfile: false,\n          pyprojectToml: false,\n          dockerfile: false,\n          indexHtml: false\n        },\n        dependencies: {},\n        devDependencies: {}\n      };\n\n      const files = await fs.readdir(workingDir);\n\n      for (const file of files) {\n        switch (file) {\n          case 'package.json':\n            analysis.configFiles.packageJson = true;\n            const packageData = await this.readPackageJson(workingDir);\n            if (packageData) {\n              analysis.dependencies = packageData.dependencies || {};\n              analysis.devDependencies = packageData.devDependencies || {};\n              analysis.projectType = 'node';\n              analysis.framework = this.detectNodeFramework(packageData);\n            }\n            break;\n          case 'package-lock.json':\n            analysis.configFiles.packageLock = true;\n            break;\n          case 'yarn.lock':\n            analysis.configFiles.yarnLock = true;\n            break;\n          case 'pnpm-lock.yaml':\n            analysis.configFiles.pnpmLock = true;\n            break;\n          case 'requirements.txt':\n            analysis.configFiles.requirements = true;\n            if (analysis.projectType === 'unknown') {\n              analysis.projectType = 'python';\n              analysis.framework = await this.detectPythonFramework(workingDir);\n            }\n            break;\n          case 'Pipfile':\n            analysis.configFiles.pipfile = true;\n            if (analysis.projectType === 'unknown') {\n              analysis.projectType = 'python';\n            }\n            break;\n          case 'pyproject.toml':\n            analysis.configFiles.pyprojectToml = true;\n            if (analysis.projectType === 'unknown') {\n              analysis.projectType = 'python';\n            }\n            break;\n          case 'Dockerfile':\n            analysis.configFiles.dockerfile = true;\n            break;\n          case 'index.html':\n            analysis.configFiles.indexHtml = true;\n            if (analysis.projectType === 'unknown') {\n              analysis.projectType = 'static';\n            }\n            break;\n        }\n      }\n\n      return analysis;\n    } catch (error) {\n      logger.error('Error detecting project type:', error);\n      return {\n        projectType: 'unknown',\n        framework: null,\n        configFiles: {},\n        dependencies: {},\n        devDependencies: {}\n      };\n    }\n  }\n\n  async readPackageJson(workingDir) {\n    try {\n      const packageJsonPath = path.join(workingDir, 'package.json');\n      const content = await fs.readFile(packageJsonPath, 'utf8');\n      return JSON.parse(content);\n    } catch (error) {\n      logger.error('Error reading package.json:', error);\n      return null;\n    }\n  }\n\n  detectNodeFramework(packageData) {\n    const allDeps = {\n      ...packageData.dependencies,\n      ...packageData.devDependencies\n    };\n\n    for (const [framework, indicators] of Object.entries(this.frameworkDetection.node)) {\n      if (indicators.some(dep => dep in allDeps)) {\n        return framework;\n      }\n    }\n\n    return null;\n  }\n\n  async detectPythonFramework(workingDir) {\n    try {\n      const requirementsPath = path.join(workingDir, 'requirements.txt');\n      const content = await fs.readFile(requirementsPath, 'utf8');\n      const lines = content.toLowerCase().split('\\n');\n\n      if (lines.some(line => line.includes('django'))) {\n        return 'django';\n      }\n      if (lines.some(line => line.includes('flask'))) {\n        return 'flask';\n      }\n      if (lines.some(line => line.includes('fastapi'))) {\n        return 'fastapi';\n      }\n    } catch (error) {\n      logger.debug('Could not detect Python framework:', error.message);\n    }\n\n    return null;\n  }\n\n  async getAvailableScripts(workingDir, projectType) {\n    const scripts = {};\n\n    if (projectType === 'node') {\n      const packageData = await this.readPackageJson(workingDir);\n      if (packageData && packageData.scripts) {\n        Object.assign(scripts, packageData.scripts);\n      }\n    } else if (projectType === 'python') {\n      const framework = await this.detectPythonFramework(workingDir);\n      if (framework === 'django') {\n        scripts.runserver = 'python manage.py runserver';\n      } else if (framework === 'flask') {\n        scripts.run = 'flask run';\n      } else if (framework === 'fastapi') {\n        scripts.dev = 'uvicorn main:app --reload';\n      }\n    } else if (projectType === 'static') {\n      scripts.serve = 'python -m http.server';\n    }\n\n    return scripts;\n  }\n\n  getSuggestedCommand(scripts) {\n    for (const priority of this.scriptPriority) {\n      if (scripts[priority]) {\n        return priority;\n      }\n    }\n\n    const scriptNames = Object.keys(scripts);\n    if (scriptNames.length > 0) {\n      return scriptNames[0];\n    }\n\n    return null;\n  }\n\n  async detectPort(workingDir, script, framework) {\n    let detectedPort = null;\n\n    if (framework && this.defaultPorts[framework]) {\n      detectedPort = this.defaultPorts[framework];\n    }\n\n    try {\n      const packageData = await this.readPackageJson(workingDir);\n      if (packageData) {\n        if (packageData.config && packageData.config.port) {\n          detectedPort = packageData.config.port;\n        }\n\n        const scriptContent = packageData.scripts?.[script];\n        if (scriptContent) {\n          const portMatch = scriptContent.match(/--port[= ](\\d+)|-p[= ](\\d+)/);\n          if (portMatch) {\n            detectedPort = parseInt(portMatch[1] || portMatch[2]);\n          }\n\n          const envPortMatch = scriptContent.match(/PORT=(\\d+)/);\n          if (envPortMatch) {\n            detectedPort = parseInt(envPortMatch[1]);\n          }\n        }\n      }\n\n      const envFiles = ['.env', '.env.local', '.env.development'];\n      for (const envFile of envFiles) {\n        try {\n          const envPath = path.join(workingDir, envFile);\n          const envContent = await fs.readFile(envPath, 'utf8');\n          const portMatch = envContent.match(/^PORT=(\\d+)/m);\n          if (portMatch) {\n            detectedPort = parseInt(portMatch[1]);\n            break;\n          }\n        } catch (error) {\n          continue;\n        }\n      }\n    } catch (error) {\n      logger.debug('Error detecting port:', error.message);\n    }\n\n    return detectedPort || this.defaultPorts[framework] || 3000;\n  }\n\n  async checkDependenciesInstalled(workingDir, projectType) {\n    if (projectType === 'node') {\n      try {\n        await fs.access(path.join(workingDir, 'node_modules'));\n        return true;\n      } catch {\n        return false;\n      }\n    } else if (projectType === 'python') {\n      try {\n        await fs.access(path.join(workingDir, 'venv'));\n        return true;\n      } catch {\n        try {\n          await fs.access(path.join(workingDir, '.venv'));\n          return true;\n        } catch {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  detectPackageManager(configFiles) {\n    if (configFiles.yarnLock) return 'yarn';\n    if (configFiles.pnpmLock) return 'pnpm';\n    if (configFiles.packageLock) return 'npm';\n    if (configFiles.packageJson) return 'npm';\n    if (configFiles.pipfile) return 'pipenv';\n    if (configFiles.requirements) return 'pip';\n    return null;\n  }\n}\n\nexport default ProjectAnalyzer;","import http from 'node:http';\nimport https from 'node:https';\nimport { URL } from 'node:url';\nimport { createLogger } from '../logger.js';\n\nconst logger = createLogger('healthChecker');\n\nclass HealthChecker {\n  constructor() {\n    this.defaultTimeout = 5000;\n    this.maxAttempts = 30;\n    this.initialDelay = 1000;\n    this.maxDelay = 5000;\n  }\n\n  async checkHealth(url, timeout = this.defaultTimeout) {\n    return new Promise((resolve) => {\n      const startTime = Date.now();\n      const parsedUrl = new URL(url);\n      const client = parsedUrl.protocol === 'https:' ? https : http;\n\n      const options = {\n        hostname: parsedUrl.hostname,\n        port: parsedUrl.port,\n        path: parsedUrl.pathname,\n        method: 'GET',\n        timeout: timeout,\n        headers: {\n          'User-Agent': 'AI-Agent-Wrapper-HealthChecker/1.0'\n        }\n      };\n\n      const req = client.request(options, (res) => {\n        const responseTime = Date.now() - startTime;\n        \n        res.on('data', () => {});\n        res.on('end', () => {\n          resolve({\n            responsive: true,\n            statusCode: res.statusCode,\n            responseTime: responseTime,\n            headers: res.headers\n          });\n        });\n      });\n\n      req.on('error', (error) => {\n        logger.debug(`Health check failed for ${url}:`, error.message);\n        resolve({\n          responsive: false,\n          error: error.message,\n          responseTime: Date.now() - startTime\n        });\n      });\n\n      req.on('timeout', () => {\n        req.destroy();\n        resolve({\n          responsive: false,\n          error: 'Request timeout',\n          responseTime: timeout\n        });\n      });\n\n      req.end();\n    });\n  }\n\n  async waitForServer(url, options = {}) {\n    const maxAttempts = options.maxAttempts || this.maxAttempts;\n    const initialDelay = options.initialDelay || this.initialDelay;\n    const maxDelay = options.maxDelay || this.maxDelay;\n    const timeout = options.timeout || this.defaultTimeout;\n    const acceptedStatusCodes = options.acceptedStatusCodes || [200, 201, 202, 204, 301, 302, 303, 304, 307, 308];\n\n    logger.info(`Waiting for server at ${url} to become responsive...`);\n\n    let attempt = 0;\n    let delay = initialDelay;\n\n    while (attempt < maxAttempts) {\n      attempt++;\n      \n      const health = await this.checkHealth(url, timeout);\n      \n      if (health.responsive) {\n        if (acceptedStatusCodes.includes(health.statusCode)) {\n          logger.info(`Server at ${url} is responsive (attempt ${attempt}/${maxAttempts})`);\n          return {\n            success: true,\n            attempts: attempt,\n            health: health\n          };\n        } else {\n          logger.debug(`Server responded with unexpected status ${health.statusCode}`);\n        }\n      }\n\n      if (attempt < maxAttempts) {\n        logger.debug(`Server not ready, waiting ${delay}ms before retry (attempt ${attempt}/${maxAttempts})`);\n        await this.sleep(delay);\n        delay = Math.min(delay * 1.5, maxDelay);\n      }\n    }\n\n    logger.error(`Server at ${url} failed to become responsive after ${maxAttempts} attempts`);\n    return {\n      success: false,\n      attempts: attempt,\n      error: 'Maximum attempts reached'\n    };\n  }\n\n  async checkMultipleUrls(urls, timeout = this.defaultTimeout) {\n    const checks = urls.map(url => \n      this.checkHealth(url, timeout).then(result => ({\n        url,\n        ...result\n      }))\n    );\n\n    return Promise.all(checks);\n  }\n\n  async findResponsiveUrl(urls, options = {}) {\n    for (const url of urls) {\n      const result = await this.waitForServer(url, { ...options, maxAttempts: 5 });\n      if (result.success) {\n        return {\n          url,\n          ...result\n        };\n      }\n    }\n\n    return {\n      success: false,\n      error: 'No responsive URL found'\n    };\n  }\n\n  sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  buildHealthReport(health) {\n    if (!health.responsive) {\n      return {\n        status: 'down',\n        message: health.error || 'Server not responding',\n        responseTime: health.responseTime\n      };\n    }\n\n    if (health.statusCode >= 200 && health.statusCode < 300) {\n      return {\n        status: 'healthy',\n        message: 'Server is responding normally',\n        statusCode: health.statusCode,\n        responseTime: health.responseTime\n      };\n    }\n\n    if (health.statusCode >= 300 && health.statusCode < 400) {\n      return {\n        status: 'redirect',\n        message: 'Server is redirecting',\n        statusCode: health.statusCode,\n        responseTime: health.responseTime,\n        location: health.headers.location\n      };\n    }\n\n    if (health.statusCode >= 400 && health.statusCode < 500) {\n      return {\n        status: 'client_error',\n        message: 'Client error',\n        statusCode: health.statusCode,\n        responseTime: health.responseTime\n      };\n    }\n\n    if (health.statusCode >= 500) {\n      return {\n        status: 'server_error',\n        message: 'Server error',\n        statusCode: health.statusCode,\n        responseTime: health.responseTime\n      };\n    }\n\n    return {\n      status: 'unknown',\n      message: 'Unknown status',\n      statusCode: health.statusCode,\n      responseTime: health.responseTime\n    };\n  }\n}\n\nexport default HealthChecker;","import { spawn } from 'node:child_process';\nimport { v4 as uuidv4 } from 'uuid';\nimport os from 'node:os';\nimport path from 'node:path';\nimport axios from 'axios';\nimport { createLogger } from '../logger.js';\nimport { default as PortAllocator } from './portAllocator.js';\nimport { default as ProjectAnalyzer } from './projectAnalyzer.js';\nimport { default as HealthChecker } from './healthChecker.js';\n\nconst logger = createLogger('previewManager');\n\nclass PreviewManager {\n  constructor(db, processManager, eventEmitter) {\n    this.db = db;\n    this.processManager = processManager;\n    this.eventEmitter = eventEmitter;\n    this.portAllocator = new PortAllocator(db);\n    this.projectAnalyzer = new ProjectAnalyzer();\n    this.healthChecker = new HealthChecker();\n    this.previewProcesses = new Map();\n    this.sseConnections = new Map();\n    \n    // Auto-restart configuration\n    this.healthCheckInterval = 120000; // 2 minutes - less aggressive\n    this.maxRestartAttempts = 1; // Only one restart attempt before asking Claude\n    this.restartDelay = 5000; // 5 seconds\n    \n    // Error detection patterns for preview logs\n    this.errorPatterns = [\n      // Build/compilation errors\n      /error TS\\d+:/i,  // TypeScript errors\n      /Module not found:/i,\n      /Cannot find module/i,\n      /SyntaxError:/i,\n      /ReferenceError:/i,\n      /TypeError:/i,\n      /Failed to compile/i,\n      /Build error occurred/i,\n      /ENOENT.*no such file or directory/i,\n      \n      // Dependency errors\n      /npm ERR!/i,\n      /yarn error/i,\n      /pnpm ERR!/i,\n      /Cannot resolve dependency/i,\n      /peer dep missing/i,\n      \n      // Runtime critical errors\n      /FATAL ERROR:/i,\n      /Uncaught Exception/i,\n      /Out of memory/i,\n      /EMFILE.*too many open files/i,\n      \n      // Next.js specific errors\n      /Error: Failed to load/i,\n      /Error occurred prerendering page/i,\n      /Export encountered errors/i\n    ];\n    \n    // Track recent errors to avoid spam\n    this.recentErrors = new Map(); // previewId -> { count, lastSent }\n    \n    // Execution-level error tracking to prevent multiple Claude sessions\n    this.executionErrors = new Map(); // executionId -> { errorBuffer, timeoutId, lastSent, isHandling }\n    this.errorBufferDelay = 2000; // 2 seconds to collect full error context\n    \n    // Start health monitoring\n    this.startHealthMonitoring();\n  }\n\n  async analyzeProject(executionId, options = {}) {\n    try {\n      const execution = await this.db.get(\n        'SELECT * FROM executions WHERE id = ?',\n        [executionId]\n      );\n\n      if (!execution) {\n        throw new Error('Execution not found');\n      }\n\n      // Determine the working directory based on reference info\n      let workingDir = execution.working_dir;\n      if (options.refType && options.refId) {\n        // Use reference-specific directory within the execution workspace\n        const baseWorkspace = execution.workspace_path || execution.working_dir;\n        workingDir = path.join(baseWorkspace, options.refType, options.refId);\n        logger.info(`Using reference-specific directory: ${workingDir}`);\n      }\n      const projectInfo = await this.projectAnalyzer.detectProjectType(workingDir);\n      const scripts = await this.projectAnalyzer.getAvailableScripts(workingDir, projectInfo.projectType);\n      const suggestedCommand = this.projectAnalyzer.getSuggestedCommand(scripts);\n      const dependencies = {\n        installed: await this.projectAnalyzer.checkDependenciesInstalled(workingDir, projectInfo.projectType),\n        manager: this.projectAnalyzer.detectPackageManager(projectInfo.configFiles)\n      };\n\n      let detectedPort = null;\n      if (suggestedCommand) {\n        detectedPort = await this.projectAnalyzer.detectPort(workingDir, suggestedCommand, projectInfo.framework);\n      }\n\n      const port = {\n        detected: detectedPort,\n        available: detectedPort ? await this.portAllocator.isPortAvailable(detectedPort) : null\n      };\n\n      return {\n        executionId,\n        refType: options.refType,\n        refId: options.refId,\n        workingDir,\n        projectType: projectInfo.projectType,\n        framework: projectInfo.framework,\n        configFiles: projectInfo.configFiles,\n        availableScripts: scripts,\n        suggestedCommand,\n        dependencies,\n        port\n      };\n    } catch (error) {\n      logger.error(`Error analyzing project for execution ${executionId}:`, error);\n      throw error;\n    }\n  }\n\n  async startPreview(executionId, options = {}) {\n    try {\n      const execution = await this.db.get(\n        'SELECT * FROM executions WHERE id = ?',\n        [executionId]\n      );\n\n      if (!execution) {\n        throw new Error('Execution not found');\n      }\n\n      // Check if there's already a preview for this reference\n      if (options.refType && options.refId) {\n        const existingPreview = await this.db.get(\n          'SELECT * FROM preview_processes WHERE execution_id = ? AND ref_type = ? AND ref_id = ? ORDER BY started_at DESC LIMIT 1',\n          [executionId, options.refType, options.refId]\n        );\n        \n        if (existingPreview) {\n          logger.info(`Found existing preview for ${options.refType}/${options.refId}:`, {\n            id: existingPreview.id,\n            status: existingPreview.status,\n            pid: existingPreview.pid,\n            port: existingPreview.port,\n            stopped_at: existingPreview.stopped_at,\n            error_message: existingPreview.error_message\n          });\n          \n          // If preview is marked as running, verify it's actually running\n          if (['installing', 'starting', 'running'].includes(existingPreview.status)) {\n            logger.info(`Preview is marked as ${existingPreview.status}, verifying actual state...`);\n            \n            // Check if the process is actually running\n            let isActuallyRunning = false;\n            \n            // Check by PID\n            if (existingPreview.pid) {\n              try {\n                // Check if process exists (kill with signal 0 doesn't actually kill, just checks)\n                process.kill(existingPreview.pid, 0);\n                isActuallyRunning = true;\n                logger.info(`Process ${existingPreview.pid} is still running`);\n              } catch (error) {\n                logger.info(`Process ${existingPreview.pid} is not running: ${error.message}`);\n              }\n            }\n            \n            // Also check if port is actually in use\n            if (!isActuallyRunning && existingPreview.port) {\n              const portInUse = !(await this.portAllocator.isPortAvailable(existingPreview.port));\n              if (portInUse) {\n                logger.info(`Port ${existingPreview.port} is still in use, but not by our process`);\n                // Port is in use but not by our process - need to clean up\n              } else {\n                logger.info(`Port ${existingPreview.port} is available`);\n              }\n            }\n            \n            if (isActuallyRunning) {\n              // Process is actually running, return existing preview\n              logger.info(`Preview is actually running, returning existing preview`);\n              const urls = existingPreview.urls ? JSON.parse(existingPreview.urls) : {};\n              return {\n                success: true,\n                previewId: existingPreview.id,\n                executionId,\n                refType: options.refType,\n                refId: options.refId,\n                workingDir: existingPreview.working_dir,\n                status: existingPreview.status,\n                command: existingPreview.command,\n                pid: existingPreview.pid,\n                port: existingPreview.port,\n                urls,\n                startedAt: existingPreview.started_at,\n                existing: true\n              };\n            } else {\n              // Process is not running, update status to stopped\n              logger.info(`Preview process is not running, updating status to stopped`);\n              await this.db.run(\n                'UPDATE preview_processes SET status = ?, stopped_at = CURRENT_TIMESTAMP WHERE id = ?',\n                ['stopped', existingPreview.id]\n              );\n              existingPreview.status = 'stopped';\n              // Continue to restart logic below\n            }\n          }\n          \n          // If preview is stopped or failed, restart it\n          if (['stopped', 'failed'].includes(existingPreview.status)) {\n            logger.info(`Preview is in ${existingPreview.status} state, stopping and restarting...`);\n            \n            // First stop the preview if needed\n            try {\n              await this.stopPreview(executionId, existingPreview.id);\n              // Wait a moment for cleanup\n              await new Promise(resolve => setTimeout(resolve, 1000));\n            } catch (error) {\n              logger.warn(`Error stopping preview ${existingPreview.id}:`, error);\n            }\n            \n            // Now start a new preview with the same parameters\n            // Continue to the normal flow below to create a new preview\n            logger.info(`Creating new preview for ${options.refType}/${options.refId} after stopping the old one`);\n            // Don't return here - let it continue to create a new preview\n          } else {\n            // Return for unexpected status\n            logger.warn(`Preview has unexpected status: ${existingPreview.status}`);\n            return {\n              success: false,\n              error: `Preview has unexpected status: ${existingPreview.status}`,\n              previewId: existingPreview.id\n            };\n          }\n        }\n      }\n\n      // Determine the working directory based on reference info\n      let workingDir = execution.working_dir;\n      if (options.refType && options.refId) {\n        const baseWorkspace = execution.workspace_path || execution.working_dir;\n        workingDir = path.join(baseWorkspace, options.refType, options.refId);\n        logger.info(`Starting new preview in reference directory: ${workingDir}`, {\n          refType: options.refType,\n          refId: options.refId,\n          baseWorkspace,\n          'execution.workspace_path': execution.workspace_path,\n          'execution.working_dir': execution.working_dir,\n          'execution': execution,\n          options\n        });\n      }\n      \n      const previewId = uuidv4();\n\n      // Store preview in database immediately with 'installing' status\n      await this.db.run(\n        `INSERT INTO preview_processes (id, execution_id, command, port, status, urls, pid, ref_type, ref_id, working_dir)\n         VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,\n        [previewId, executionId, 'pending', null, 'installing', JSON.stringify({}), null, \n         options.refType || null, options.refId || null, workingDir]\n      );\n\n      // Start the async setup process in the background\n      this.setupPreviewAsync(previewId, executionId, workingDir, options)\n        .catch(error => {\n          logger.error(`Async preview setup failed for ${previewId}:`, error);\n          this.db.run(\n            'UPDATE preview_processes SET status = ?, error_message = ? WHERE id = ?',\n            ['failed', error.message, previewId]\n          ).catch(dbError => {\n            logger.error(`Failed to update preview status to failed:`, dbError);\n          });\n        });\n\n      // Return immediately - client will poll status endpoint\n      return {\n        success: true,\n        previewId,\n        executionId,\n        refType: options.refType,\n        refId: options.refId,\n        workingDir,\n        status: 'installing',\n        command: 'pending',\n        pid: null,\n        port: null,\n        urls: {},\n        startedAt: new Date().toISOString()\n      };\n\n    } catch (error) {\n      logger.error('Error starting preview:', error);\n      throw error;\n    }\n  }\n\n  async setupPreviewAsync(previewId, executionId, workingDir, options) {\n    try {\n      logger.info(`Setting up preview ${previewId} in ${workingDir}`);\n\n      // Analyze project\n      const analysis = await this.analyzeProject(executionId, { refType: options.refType, refId: options.refId });\n      \n      // Install dependencies by default unless explicitly disabled\n      if (options.installDependencies !== false) {\n        logger.info(`Installing dependencies in ${workingDir}`);\n        \n        // Emit phase update for dependency installation\n        if (this.eventEmitter) {\n          this.eventEmitter.emit('execution:log', {\n            executionId,\n            log: {\n              timestamp: new Date().toISOString(),\n              type: 'system',\n              content: JSON.stringify({\n                type: 'system',\n                subtype: 'phase',\n                phase: 'installing_dependencies',\n                message: 'Installing project dependencies'\n              })\n            }\n          });\n        }\n        \n        try {\n          const installResult = await this.installDependencies(executionId, { \n            manager: 'auto', \n            workingDir,\n            refType: options.refType,\n            refId: options.refId \n          });\n          logger.info(`Dependencies installed successfully`, installResult);\n          \n          // Emit ready for preview after successful install\n          if (this.eventEmitter) {\n            this.eventEmitter.emit('execution:log', {\n              executionId,\n              log: {\n                timestamp: new Date().toISOString(),\n                type: 'system',\n                content: JSON.stringify({\n                  type: 'system',\n                  subtype: 'phase',\n                  phase: 'ready_for_preview',\n                  message: 'Dependencies installed, project ready for preview'\n                })\n              }\n            });\n          }\n        } catch (installError) {\n          logger.error(`Failed to install dependencies: ${installError.message}`);\n          throw new Error(`Dependency installation failed: ${installError.message}`);\n        }\n      }\n\n      // Get command\n      let command = options.customCommand || \n        (options.command && analysis.availableScripts[options.command]) ||\n        analysis.availableScripts[analysis.suggestedCommand];\n\n      if (!command) {\n        throw new Error('No command specified or available');\n      }\n\n      // Fix command to use npx for Node.js projects so binaries are found\n      if (analysis.projectType === 'node' && !command.startsWith('npx') && !command.startsWith('npm') && !command.startsWith('yarn')) {\n        command = `npx ${command}`;\n        logger.info(`Modified command to use npx: ${command}`);\n      }\n\n      // Update status to starting\n      await this.db.run(\n        'UPDATE preview_processes SET status = ?, command = ? WHERE id = ?',\n        ['starting', command, previewId]\n      );\n\n      logger.info(`Starting app with command: ${command} in directory: ${workingDir}`);\n      \n      // Create clean environment without PORT to avoid conflicts\n      const env = {\n        ...process.env,\n        NODE_ENV: 'development',\n        ...options.env\n      };\n      \n      // Remove PORT from environment to let the preview app auto-detect\n      delete env.PORT;\n\n      const [cmd, ...args] = command.split(' ');\n      const childProcess = spawn(cmd, args, {\n        cwd: workingDir,\n        env,\n        shell: true,\n        stdio: ['pipe', 'pipe', 'pipe']\n      });\n\n      if (!childProcess.pid) {\n        throw new Error('Failed to start process');\n      }\n\n      // Store the process so it doesn't get garbage collected\n      this.previewProcesses.set(previewId, childProcess);\n      \n      logger.info(`Started process with PID: ${childProcess.pid}`);\n\n      await this.db.run(\n        'UPDATE preview_processes SET pid = ? WHERE id = ?',\n        [childProcess.pid, previewId]\n      );\n\n      let assignedPort = null;\n\n      childProcess.stdout.on('data', (data) => {\n        const output = data.toString();\n        this.handleProcessOutput(previewId, 'stdout', output);\n        this.checkForErrors(previewId, output, executionId);\n        \n        if (!assignedPort) {\n          assignedPort = this.parsePortFromOutput(output, analysis.framework);\n          if (assignedPort) {\n            logger.info(`Detected port ${assignedPort} for preview ${previewId}`);\n            this.updatePreviewPort(previewId, assignedPort);\n          }\n        }\n      });\n\n      childProcess.stderr.on('data', (data) => {\n        const output = data.toString();\n        this.handleProcessOutput(previewId, 'stderr', output);\n        this.checkForErrors(previewId, output, executionId);\n        \n        if (!assignedPort) {\n          assignedPort = this.parsePortFromOutput(output, analysis.framework);\n          if (assignedPort) {\n            logger.info(`Detected port ${assignedPort} for preview ${previewId} (from stderr)`);\n            this.updatePreviewPort(previewId, assignedPort);\n          }\n        }\n      });\n\n      childProcess.on('error', (error) => {\n        logger.error(`Process error for preview ${previewId}:`, error);\n        this.handleProcessError(previewId, error);\n      });\n\n      childProcess.on('exit', (code, signal) => {\n        logger.info(`Process exited for preview ${previewId} with code ${code}, signal ${signal}`);\n        this.handleProcessExit(previewId, code, signal);\n      });\n\n    } catch (error) {\n      logger.error(`Setup failed for preview ${previewId}:`, error);\n      await this.db.run(\n        'UPDATE preview_processes SET status = ?, error_message = ? WHERE id = ?',\n        ['failed', error.message, previewId]\n      );\n      throw error;\n    }\n  }\n\n  async stopPreview(executionId, previewId = null, options = {}) {\n    try {\n      let previewsToStop = [];\n\n      if (previewId) {\n        const preview = await this.db.get(\n          'SELECT * FROM preview_processes WHERE id = ? AND execution_id = ?',\n          [previewId, executionId]\n        );\n        if (preview) {\n          previewsToStop.push(preview);\n        }\n      } else if (options.refType && options.refId) {\n        // Stop only previews for specific reference\n        previewsToStop = await this.db.all(\n          'SELECT * FROM preview_processes WHERE execution_id = ? AND ref_type = ? AND ref_id = ? AND status IN (?, ?, ?)',\n          [executionId, options.refType, options.refId, 'installing', 'starting', 'running']\n        );\n      } else {\n        // Stop all previews for execution\n        previewsToStop = await this.db.all(\n          'SELECT * FROM preview_processes WHERE execution_id = ? AND status IN (?, ?, ?)',\n          [executionId, 'installing', 'starting', 'running']\n        );\n      }\n\n      const stoppedIds = [];\n\n      for (const preview of previewsToStop) {\n        const process = this.previewProcesses.get(preview.id);\n        if (process) {\n          process.kill('SIGTERM');\n          \n          setTimeout(() => {\n            if (!process.killed) {\n              process.kill('SIGKILL');\n            }\n          }, 5000);\n        }\n\n        await this.portAllocator.releasePortsByPreviewId(preview.id);\n        \n        await this.db.run(\n          'UPDATE preview_processes SET status = ?, stopped_at = CURRENT_TIMESTAMP WHERE id = ?',\n          ['stopped', preview.id]\n        );\n\n        this.previewProcesses.delete(preview.id);\n        stoppedIds.push(preview.id);\n      }\n\n      return {\n        success: true,\n        stopped: stoppedIds,\n        stoppedAt: new Date().toISOString()\n      };\n    } catch (error) {\n      logger.error(`Error stopping preview:`, error);\n      throw error;\n    }\n  }\n\n  async getPreviewStatus(executionId, options = {}) {\n    try {\n      let query = 'SELECT * FROM preview_processes WHERE execution_id = ?';\n      const params = [executionId];\n      \n      if (options.refType && options.refId) {\n        query += ' AND ref_type = ? AND ref_id = ?';\n        params.push(options.refType, options.refId);\n      }\n      \n      query += ' ORDER BY started_at DESC';\n      \n      const previews = await this.db.all(query, params);\n\n      const results = [];\n\n      for (const preview of previews) {\n        const urls = JSON.parse(preview.urls || '{}');\n        let health = null;\n\n        if (preview.status === 'running' && urls.local) {\n          const healthCheck = await this.healthChecker.checkHealth(urls.local, 5000); // 5 second timeout\n          health = {\n            responsive: healthCheck.responsive,\n            lastCheck: new Date().toISOString(),\n            responseTime: healthCheck.responseTime\n          };\n        }\n\n        const recentLogs = await this.db.all(\n          'SELECT content FROM preview_logs WHERE preview_id = ? ORDER BY timestamp DESC LIMIT 10',\n          [preview.id]\n        );\n\n        results.push({\n          previewId: preview.id,\n          refType: preview.ref_type,\n          refId: preview.ref_id,\n          workingDir: preview.working_dir,\n          status: preview.status,\n          command: preview.command,\n          pid: preview.pid,\n          port: preview.port,\n          urls,\n          startedAt: preview.started_at,\n          stoppedAt: preview.stopped_at,\n          errorMessage: preview.error_message,\n          health,\n          logs: {\n            recent: recentLogs.map(log => log.content).reverse()\n          }\n        });\n      }\n\n      return {\n        executionId,\n        refType: options.refType,\n        refId: options.refId,\n        previews: results\n      };\n    } catch (error) {\n      logger.error(`Error getting preview status for execution ${executionId}:`, error);\n      throw error;\n    }\n  }\n\n  async installDependencies(executionId, options = {}) {\n    try {\n      const execution = await this.db.get(\n        'SELECT * FROM executions WHERE id = ?',\n        [executionId]\n      );\n\n      if (!execution) {\n        throw new Error('Execution not found');\n      }\n\n      // Determine the working directory based on reference info\n      let workingDir = options.workingDir || execution.working_dir;\n      if (options.refType && options.refId) {\n        const baseWorkspace = execution.workspace_path || execution.working_dir;\n        workingDir = path.join(baseWorkspace, options.refType, options.refId);\n        logger.info(`Installing dependencies in reference directory: ${workingDir}`);\n      }\n      \n      const analysis = await this.analyzeProject(executionId, { refType: options.refType, refId: options.refId });\n      \n      let manager = options.manager;\n      if (manager === 'auto') {\n        manager = analysis.dependencies.manager;\n      }\n\n      if (!manager) {\n        throw new Error('No package manager detected');\n      }\n\n      const commands = {\n        npm: options.production ? 'npm ci --production' : 'npm install',\n        yarn: options.production ? 'yarn install --production' : 'yarn install',\n        pnpm: options.production ? 'pnpm install --prod' : 'pnpm install',\n        pip: 'pip install -r requirements.txt',\n        pipenv: 'pipenv install'\n      };\n\n      const command = commands[manager];\n      if (!command) {\n        throw new Error(`Unsupported package manager: ${manager}`);\n      }\n\n      const startTime = Date.now();\n\n      return new Promise((resolve, reject) => {\n        const [cmd, ...args] = command.split(' ');\n        const childProcess = spawn(cmd, args, {\n          cwd: workingDir,\n          shell: true,\n          env: { ...process.env, NODE_ENV: 'development' }\n        });\n\n        let output = '';\n\n        childProcess.stdout.on('data', (data) => {\n          output += data.toString();\n          logger.info(`Install output: ${data.toString().trim()}`);\n        });\n\n        childProcess.stderr.on('data', (data) => {\n          output += data.toString();\n          logger.info(`Install stderr: ${data.toString().trim()}`);\n        });\n\n        childProcess.on('error', (error) => {\n          logger.error(`Install process error:`, error);\n          reject(error);\n        });\n\n        childProcess.on('exit', (code) => {\n          const duration = Date.now() - startTime;\n          logger.info(`Install process exited with code ${code} after ${duration}ms`);\n\n          if (code === 0) {\n            resolve({\n              success: true,\n              manager,\n              command,\n              duration,\n              workingDir,\n              refType: options.refType,\n              refId: options.refId,\n              installedAt: new Date().toISOString()\n            });\n          } else {\n            reject(new Error(`Installation failed with code ${code}: ${output}`));\n          }\n        });\n      });\n    } catch (error) {\n      logger.error(`Error installing dependencies for execution ${executionId}:`, error);\n      throw error;\n    }\n  }\n\n  async handleProcessOutput(previewId, type, content) {\n    try {\n      await this.db.run(\n        'INSERT INTO preview_logs (preview_id, type, content) VALUES (?, ?, ?)',\n        [previewId, type, content]\n      );\n\n      this.broadcastLog(previewId, type, content);\n    } catch (error) {\n      logger.error(`Error handling process output for preview ${previewId}:`, error);\n    }\n  }\n\n  async handleProcessError(previewId, error) {\n    try {\n      await this.db.run(\n        'UPDATE preview_processes SET status = ?, error_message = ? WHERE id = ?',\n        ['failed', error.message, previewId]\n      );\n\n      await this.handleProcessOutput(previewId, 'system', `Process error: ${error.message}`);\n    } catch (dbError) {\n      logger.error(`Error handling process error for preview ${previewId}:`, dbError);\n    }\n  }\n\n  async handleProcessExit(previewId, code, signal) {\n    try {\n      const status = code === 0 ? 'stopped' : 'failed';\n      const message = signal ? `Process killed by signal ${signal}` : `Process exited with code ${code}`;\n\n      await this.db.run(\n        'UPDATE preview_processes SET status = ?, stopped_at = CURRENT_TIMESTAMP, error_message = ? WHERE id = ?',\n        [status, code !== 0 ? message : null, previewId]\n      );\n\n      await this.handleProcessOutput(previewId, 'system', message);\n      await this.portAllocator.releasePortsByPreviewId(previewId);\n\n      this.previewProcesses.delete(previewId);\n\n      // Check if this was an unexpected exit that should trigger auto-restart\n      const isUnexpectedExit = code !== 0 && !signal?.includes('SIGTERM') && !signal?.includes('SIGINT');\n      \n      if (isUnexpectedExit) {\n        // Get preview data for error notification\n        const preview = await this.db.get(\n          'SELECT * FROM preview_processes WHERE id = ?',\n          [previewId]\n        );\n        \n        if (preview && preview.execution_id) {\n          logger.warn(`Preview ${previewId} exited unexpectedly (code: ${code}, signal: ${signal})`);\n          \n          // Send error to Claude instead of auto-restarting\n          const errorMessage = ` **Preview Process Exited**\\n\\n` +\n            `Preview for ${preview.ref_type}/${preview.ref_id} stopped unexpectedly.\\n\\n` +\n            `Exit code: ${code}\\n` +\n            `Signal: ${signal || 'none'}\\n\\n` +\n            `This might be due to:\\n` +\n            `- A crash in the application\\n` +\n            `- Memory issues\\n` +\n            `- Build/compilation errors\\n` +\n            `- Port conflicts\\n\\n` +\n            `Please check the logs above for more details. You can restart the preview using the UI controls.`;\n          \n          try {\n            await axios.post(`http://localhost:3010/message/${preview.execution_id}`, {\n              message: errorMessage\n            });\n            logger.info(`Sent exit notification to Claude for preview ${previewId}`);\n          } catch (error) {\n            logger.error(`Failed to send exit notification to Claude:`, error);\n          }\n        }\n      }\n    } catch (error) {\n      logger.error(`Error handling process exit for preview ${previewId}:`, error);\n    }\n  }\n\n  addSSEConnection(previewId, res) {\n    if (!this.sseConnections.has(previewId)) {\n      this.sseConnections.set(previewId, new Set());\n    }\n    this.sseConnections.get(previewId).add(res);\n  }\n\n  removeSSEConnection(previewId, res) {\n    const connections = this.sseConnections.get(previewId);\n    if (connections) {\n      connections.delete(res);\n      if (connections.size === 0) {\n        this.sseConnections.delete(previewId);\n      }\n    }\n  }\n\n  broadcastLog(previewId, type, content) {\n    const connections = this.sseConnections.get(previewId);\n    if (connections) {\n      const data = JSON.stringify({\n        timestamp: new Date().toISOString(),\n        type,\n        content\n      });\n\n      connections.forEach(res => {\n        res.write(`event: log\\ndata: ${data}\\n\\n`);\n      });\n    }\n  }\n\n  broadcastStatus(previewId, status, port, url) {\n    const connections = this.sseConnections.get(previewId);\n    if (connections) {\n      const data = JSON.stringify({\n        status,\n        port,\n        url\n      });\n\n      connections.forEach(res => {\n        res.write(`event: status\\ndata: ${data}\\n\\n`);\n      });\n    }\n  }\n\n  getNetworkIP() {\n    const interfaces = os.networkInterfaces();\n    for (const name of Object.keys(interfaces)) {\n      for (const iface of interfaces[name]) {\n        if (iface.family === 'IPv4' && !iface.internal) {\n          return iface.address;\n        }\n      }\n    }\n    return 'localhost';\n  }\n\n  parsePortFromOutput(output, framework) {\n    // Common patterns for different frameworks\n    const patterns = {\n      nextjs: [\n        /Ready - started server on 0\\.0\\.0\\.0:(\\d+)/,\n        /Ready - started server on .*:(\\d+)/,\n        /Local:\\s+http:\\/\\/localhost:(\\d+)/,\n        /ready - started server on.*:(\\d+)/i\n      ],\n      react: [\n        /Local:\\s+http:\\/\\/localhost:(\\d+)/,\n        /webpack compiled with \\d+ warnings.*http:\\/\\/localhost:(\\d+)/,\n        /compiled successfully!.*http:\\/\\/localhost:(\\d+)/i\n      ],\n      vue: [\n        /Local:\\s+http:\\/\\/localhost:(\\d+)/,\n        /App running at:.*http:\\/\\/localhost:(\\d+)/\n      ],\n      vite: [\n        /Local:\\s+http:\\/\\/localhost:(\\d+)/,\n        /Local:\\s+http:\\/\\/127\\.0\\.0\\.1:(\\d+)/\n      ]\n    };\n\n    // Try framework-specific patterns first\n    const frameworkPatterns = patterns[framework] || [];\n    for (const pattern of frameworkPatterns) {\n      const match = output.match(pattern);\n      if (match) {\n        const port = parseInt(match[1], 10);\n        logger.info(`Detected port ${port} for ${framework} from output`);\n        return port;\n      }\n    }\n\n    // Try generic patterns\n    const genericPatterns = [\n      /localhost:(\\d+)/g,\n      /127\\.0\\.0\\.1:(\\d+)/g,\n      /0\\.0\\.0\\.0:(\\d+)/g,\n      /http:\\/\\/.*:(\\d+)/g\n    ];\n\n    for (const pattern of genericPatterns) {\n      const matches = Array.from(output.matchAll(pattern));\n      if (matches.length > 0) {\n        const port = parseInt(matches[0][1], 10);\n        // Skip common non-server ports\n        if (port >= 3000 && port <= 9000) {\n          logger.info(`Detected port ${port} from generic pattern`);\n          return port;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  async updatePreviewPort(previewId, port) {\n    try {\n      const urls = {\n        local: `http://localhost:${port}`,\n        network: `http://${this.getNetworkIP()}:${port}`,\n        public: null\n      };\n\n      await this.db.run(\n        'UPDATE preview_processes SET port = ?, urls = ? WHERE id = ?',\n        [port, JSON.stringify(urls), previewId]\n      );\n\n      // Update port allocation tracking\n      await this.portAllocator.updatePortAllocation(port, previewId);\n\n      logger.info(`Updated preview ${previewId} with detected port ${port}`);\n\n      // Broadcast port update to SSE connections\n      this.broadcastStatus(previewId, 'port_detected', port, urls.local);\n\n      // Start health checking now that we have the port\n      this.startHealthCheck(previewId, port);\n    } catch (error) {\n      logger.error(`Error updating preview port for ${previewId}:`, error);\n    }\n  }\n\n  async startHealthCheck(previewId, port) {\n    const url = `http://localhost:${port}`;\n    \n    setTimeout(async () => {\n      try {\n        const waitResult = await this.healthChecker.waitForServer(url, {\n          maxAttempts: 30,\n          initialDelay: 2000\n        });\n\n        if (waitResult.success) {\n          await this.db.run(\n            'UPDATE preview_processes SET status = ? WHERE id = ?',\n            ['running', previewId]\n          );\n          this.broadcastStatus(previewId, 'running', port, url);\n        } else {\n          await this.db.run(\n            'UPDATE preview_processes SET status = ?, error_message = ? WHERE id = ?',\n            ['failed', 'Server failed to start', previewId]\n          );\n          this.broadcastStatus(previewId, 'failed', port, null);\n        }\n      } catch (error) {\n        logger.error(`Health check failed for preview ${previewId}:`, error);\n      }\n    }, 3000); // Give the app some time to start before health checking\n  }\n\n  /**\n   * Forcefully stop a preview process and clean up resources\n   */\n  async forceStopPreview(previewId) {\n    logger.info(`Force stopping preview ${previewId}`);\n    \n    try {\n      // Kill process if it exists in memory\n      const processInfo = this.previewProcesses.get(previewId);\n      if (processInfo && processInfo.process) {\n        const process = processInfo.process;\n        \n        if (!process.killed) {\n          // Try graceful termination first\n          process.kill('SIGTERM');\n          \n          // Wait 2 seconds, then force kill if still running\n          await new Promise(resolve => setTimeout(resolve, 2000));\n          \n          if (!process.killed) {\n            logger.warn(`Preview ${previewId} didn't respond to SIGTERM, using SIGKILL`);\n            process.kill('SIGKILL');\n          }\n        }\n        \n        // Remove from our process map\n        this.previewProcesses.delete(previewId);\n      }\n      \n      // Kill any processes using the same port (in case of port conflicts)\n      const preview = await this.db.get('SELECT port FROM preview_processes WHERE id = ?', [previewId]);\n      if (preview && preview.port) {\n        await this.killProcessOnPort(preview.port);\n      }\n      \n      // Release allocated ports\n      await this.portAllocator.releasePortsByPreviewId(previewId);\n      \n    } catch (error) {\n      logger.error(`Error during force stop of preview ${previewId}:`, error);\n      // Don't throw - we want restart to continue even if cleanup partially fails\n    }\n  }\n\n  /**\n   * Kill any process using the specified port\n   */\n  async killProcessOnPort(port) {\n    \n    try {\n      // Use lsof to find process using the port, then kill it\n      const lsofProcess = spawn('lsof', ['-ti', `:${port}`]);\n      \n      let pids = '';\n      lsofProcess.stdout.on('data', (data) => {\n        pids += data.toString();\n      });\n      \n      await new Promise((resolve, reject) => {\n        lsofProcess.on('close', (code) => {\n          resolve();\n        });\n        lsofProcess.on('error', reject);\n      });\n      \n      // Kill all PIDs found\n      const pidList = pids.trim().split('\\n').filter(pid => pid);\n      for (const pid of pidList) {\n        try {\n          process.kill(parseInt(pid), 'SIGKILL');\n          logger.info(`Killed process ${pid} using port ${port}`);\n        } catch (e) {\n          // Process might already be dead\n        }\n      }\n    } catch (error) {\n      logger.warn(`Could not kill processes on port ${port}:`, error.message);\n      // This is not critical, so don't throw\n    }\n  }\n\n  /**\n   * Restart a preview process after server restart\n   */\n  async restartPreview(previewData) {\n    logger.info(`Attempting to restart preview ${previewData.id}`);\n    \n    try {\n      // First, forcefully stop any existing process for this preview\n      await this.forceStopPreview(previewData.id);\n      // Parse URLs to get the port\n      const urls = previewData.urls ? JSON.parse(previewData.urls) : {};\n      const port = previewData.port;\n      \n      if (!port) {\n        throw new Error('No port found for preview');\n      }\n      \n      // Check if port is still available\n      const isAvailable = await this.portAllocator.isPortAvailable(port);\n      if (!isAvailable) {\n        logger.warn(`Port ${port} is no longer available for preview ${previewData.id}`);\n        // Allocate a new port\n        const newPort = await this.portAllocator.allocatePort(); // No arguments - let it find an available port\n        logger.info(`Allocated new port ${newPort} for preview ${previewData.id}`);\n        \n        // Associate the new port with this preview\n        await this.portAllocator.updatePortAllocation(newPort, previewData.id);\n        previewData.port = newPort;\n      }\n      \n      // Update status to restarting\n      await this.db.run(\n        'UPDATE preview_processes SET status = ? WHERE id = ?',\n        ['starting', previewData.id]\n      );\n      \n      // Parse command from stored data\n      const command = JSON.parse(previewData.command);\n      \n      // Create clean environment without PORT\n      const env = { ...process.env };\n      delete env.PORT;\n      \n      // Spawn the process\n      const childProcess = spawn(command.cmd, command.args, {\n        cwd: previewData.working_dir,\n        env,\n        shell: true\n      });\n      \n      // Store process reference\n      this.previewProcesses.set(previewData.id, {\n        process: childProcess,\n        port: previewData.port,\n        executionId: previewData.execution_id,\n        refType: previewData.ref_type,\n        refId: previewData.ref_id\n      });\n      \n      // Handle process output\n      childProcess.stdout.on('data', (data) => {\n        const content = data.toString();\n        this.handleProcessOutput(previewData.id, 'stdout', content);\n        this.checkForErrors(previewData.id, content, previewData.execution_id);\n      });\n      \n      childProcess.stderr.on('data', (data) => {\n        const content = data.toString();\n        this.handleProcessOutput(previewData.id, 'stderr', content);\n        this.checkForErrors(previewData.id, content, previewData.execution_id);\n      });\n      \n      childProcess.on('error', (error) => {\n        logger.error(`Preview process error for ${previewData.id}:`, error);\n        this.handlePreviewError(previewData.id, error.message);\n      });\n      \n      childProcess.on('exit', (code, signal) => {\n        logger.info(`Preview process exited for ${previewData.id}: code=${code}, signal=${signal}`);\n        this.handlePreviewExit(previewData.id, code, signal);\n      });\n      \n      // Update URLs\n      const newUrls = {\n        local: `http://localhost:${previewData.port}`,\n        tunnel: null\n      };\n      \n      await this.db.run(\n        'UPDATE preview_processes SET urls = ?, pid = ? WHERE id = ?',\n        [JSON.stringify(newUrls), childProcess.pid, previewData.id]\n      );\n      \n      // Perform health check after a delay\n      const url = newUrls.local;\n      setTimeout(async () => {\n        try {\n          const waitResult = await this.healthChecker.waitForServer(url, {\n            maxAttempts: 30,\n            initialDelay: 2000\n          });\n          \n          if (waitResult.success) {\n            await this.db.run(\n              'UPDATE preview_processes SET status = ? WHERE id = ?',\n              ['running', previewData.id]\n            );\n            logger.info(`Successfully restarted preview ${previewData.id}`);\n          } else {\n            await this.db.run(\n              'UPDATE preview_processes SET status = ?, error_message = ? WHERE id = ?',\n              ['failed', 'Server failed to restart', previewData.id]\n            );\n          }\n        } catch (error) {\n          logger.error(`Health check failed for restarted preview ${previewData.id}:`, error);\n        }\n      }, 3000);\n      \n      return {\n        success: true,\n        previewId: previewData.id,\n        port: previewData.port,\n        url: newUrls.local\n      };\n    } catch (error) {\n      logger.error(`Failed to restart preview ${previewData.id}:`, error);\n      \n      // Update status to failed\n      await this.db.run(\n        'UPDATE preview_processes SET status = ?, error_message = ? WHERE id = ?',\n        ['failed', error.message, previewData.id]\n      );\n      \n      throw error;\n    }\n  }\n\n  /**\n   * Start periodic health monitoring for running previews\n   */\n  startHealthMonitoring() {\n    setInterval(async () => {\n      try {\n        await this.checkAndRestartFailedPreviews();\n      } catch (error) {\n        logger.error('Error during health monitoring:', error);\n      }\n    }, this.healthCheckInterval);\n    \n    logger.info(`Started preview health monitoring (interval: ${this.healthCheckInterval}ms)`);\n  }\n\n  /**\n   * Check all running previews and restart failed ones\n   */\n  async checkAndRestartFailedPreviews() {\n    const runningPreviews = await this.db.all(\n      'SELECT * FROM preview_processes WHERE status = ?',\n      ['running']\n    );\n\n    for (const preview of runningPreviews) {\n      try {\n        await this.checkPreviewHealth(preview);\n      } catch (error) {\n        logger.error(`Health check failed for preview ${preview.id}:`, error);\n      }\n    }\n  }\n\n  /**\n   * Check health of a specific preview and restart if needed\n   */\n  async checkPreviewHealth(preview) {\n    const urls = preview.urls ? JSON.parse(preview.urls) : {};\n    const url = urls.local;\n    \n    if (!url) {\n      logger.warn(`Preview ${preview.id} has no URL, skipping health check`);\n      return;\n    }\n\n    // Check if process is still running\n    const processInfo = this.previewProcesses.get(preview.id);\n    if (processInfo && processInfo.process && processInfo.process.killed) {\n      logger.warn(`Preview ${preview.id} process was killed, restarting...`);\n      await this.handlePreviewRestart(preview, 'Process was killed');\n      return;\n    }\n\n    // HTTP health check - less aggressive, just log failures\n    try {\n      const healthResult = await this.healthChecker.checkHealth(url, 10000); // 10 second timeout\n\n      if (!healthResult.success) {\n        logger.warn(`Preview ${preview.id} health check failed: ${healthResult.error}`);\n        // Don't auto-restart on health check failures - let Claude handle it\n        // await this.handlePreviewRestart(preview, `Health check failed: ${healthResult.error}`);\n        \n        // Instead, just update the status so UI can show warning\n        await this.db.run(\n          'UPDATE preview_processes SET last_health_check = CURRENT_TIMESTAMP, error_message = ? WHERE id = ?',\n          [`Health check failed: ${healthResult.error}`, preview.id]\n        );\n      } else {\n        // Health check passed, update last check time and clear any errors\n        await this.db.run(\n          'UPDATE preview_processes SET last_health_check = CURRENT_TIMESTAMP, error_message = NULL WHERE id = ?',\n          [preview.id]\n        );\n      }\n    } catch (error) {\n      logger.warn(`Preview ${preview.id} health check error:`, error);\n      // Don't auto-restart on health check errors\n      // await this.handlePreviewRestart(preview, `Health check error: ${error.message}`);\n    }\n  }\n\n  /**\n   * Handle restarting a failed preview\n   */\n  async handlePreviewRestart(preview, reason) {\n    // Check restart attempts\n    const restartAttempts = preview.restart_attempts || 0;\n    if (restartAttempts >= this.maxRestartAttempts) {\n      logger.error(`Preview ${preview.id} exceeded max restart attempts (${this.maxRestartAttempts}), marking as failed`);\n      await this.db.run(\n        'UPDATE preview_processes SET status = ?, error_message = ? WHERE id = ?',\n        ['failed', `Exceeded max restart attempts: ${reason}`, preview.id]\n      );\n      return;\n    }\n\n    logger.info(`Restarting preview ${preview.id} (attempt ${restartAttempts + 1}/${this.maxRestartAttempts}): ${reason}`);\n\n    try {\n      // Stop the current process if it exists\n      const processInfo = this.previewProcesses.get(preview.id);\n      if (processInfo && processInfo.process) {\n        try {\n          processInfo.process.kill('SIGTERM');\n        } catch (e) {\n          // Process might already be dead\n        }\n      }\n\n      // Update status to restarting\n      await this.db.run(\n        'UPDATE preview_processes SET status = ?, restart_attempts = ?, error_message = ? WHERE id = ?',\n        ['starting', restartAttempts + 1, `Restarting: ${reason}`, preview.id]\n      );\n\n      // Wait a bit before restarting\n      await new Promise(resolve => setTimeout(resolve, this.restartDelay));\n\n      // Restart the preview using existing data\n      await this.restartPreview(preview);\n\n      logger.info(`Successfully restarted preview ${preview.id}`);\n    } catch (error) {\n      logger.error(`Failed to restart preview ${preview.id}:`, error);\n      await this.db.run(\n        'UPDATE preview_processes SET status = ?, error_message = ? WHERE id = ?',\n        ['failed', `Restart failed: ${error.message}`, preview.id]\n      );\n    }\n  }\n\n  /**\n   * Check for errors in preview logs and send to Claude if needed\n   */\n  async checkForErrors(previewId, content, executionId) {\n    // Check if content contains any error patterns\n    let errorFound = null;\n    for (const pattern of this.errorPatterns) {\n      if (pattern.test(content)) {\n        errorFound = content.trim();\n        break;\n      }\n    }\n    \n    if (!errorFound) return;\n    \n    // Get or create execution error state\n    let execError = this.executionErrors.get(executionId);\n    if (!execError) {\n      execError = {\n        errorBuffer: new Set(),\n        timeoutId: null,\n        lastSent: 0,\n        isHandling: false\n      };\n      this.executionErrors.set(executionId, execError);\n    }\n    \n    // Check if we're already handling an error for this execution\n    if (execError.isHandling) {\n      logger.debug(`Already handling error for execution ${executionId}, skipping`);\n      return;\n    }\n    \n    // Check if we've sent an error recently (within 60 seconds)\n    const now = Date.now();\n    if (execError.lastSent && (now - execError.lastSent) < 60000) {\n      logger.debug(`Recently sent error for execution ${executionId}, skipping`);\n      return;\n    }\n    \n    // Add error to buffer\n    execError.errorBuffer.add(errorFound);\n    \n    // Clear existing timeout if any\n    if (execError.timeoutId) {\n      clearTimeout(execError.timeoutId);\n    }\n    \n    // Set a new timeout to send the buffered errors\n    execError.timeoutId = setTimeout(async () => {\n      await this.sendBufferedErrors(executionId, previewId);\n    }, this.errorBufferDelay);\n  }\n\n  /**\n   * Send buffered errors to Claude after delay\n   */\n  async sendBufferedErrors(executionId, previewId) {\n    const execError = this.executionErrors.get(executionId);\n    if (!execError || execError.errorBuffer.size === 0) return;\n    \n    // Mark as handling to prevent duplicates\n    execError.isHandling = true;\n    \n    try {\n      // Check if Claude is already active for this execution\n      // We need to check with the Claude SDK Manager through the database\n      const execution = await this.db.get(\n        'SELECT agent_type FROM executions WHERE id = ?',\n        [executionId]\n      );\n      \n      if (execution && execution.agent_type === 'claude') {\n        // For Claude executions, check if there's an active session\n        // We'll rely on the startExecution check we added to prevent duplicates\n        logger.info(`Checking Claude session status for execution ${executionId}`);\n      }\n      \n      logger.info(`Sending buffered errors to Claude for execution ${executionId}`);\n      \n      // Get preview info\n      const preview = await this.db.get(\n        'SELECT * FROM preview_processes WHERE id = ?',\n        [previewId]\n      );\n      \n      if (!preview) {\n        execError.errorBuffer.clear();\n        execError.isHandling = false;\n        return;\n      }\n      \n      // Combine all buffered errors\n      const allErrors = Array.from(execError.errorBuffer).join('\\n\\n---\\n\\n');\n      \n      const errorMessage = ` **Preview Error Detected**\\n\\n` +\n        `Preview for ${preview.ref_type}/${preview.ref_id} encountered errors:\\n\\n` +\n        `\\`\\`\\`\\n${allErrors}\\n\\`\\`\\`\\n\\n` +\n        `The preview server needs attention. Please:\\n` +\n        `1. Review and fix the errors above\\n` +\n        `2. The preview will automatically restart once fixed\\n` +\n        `3. If needed, you can manually restart using the UI\\n\\n` +\n        `Common solutions:\\n` +\n        `- Fix TypeScript/build errors\\n` +\n        `- Install missing dependencies\\n` +\n        `- Check import paths and module resolution\\n` +\n        `- Verify configuration files`;\n      \n      // Send message to Claude\n      await axios.post(`http://localhost:3010/message/${executionId}`, {\n        message: errorMessage\n      });\n      \n      // Update tracking\n      execError.lastSent = Date.now();\n      execError.errorBuffer.clear();\n      \n      logger.info(`Successfully sent error message to Claude for execution ${executionId}`);\n    } catch (error) {\n      logger.error(`Failed to send error to Claude:`, error);\n    } finally {\n      execError.isHandling = false;\n    }\n  }\n\n  /**\n   * Handle preview process error\n   */\n  async handlePreviewError(previewId, errorMessage) {\n    try {\n      await this.db.run(\n        'UPDATE preview_processes SET status = ?, error_message = ?, stopped_at = CURRENT_TIMESTAMP WHERE id = ?',\n        ['failed', errorMessage, previewId]\n      );\n      \n      logger.error(`Preview ${previewId} failed: ${errorMessage}`);\n    } catch (error) {\n      logger.error(`Failed to update preview error status:`, error);\n    }\n  }\n\n  /**\n   * Handle preview process exit\n   */\n  async handlePreviewExit(previewId, code, signal) {\n    try {\n      const status = code === 0 ? 'stopped' : 'failed';\n      const message = signal ? `Process killed by signal ${signal}` : \n                     code !== 0 ? `Process exited with code ${code}` : null;\n\n      await this.db.run(\n        'UPDATE preview_processes SET status = ?, stopped_at = CURRENT_TIMESTAMP, error_message = ? WHERE id = ?',\n        [status, message, previewId]\n      );\n\n      // Clean up process reference\n      this.previewProcesses.delete(previewId);\n      \n      // Get execution ID to clean up error tracking if this was the last preview\n      const preview = await this.db.get(\n        'SELECT execution_id FROM preview_processes WHERE id = ?',\n        [previewId]\n      );\n      \n      if (preview) {\n        // Check if there are other active previews for this execution\n        const otherPreviews = await this.db.get(\n          'SELECT COUNT(*) as count FROM preview_processes WHERE execution_id = ? AND status IN (\"running\", \"starting\", \"installing\") AND id != ?',\n          [preview.execution_id, previewId]\n        );\n        \n        // If no other active previews, clean up execution error tracking\n        if (otherPreviews.count === 0) {\n          const execError = this.executionErrors.get(preview.execution_id);\n          if (execError) {\n            if (execError.timeoutId) {\n              clearTimeout(execError.timeoutId);\n            }\n            this.executionErrors.delete(preview.execution_id);\n            logger.debug(`Cleaned up error tracking for execution ${preview.execution_id}`);\n          }\n        }\n      }\n      \n      logger.info(`Preview ${previewId} exited with status: ${status}`);\n    } catch (error) {\n      logger.error(`Failed to handle preview exit:`, error);\n    }\n  }\n}\n\nexport default PreviewManager;","import { ErrorCodes, ErrorCode } from './constants.js';\n\nexport class ValidationError extends Error {\n  name = 'ValidationError';\n  code: ErrorCode;\n  details: Record<string, any>;\n\n  constructor(message: string, details: Record<string, any> = {}) {\n    super(message);\n    this.code = ErrorCodes.VALIDATION_ERROR;\n    this.details = details;\n  }\n}\n\nexport class NotFoundError extends Error {\n  name = 'NotFoundError';\n  code: ErrorCode;\n\n  constructor(message: string) {\n    super(message);\n    this.code = ErrorCodes.EXECUTION_NOT_FOUND;\n  }\n}\n\nexport class ProcessError extends Error {\n  name = 'ProcessError';\n  code: ErrorCode;\n\n  constructor(code: ErrorCode, message: string) {\n    super(message);\n    this.code = code;\n  }\n}\n\nexport class FileSystemError extends Error {\n  name = 'FileSystemError';\n  code: ErrorCode;\n  path: string;\n  details: Record<string, any>;\n\n  constructor(code: ErrorCode, message: string, path: string, details: Record<string, any> = {}) {\n    super(message);\n    this.code = code;\n    this.path = path;\n    this.details = { ...details, path };\n  }\n}\n\nexport class FileNotFoundError extends FileSystemError {\n  constructor(path: string) {\n    super(\n      ErrorCodes.FILE_NOT_FOUND,\n      `File not found: ${path}`,\n      path\n    );\n  }\n}\n\nexport class DirectoryNotFoundError extends FileSystemError {\n  constructor(path: string) {\n    super(\n      ErrorCodes.DIRECTORY_NOT_FOUND,\n      `Directory not found: ${path}`,\n      path\n    );\n  }\n}\n\nexport class PathTraversalError extends FileSystemError {\n  constructor(path: string) {\n    super(\n      ErrorCodes.PATH_TRAVERSAL_ATTEMPT,\n      `Path traversal attempt detected: ${path}`,\n      path\n    );\n  }\n}\n\nexport class FileTooLargeError extends FileSystemError {\n  constructor(path: string, size: number, maxSize: number) {\n    super(\n      ErrorCodes.FILE_TOO_LARGE,\n      `File ${path} exceeds maximum size of ${maxSize} bytes`,\n      path,\n      { size, maxSize }\n    );\n  }\n}\n\nexport class FileExistsError extends FileSystemError {\n  constructor(path: string) {\n    super(\n      ErrorCodes.FILE_EXISTS,\n      `File already exists: ${path}`,\n      path\n    );\n  }\n}\n\nexport class DirectoryNotEmptyError extends FileSystemError {\n  constructor(path: string) {\n    super(\n      ErrorCodes.DIRECTORY_NOT_EMPTY,\n      `Directory is not empty: ${path}`,\n      path\n    );\n  }\n}\n\nexport class InvalidEncodingError extends FileSystemError {\n  constructor(encoding: string, path: string) {\n    super(\n      ErrorCodes.INVALID_ENCODING,\n      `Invalid encoding '${encoding}' for file: ${path}`,\n      path,\n      { encoding }\n    );\n  }\n}\n\nexport class PermissionDeniedError extends FileSystemError {\n  constructor(path: string, operation: string) {\n    super(\n      ErrorCodes.PERMISSION_DENIED,\n      `Permission denied for ${operation} on: ${path}`,\n      path,\n      { operation }\n    );\n  }\n}\n\ninterface ErrorResponse {\n  error: {\n    code: ErrorCode;\n    message: string;\n    details?: Record<string, any>;\n  };\n}\n\nexport function createErrorResponse(error: any): ErrorResponse {\n  const response: ErrorResponse = {\n    error: {\n      code: error.code || ErrorCodes.INTERNAL_ERROR,\n      message: error.message\n    }\n  };\n\n  if (error.details) {\n    response.error.details = error.details;\n  }\n\n  return response;\n}","import { ValidationError } from './errors.js';\nimport path from 'node:path';\nimport fs from 'node:fs';\n\nexport function validateAgent(agent: any): string {\n  if (!agent) {\n    throw new ValidationError('Agent type is required', { field: 'agent' });\n  }\n  \n  if (!['claude', 'gemini'].includes(agent)) {\n    throw new ValidationError(\n      \"Invalid agent type. Must be 'claude' or 'gemini'\",\n      { field: 'agent', value: agent }\n    );\n  }\n  \n  return agent;\n}\n\nexport function validatePrompt(prompt: any): string {\n  if (!prompt || typeof prompt !== 'string') {\n    throw new ValidationError('Prompt is required and must be a string', { field: 'prompt' });\n  }\n  \n  if (prompt.trim().length === 0) {\n    throw new ValidationError('Prompt cannot be empty', { field: 'prompt' });\n  }\n  \n  return prompt.trim();\n}\n\nexport function validateWorkingDir(workingDir: any): string | null {\n  if (!workingDir) {\n    return null; // Optional field\n  }\n  \n  if (typeof workingDir !== 'string') {\n    throw new ValidationError('Working directory must be a string', { field: 'workingDir' });\n  }\n  \n  const absPath = path.resolve(workingDir);\n  \n  if (!fs.existsSync(absPath)) {\n    throw new ValidationError(`Working directory does not exist: ${absPath}`, { \n      field: 'workingDir',\n      path: absPath \n    });\n  }\n  \n  if (!fs.statSync(absPath).isDirectory()) {\n    throw new ValidationError(`Path is not a directory: ${absPath}`, { \n      field: 'workingDir',\n      path: absPath \n    });\n  }\n  \n  return absPath;\n}\n\nexport function validateExecutionId(executionId: any): string {\n  if (!executionId || typeof executionId !== 'string') {\n    throw new ValidationError('Execution ID is required', { field: 'executionId' });\n  }\n  \n  // Basic UUID v4 validation\n  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\n  if (!uuidRegex.test(executionId)) {\n    throw new ValidationError('Invalid execution ID format', { \n      field: 'executionId',\n      value: executionId \n    });\n  }\n  \n  return executionId;\n}\n\nexport function validateMessage(message: any): string {\n  if (!message || typeof message !== 'string') {\n    throw new ValidationError('Message is required and must be a string', { field: 'message' });\n  }\n  \n  if (message.trim().length === 0) {\n    throw new ValidationError('Message cannot be empty', { field: 'message' });\n  }\n  \n  if (message.length > 100000) {\n    throw new ValidationError('Message is too long (max 100000 characters)', { \n      field: 'message', \n      length: message.length \n    });\n  }\n  \n  return message.trim();\n}\n\n// Export all validators as a namespace for backward compatibility\nexport const validators = {\n  validateAgent,\n  validatePrompt,\n  validateWorkingDir,\n  validateExecutionId,\n  validateMessage\n};\n\n// Re-export ValidationError for convenience\nexport { ValidationError } from './errors.js';","import express from 'express';\nimport { v4 as uuidv4 } from 'uuid';\nimport ProcessManager from '../processManager.js';\nimport ClaudeSDKManager from '../claudeSDKManager.js';\nimport StreamHandler from '../streamHandler.js';\nimport * as validators from '../validators.js';\nimport { createErrorResponse } from '../errors.js';\nimport { ExecutionStatus, Events } from '../constants.js';\nimport { createLogger } from '../logger.js';\nimport ExecutionContextManager from '../services/ExecutionContextManager.js';\nimport RefManager from '../services/RefManager.js';\nimport PreviewManager from '../preview/previewManager.js';\nimport { config } from '../config.js';\n\nconst logger = createLogger('routes/execute');\n\nconst router = express.Router();\n\nrouter.post('/execute', async (req, res, next) => {\n  try {\n    // Validate input\n    const agent = validators.validateAgent(req.body.agent);\n    const prompt = validators.validatePrompt(req.body.prompt);\n    \n    // workingDir is optional - if not provided, we'll use the execution workspace\n    const providedWorkingDir = req.body.workingDir;\n    let workingDir = null;\n    if (providedWorkingDir) {\n      workingDir = validators.validateWorkingDir(providedWorkingDir);\n    }\n    \n    // Validate references if provided\n    const refs = req.body.refs || {};\n    if (refs.read && !Array.isArray(refs.read)) {\n      throw new validators.ValidationError('refs.read must be an array');\n    }\n    if (refs.mutate && !Array.isArray(refs.mutate)) {\n      throw new validators.ValidationError('refs.mutate must be an array');\n    }\n    if (refs.create && !Array.isArray(refs.create)) {\n      throw new validators.ValidationError('refs.create must be an array');\n    }\n\n    // Generate execution ID\n    const executionId = uuidv4();\n    \n    // Get dependencies from app locals\n    const { db, eventEmitter, workspaceManager, resourceMonitor, auditLogger, performanceMonitor } = req.app.locals;\n    \n    // Helper to emit phase updates and update database\n    const emitPhase = async (phase, message) => {\n      const timestamp = new Date().toISOString();\n      \n      // Update phase in database\n      await db.run(\n        'UPDATE executions SET phase = ?, last_heartbeat = CURRENT_TIMESTAMP WHERE id = ?',\n        [phase, executionId]\n      );\n      \n      // Emit log event\n      eventEmitter.emit(Events.LOG_ENTRY, {\n        executionId,\n        timestamp,\n        type: 'system',\n        content: JSON.stringify({\n          type: 'system',\n          subtype: 'phase',\n          phase,\n          message\n        })\n      });\n    };\n    \n    // Emit starting phase\n    await emitPhase('starting', 'Execution started');\n    \n    // Check resource limits before starting execution\n    if (resourceMonitor) {\n      const canExecute = await resourceMonitor.canStartExecution();\n      if (!canExecute) {\n        const checks = await Promise.all([\n          resourceMonitor.checkConcurrentExecutions(),\n          resourceMonitor.checkDiskUsage(),\n          resourceMonitor.checkSystemResources()\n        ]);\n        \n        const blockedBy = checks.filter(check => !check.allowed);\n        const reasons = blockedBy.map(check => check.message).filter(Boolean);\n        \n        return res.status(429).json({\n          error: {\n            code: 'RESOURCE_LIMIT_EXCEEDED',\n            message: 'Cannot start execution due to resource limits',\n            details: {\n              blockedBy: blockedBy.map(check => check.type),\n              reasons\n            }\n          }\n        });\n      }\n    }\n    \n    // Create execution record FIRST so it exists for auto-preview\n    await db.run(\n      `INSERT INTO executions (id, agent_type, status, working_dir, workspace_path, phase, last_heartbeat) \n       VALUES (?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)`,\n      [executionId, agent, ExecutionStatus.STARTING, workingDir || process.cwd(), \n       null, 'starting'] // workspace_path will be updated later\n    );\n\n    // Set up execution workspace if references are provided\n    let executionWorkspace = null;\n    let actualWorkingDir = workingDir || process.cwd();\n    \n    if (refs.read?.length > 0 || refs.mutate?.length > 0 || refs.create?.length > 0) {\n      // Initialize ExecutionContextManager with PreviewManager\n      const workspacePath = workspaceManager.getWorkspacePath();\n      const refManager = new RefManager(workspacePath, performanceMonitor);\n      const previewManager = new PreviewManager(db, req.app.locals.processManager, eventEmitter);\n      const contextManager = new ExecutionContextManager(workspaceManager, refManager, previewManager);\n      \n      try {\n        await emitPhase('copying_files', 'Setting up project files and references');\n        \n        // Set up execution workspace with references\n        executionWorkspace = await contextManager.setupExecutionWorkspace(executionId, refs);\n        \n        // Use the execution workspace as the working directory\n        actualWorkingDir = executionWorkspace.executionPath;\n        \n        // Update the execution record with workspace path\n        await db.run(\n          'UPDATE executions SET workspace_path = ?, working_dir = ? WHERE id = ?',\n          [executionWorkspace.executionPath, actualWorkingDir, executionId]\n        );\n        \n        // Now start any pending previews (after workspace_path is updated)\n        await contextManager.startPendingPreviews();\n        \n        logger.info('Execution workspace created', { \n          executionId, \n          workspace: executionWorkspace.executionPath,\n          refs: executionWorkspace.manifest.refs \n        });\n      } catch (error) {\n        logger.error('Failed to set up execution workspace', { executionId, error });\n        throw new validators.ValidationError(`Failed to set up references: ${error.message}`);\n      }\n    }\n\n    // Log execution start event\n    if (auditLogger) {\n      await auditLogger.logExecutionEvent({\n        executionId,\n        event: 'started',\n        phase: 'initialization',\n        details: {\n          agent,\n          prompt: prompt.substring(0, 100), // First 100 chars for brevity\n          workingDir: actualWorkingDir,\n          hasReferences: !!(refs.read?.length || refs.mutate?.length || refs.create?.length),\n          referenceCounts: {\n            read: refs.read?.length || 0,\n            mutate: refs.mutate?.length || 0,\n            create: refs.create?.length || 0\n          }\n        }\n      });\n    }\n\n    // Execution record already created above\n    \n    // Save reference associations if provided\n    if (executionWorkspace) {\n      const refInserts = [];\n      \n      for (const refId of refs.read || []) {\n        refInserts.push(db.run(\n          'INSERT INTO execution_refs (execution_id, ref_id, permission) VALUES (?, ?, ?)',\n          [executionId, refId, 'read']\n        ));\n      }\n      \n      for (const refId of refs.mutate || []) {\n        refInserts.push(db.run(\n          'INSERT INTO execution_refs (execution_id, ref_id, permission) VALUES (?, ?, ?)',\n          [executionId, refId, 'mutate']\n        ));\n      }\n      \n      for (const refId of refs.create || []) {\n        refInserts.push(db.run(\n          'INSERT INTO execution_refs (execution_id, ref_id, permission) VALUES (?, ?, ?)',\n          [executionId, refId, 'create']\n        ));\n      }\n      \n      await Promise.all(refInserts);\n    }\n\n    // Use ClaudeSDKManager for Claude agent\n    if (agent === 'claude') {\n      // Initialize ClaudeSDKManager if not exists\n      if (!req.app.locals.claudeSDKManager) {\n        req.app.locals.claudeSDKManager = new ClaudeSDKManager(\n          db, \n          req.app.locals.config || config, \n          eventEmitter,\n          workspaceManager\n        );\n      }\n      \n      const claudeManager = req.app.locals.claudeSDKManager;\n      \n      // Start execution with SDK\n      await claudeManager.startExecution(executionId, prompt, actualWorkingDir);\n      \n    } else {\n      // Fall back to process spawning for other agents\n      if (!req.app.locals.processManager) {\n        req.app.locals.processManager = new ProcessManager(db, req.app.locals.config || config, eventEmitter);\n      }\n      if (!req.app.locals.streamHandler) {\n        req.app.locals.streamHandler = new StreamHandler(db, eventEmitter);\n      }\n\n      const processManager = req.app.locals.processManager;\n      const streamHandler = req.app.locals.streamHandler;\n\n      // Spawn the process with the actual working directory\n      const childProcess = await processManager.spawn(executionId, agent, prompt, actualWorkingDir, false);\n\n      // Attach stream handlers\n      childProcess.stdout.on('data', (data) => {\n        logger.info('Process stdout', { executionId, length: data.length, preview: data.toString().substring(0, 100) });\n        streamHandler.handleOutput(executionId, 'stdout', data);\n      });\n\n      childProcess.stderr.on('data', (data) => {\n        logger.info('Process stderr', { executionId, length: data.length, preview: data.toString().substring(0, 100) });\n        streamHandler.handleOutput(executionId, 'stderr', data);\n      });\n    }\n\n    // Return response\n    const response = {\n      executionId,\n      status: ExecutionStatus.STARTING,\n      startedAt: new Date().toISOString(),\n      workingDir: actualWorkingDir\n    };\n    \n    // Add refs to response if present\n    if (executionWorkspace) {\n      response.refs = executionWorkspace.manifest.refs;\n      response.workspace = {\n        path: executionWorkspace.executionPath,\n        directories: executionWorkspace.paths\n      };\n      \n      // Include skipped references information\n      if (executionWorkspace.skippedRefs) {\n        const hasSkipped = executionWorkspace.skippedRefs.read.length > 0 || \n                          executionWorkspace.skippedRefs.mutate.length > 0;\n        if (hasSkipped) {\n          response.skippedRefs = executionWorkspace.skippedRefs;\n          response.warnings = [`Skipped ${executionWorkspace.skippedRefs.read.length + executionWorkspace.skippedRefs.mutate.length} non-existent references`];\n        }\n      }\n    }\n    \n    logger.info('Execution started', { executionId, agent, workingDir: actualWorkingDir, refs });\n    res.status(201).json(response);\n\n  } catch (error) {\n    if (error.name === 'ValidationError') {\n      logger.warn('Validation error', error);\n      return res.status(400).json(createErrorResponse(error));\n    }\n    logger.error('Execution error', error);\n    next(error);\n  }\n});\n\nexport default router;","import express from 'express';\nimport * as validators from '../validators.js';\nimport { NotFoundError, createErrorResponse } from '../errors.js';\n\nconst router = express.Router();\n\nrouter.get('/status/:executionId', async (req, res, next) => {\n  try {\n    // Validate execution ID\n    const executionId = validators.validateExecutionId(req.params.executionId);\n\n    const { db } = req.app.locals;\n\n    // Get execution details with enhanced fields\n    const execution = await db.get(\n      'SELECT * FROM executions WHERE id = ?',\n      [executionId]\n    );\n\n    if (!execution) {\n      throw new NotFoundError(`Execution not found: ${executionId}`);\n    }\n\n    // Get preview information - only the most recent preview for each ref\n    const previews = await db.all(\n      `SELECT p1.* FROM preview_processes p1\n       INNER JOIN (\n         SELECT execution_id, ref_type, ref_id, MAX(started_at) as max_started\n         FROM preview_processes\n         WHERE execution_id = ?\n         AND ref_type IS NOT NULL\n         AND ref_id IS NOT NULL\n         GROUP BY execution_id, ref_type, ref_id\n       ) p2 ON p1.execution_id = p2.execution_id \n           AND p1.ref_type = p2.ref_type \n           AND p1.ref_id = p2.ref_id \n           AND p1.started_at = p2.max_started\n       WHERE p1.execution_id = ?`,\n      [executionId, executionId]\n    );\n\n    // Group previews by refType and refId\n    const previewsByType = {\n      create: {},\n      mutate: {}\n    };\n\n    for (const preview of previews) {\n      if (preview.ref_type && preview.ref_id) {\n        if (!previewsByType[preview.ref_type]) {\n          previewsByType[preview.ref_type] = {};\n        }\n        \n        const urls = preview.urls ? JSON.parse(preview.urls) : {};\n        previewsByType[preview.ref_type][preview.ref_id] = {\n          previewId: preview.id,\n          status: preview.status,\n          port: preview.port,\n          url: urls.local || null,\n          startedAt: preview.started_at,\n          stoppedAt: preview.stopped_at || null,\n          errorMessage: preview.error_message || null\n        };\n      }\n    }\n\n    // Get log summary\n    const logCount = await db.get(\n      'SELECT COUNT(*) as count FROM logs WHERE execution_id = ?',\n      [executionId]\n    );\n\n    const lastLog = await db.get(\n      'SELECT timestamp FROM logs WHERE execution_id = ? ORDER BY timestamp DESC LIMIT 1',\n      [executionId]\n    );\n\n    // Format comprehensive response\n    const response = {\n      executionId: execution.id,\n      status: execution.status,\n      phase: execution.phase || 'unknown',\n      startedAt: execution.created_at,\n      completedAt: execution.completed_at || null,\n      lastActivity: execution.last_heartbeat || lastLog?.timestamp || execution.created_at,\n      sessionId: execution.session_id || null,\n      \n      // Preview information\n      previews: previewsByType,\n      \n      // Log summary\n      logSummary: {\n        totalLogs: logCount?.count || 0,\n        lastLogTime: lastLog?.timestamp || null\n      }\n    };\n\n    res.json(response);\n\n  } catch (error) {\n    if (error.name === 'ValidationError') {\n      return res.status(400).json(createErrorResponse(error));\n    }\n    if (error.name === 'NotFoundError') {\n      return res.status(404).json(createErrorResponse(error));\n    }\n    next(error);\n  }\n});\n\nexport default router;","import express from 'express';\nimport path from 'node:path';\nimport { promises as fs } from 'node:fs';\nimport * as validators from '../validators.js';\nimport { NotFoundError, ProcessError, createErrorResponse } from '../errors.js';\nimport { ErrorCodes, ExecutionStatus } from '../constants.js';\nimport { createLogger } from '../logger.js';\nimport ClaudeSDKManager from '../claudeSDKManager.js';\nimport { config } from '../config.js';\n\nconst logger = createLogger('routes/message');\nconst router = express.Router();\n\nrouter.post('/message/:executionId', async (req, res, next) => {\n  try {\n    // Validate input\n    const executionId = validators.validateExecutionId(req.params.executionId);\n    const message = validators.validateMessage(req.body.message);\n\n    const { db, processManager } = req.app.locals;\n\n    // Check if execution exists\n    const execution = await db.get(\n      'SELECT * FROM executions WHERE id = ?',\n      [executionId]\n    );\n\n    if (!execution) {\n      throw new NotFoundError(`Execution not found: ${executionId}`);\n    }\n\n    // Use ClaudeSDKManager for Claude agent\n    if (execution.agent_type === 'claude') {\n      // Initialize ClaudeSDKManager if not exists\n      if (!req.app.locals.claudeSDKManager) {\n        const { eventEmitter, workspaceManager } = req.app.locals;\n        req.app.locals.claudeSDKManager = new ClaudeSDKManager(\n          db, \n          req.app.locals.config || config, \n          eventEmitter,\n          workspaceManager\n        );\n      }\n      \n      const claudeManager = req.app.locals.claudeSDKManager;\n      \n      try {\n        // Send message using SDK (it handles session resumption)\n        await claudeManager.sendMessage(executionId, message);\n        \n        // Return success response\n        res.json({\n          success: true,\n          continued: true,\n          timestamp: new Date().toISOString()\n        });\n        return;\n        \n      } catch (error) {\n        if (error.message === ErrorCodes.EXECUTION_NOT_FOUND) {\n          throw new NotFoundError(`Execution not found: ${executionId}`);\n        }\n        throw new ProcessError(\n          ErrorCodes.INTERNAL_ERROR,\n          `Failed to send message: ${error.message}`\n        );\n      }\n    }\n    \n    // For non-Claude agents, use the original process-based approach\n    if (execution.status !== ExecutionStatus.RUNNING) {\n      // Check if we can resume the execution\n      if (execution.status === ExecutionStatus.COMPLETED || execution.status === ExecutionStatus.FAILED) {\n        const { workspaceManager, eventEmitter } = req.app.locals;\n        \n        // Check if execution workspace still exists\n        const workspacePath = path.join(\n          workspaceManager.getWorkspacePath(),\n          '.execution',\n          `exec-${executionId}`\n        );\n        \n        try {\n          await fs.access(workspacePath);\n          logger.info(`Resuming execution ${executionId} in existing workspace`);\n          \n          // Update execution status to running\n          await db.run(\n            'UPDATE executions SET status = ?, completed_at = NULL WHERE id = ?',\n            [ExecutionStatus.RUNNING, executionId]\n          );\n          \n          // Spawn new process in existing workspace with continuation flag\n          const childProcess = await processManager.spawn(\n            executionId,\n            execution.agent_type,\n            message,\n            workspacePath,\n            true  // isContinuation = true\n          );\n          \n          // Get streamHandler\n          const streamHandler = req.app.locals.streamHandler;\n          \n          // Attach stream handlers for logging\n          childProcess.stdout.on('data', (data) => {\n            logger.info('Process stdout', { executionId, length: data.length, preview: data.toString().substring(0, 100) });\n            streamHandler.handleOutput(executionId, 'stdout', data);\n          });\n\n          childProcess.stderr.on('data', (data) => {\n            logger.info('Process stderr', { executionId, length: data.length, preview: data.toString().substring(0, 100) });\n            streamHandler.handleOutput(executionId, 'stderr', data);\n          });\n          \n          // Emit process start event\n          eventEmitter.emit('process-start', { executionId, pid: childProcess.pid });\n          \n          // Return success response\n          res.json({\n            success: true,\n            resumed: true,\n            timestamp: new Date().toISOString()\n          });\n          return;\n          \n        } catch (error) {\n          // Workspace doesn't exist or can't be accessed\n          throw new ProcessError(\n            ErrorCodes.PROCESS_NOT_RUNNING,\n            `Process is not running and workspace no longer exists (status: ${execution.status})`\n          );\n        }\n      } else {\n        throw new ProcessError(\n          ErrorCodes.PROCESS_NOT_RUNNING,\n          `Process is not running (status: ${execution.status})`\n        );\n      }\n    }\n\n    // For non-Claude agents that are already running\n    // Process is running - stop it and restart with continuation flag\n    if (!processManager) {\n      throw new ProcessError(\n        ErrorCodes.INTERNAL_ERROR,\n        'ProcessManager not initialized'\n      );\n    }\n\n    logger.info(`Stopping process for execution ${executionId} to restart with continuation`);\n    \n    // Stop the current process\n    await processManager.stopProcess(executionId);\n    \n    // Reload execution data after stopping to get latest status\n    const updatedExecution = await db.get(\n      'SELECT * FROM executions WHERE id = ?',\n      [executionId]\n    );\n    \n    // Get workspace path\n    const { workspaceManager, streamHandler, eventEmitter } = req.app.locals;\n    const workspacePath = updatedExecution.working_dir || path.join(\n      workspaceManager.getWorkspacePath(),\n      '.execution',\n      `exec-${executionId}`\n    );\n    \n    // Restart process with continuation flag\n    const childProcess = await processManager.spawn(\n      executionId,\n      updatedExecution.agent_type,\n      message,\n      workspacePath,\n      true  // isContinuation = true\n    );\n    \n    // Attach stream handlers for logging\n    childProcess.stdout.on('data', (data) => {\n      logger.info('Process stdout', { executionId, length: data.length, preview: data.toString().substring(0, 100) });\n      streamHandler.handleOutput(executionId, 'stdout', data);\n    });\n\n    childProcess.stderr.on('data', (data) => {\n      logger.info('Process stderr', { executionId, length: data.length, preview: data.toString().substring(0, 100) });\n      streamHandler.handleOutput(executionId, 'stderr', data);\n    });\n    \n    // Emit process start event\n    eventEmitter.emit('process-start', { executionId, pid: childProcess.pid });\n\n    // Return success response\n    res.json({\n      success: true,\n      continued: true,\n      timestamp: new Date().toISOString()\n    });\n\n  } catch (error) {\n    if (error.name === 'ValidationError') {\n      return res.status(400).json(createErrorResponse(error));\n    }\n    if (error.name === 'NotFoundError') {\n      return res.status(404).json(createErrorResponse(error));\n    }\n    if (error.name === 'ProcessError') {\n      return res.status(400).json(createErrorResponse(error));\n    }\n    next(error);\n  }\n});\n\nexport default router;","import express from 'express';\nimport * as validators from '../validators.js';\nimport { NotFoundError, createErrorResponse } from '../errors.js';\nimport { Events } from '../constants.js';\nimport { createLogger } from '../logger.js';\n\nconst logger = createLogger('routes/logs');\n\nconst router = express.Router();\n\nrouter.get('/logs/:executionId', async (req, res, next) => {\n  try {\n    // Validate execution ID\n    const executionId = validators.validateExecutionId(req.params.executionId);\n\n    const { db, eventEmitter, config } = req.app.locals;\n\n    // Check if execution exists\n    const execution = await db.get(\n      'SELECT * FROM executions WHERE id = ?',\n      [executionId]\n    );\n\n    if (!execution) {\n      throw new NotFoundError(`Execution not found: ${executionId}`);\n    }\n\n    logger.info('Starting SSE stream', { executionId });\n    \n    // Set SSE headers\n    res.writeHead(200, {\n      'Content-Type': 'text/event-stream',\n      'Cache-Control': 'no-cache',\n      'Connection': 'keep-alive',\n      'X-Accel-Buffering': 'no' // Disable Nginx buffering\n    });\n\n    // Send historical logs first\n    const historicalLogs = await db.all(\n      'SELECT * FROM logs WHERE execution_id = ? ORDER BY timestamp ASC',\n      [executionId]\n    );\n\n    for (const log of historicalLogs) {\n      res.write(`event: log\\n`);\n      res.write(`data: ${JSON.stringify({\n        timestamp: log.timestamp,\n        type: log.type,\n        content: log.content\n      })}\\n\\n`);\n    }\n\n    // Set up real-time log streaming\n    const logHandler = (event) => {\n      if (event.executionId === executionId) {\n        res.write(`event: log\\n`);\n        res.write(`data: ${JSON.stringify({\n          timestamp: event.timestamp,\n          type: event.type,\n          content: event.content\n        })}\\n\\n`);\n      }\n    };\n\n    // Listen for new logs\n    eventEmitter.on(Events.LOG_ENTRY, logHandler);\n\n    // Set up heartbeat\n    const heartbeatInterval = setInterval(() => {\n      res.write(':heartbeat\\n\\n');\n    }, config?.streaming?.heartbeatInterval || 30000);\n\n    // Clean up on client disconnect\n    req.on('close', () => {\n      logger.info('SSE client disconnected', { executionId });\n      eventEmitter.removeListener(Events.LOG_ENTRY, logHandler);\n      clearInterval(heartbeatInterval);\n    });\n\n    // Handle process completion\n    const exitHandler = (event) => {\n      if (event.executionId === executionId) {\n        res.write(`event: end\\n`);\n        res.write(`data: ${JSON.stringify({\n          code: event.code,\n          signal: event.signal\n        })}\\n\\n`);\n        \n        // Clean up\n        eventEmitter.removeListener(Events.LOG_ENTRY, logHandler);\n        eventEmitter.removeListener(Events.PROCESS_EXIT, exitHandler);\n        clearInterval(heartbeatInterval);\n        res.end();\n      }\n    };\n\n    eventEmitter.on(Events.PROCESS_EXIT, exitHandler);\n\n  } catch (error) {\n    if (error.name === 'ValidationError') {\n      return res.status(400).json(createErrorResponse(error));\n    }\n    if (error.name === 'NotFoundError') {\n      return res.status(404).json(createErrorResponse(error));\n    }\n    next(error);\n  }\n});\n\nexport default router;","import express from 'express';\nconst router = express.Router();\n\n// Placeholder files route - this was referenced but missing\n// File operations are handled by the refs endpoints\n\nexport default router;","import express from 'express';\nconst router = express.Router();\nimport { createLogger } from '../logger.js';\nimport PreviewManager from '../preview/previewManager.js';\n\nconst logger = createLogger('preview-routes');\n\nlet previewManager;\n\nrouter.use((req, res, next) => {\n  if (!previewManager) {\n    previewManager = new PreviewManager(req.app.locals.db, req.app.locals.processManager, req.app.locals.eventEmitter);\n  }\n  next();\n});\n\nrouter.get('/:executionId/analyze', async (req, res) => {\n  try {\n    const { executionId } = req.params;\n    const { refType, refId } = req.query;\n    \n    logger.info(`Analyzing project for execution ${executionId}`, { refType, refId });\n    \n    const analysis = await previewManager.analyzeProject(executionId, { refType, refId });\n    \n    res.json(analysis);\n  } catch (error) {\n    logger.error('Error analyzing project:', error);\n    res.status(error.message === 'Execution not found' ? 404 : 500).json({\n      error: {\n        code: error.message === 'Execution not found' ? 'EXECUTION_NOT_FOUND' : 'ANALYSIS_FAILED',\n        message: error.message,\n        details: error.stack\n      }\n    });\n  }\n});\n\nrouter.post('/:executionId/start', async (req, res) => {\n  try {\n    const { executionId } = req.params;\n    const { refType, refId } = req.query;\n    const options = { ...req.body, refType, refId };\n    \n    logger.info(`Starting preview for execution ${executionId}`, {\n      refType,\n      refId,\n      queryParams: req.query,\n      fullUrl: req.originalUrl,\n      options\n    });\n    \n    const result = await previewManager.startPreview(executionId, options);\n    \n    res.json(result);\n  } catch (error) {\n    logger.error('Error starting preview:', error);\n    \n    let errorCode = 'PREVIEW_START_FAILED';\n    let statusCode = 500;\n    \n    if (error.message === 'Execution not found') {\n      errorCode = 'EXECUTION_NOT_FOUND';\n      statusCode = 404;\n    } else if (error.message.includes('No available ports')) {\n      errorCode = 'PORT_UNAVAILABLE';\n      statusCode = 503;\n    } else if (error.message === 'No command specified or available') {\n      errorCode = 'COMMAND_NOT_FOUND';\n      statusCode = 400;\n    }\n    \n    res.status(statusCode).json({\n      error: {\n        code: errorCode,\n        message: error.message,\n        details: error.stack\n      }\n    });\n  }\n});\n\nrouter.get('/:executionId/status', async (req, res) => {\n  try {\n    const { executionId } = req.params;\n    const { refType, refId } = req.query;\n    \n    logger.info(`Getting preview status for execution ${executionId}`, { refType, refId });\n    \n    const status = await previewManager.getPreviewStatus(executionId, { refType, refId });\n    \n    res.json(status);\n  } catch (error) {\n    logger.error('Error getting preview status:', error);\n    res.status(500).json({\n      error: {\n        code: 'STATUS_FAILED',\n        message: error.message,\n        details: error.stack\n      }\n    });\n  }\n});\n\nrouter.post('/:executionId/stop', async (req, res) => {\n  try {\n    const { executionId } = req.params;\n    const { refType, refId } = req.query;\n    const { previewId, cleanup } = req.body;\n    \n    logger.info(`Stopping preview for execution ${executionId}`, { previewId, cleanup, refType, refId });\n    \n    const result = await previewManager.stopPreview(executionId, previewId, { refType, refId });\n    \n    res.json(result);\n  } catch (error) {\n    logger.error('Error stopping preview:', error);\n    res.status(500).json({\n      error: {\n        code: 'STOP_FAILED',\n        message: error.message,\n        details: error.stack\n      }\n    });\n  }\n});\n\nrouter.post('/:executionId/restart', async (req, res) => {\n  try {\n    const { executionId } = req.params;\n    const { refType, refId } = req.query;\n    const { previewId, force = false } = req.body;\n    \n    logger.info(`Restarting preview for execution ${executionId}`, { previewId, refType, refId, force });\n    \n    // If previewId is provided, restart that specific preview\n    if (previewId) {\n      const preview = await req.app.locals.db.get(\n        'SELECT * FROM preview_processes WHERE id = ? AND execution_id = ?',\n        [previewId, executionId]\n      );\n      \n      if (!preview) {\n        return res.status(404).json({\n          error: {\n            code: 'PREVIEW_NOT_FOUND',\n            message: 'Preview not found'\n          }\n        });\n      }\n      \n      // Stop existing preview first if it's running\n      if (['installing', 'starting', 'running'].includes(preview.status)) {\n        await previewManager.stopPreview(executionId, previewId);\n        // Wait a moment for cleanup\n        await new Promise(resolve => setTimeout(resolve, 1000));\n      }\n      \n      // Start the preview again with same ref parameters\n      const result = await previewManager.startPreview(executionId, {\n        refType: preview.ref_type,\n        refId: preview.ref_id,\n        installDependencies: !force // Skip install if force=true\n      });\n      \n      res.json({\n        ...result,\n        restarted: true,\n        previousPreviewId: previewId\n      });\n    } else if (refType && refId) {\n      // Restart preview for specific reference\n      // First check if there's an existing preview\n      const existingPreviews = await req.app.locals.db.all(\n        'SELECT * FROM preview_processes WHERE execution_id = ? AND ref_type = ? AND ref_id = ? ORDER BY started_at DESC',\n        [executionId, refType, refId]\n      );\n      \n      // Stop any running previews for this ref\n      for (const preview of existingPreviews) {\n        if (['installing', 'starting', 'running'].includes(preview.status)) {\n          await previewManager.stopPreview(executionId, preview.id);\n        }\n      }\n      \n      // Wait a moment for cleanup\n      if (existingPreviews.length > 0) {\n        await new Promise(resolve => setTimeout(resolve, 1000));\n      }\n      \n      // Start new preview\n      const result = await previewManager.startPreview(executionId, {\n        refType,\n        refId,\n        installDependencies: !force\n      });\n      \n      res.json({\n        ...result,\n        restarted: true,\n        hadExistingPreviews: existingPreviews.length > 0\n      });\n    } else {\n      return res.status(400).json({\n        error: {\n          code: 'MISSING_PARAMETERS',\n          message: 'Either previewId or both refType and refId must be provided'\n        }\n      });\n    }\n  } catch (error) {\n    logger.error('Error restarting preview:', error);\n    \n    let errorCode = 'RESTART_FAILED';\n    let statusCode = 500;\n    \n    if (error.message === 'Execution not found') {\n      errorCode = 'EXECUTION_NOT_FOUND';\n      statusCode = 404;\n    } else if (error.message.includes('No available ports')) {\n      errorCode = 'PORT_UNAVAILABLE';\n      statusCode = 503;\n    }\n    \n    res.status(statusCode).json({\n      error: {\n        code: errorCode,\n        message: error.message,\n        details: error.stack\n      }\n    });\n  }\n});\n\nrouter.get('/:executionId/logs', async (req, res) => {\n  try {\n    const { executionId } = req.params;\n    const { previewId } = req.query;\n    \n    if (!previewId) {\n      return res.status(400).json({\n        error: {\n          code: 'PREVIEW_ID_REQUIRED',\n          message: 'Preview ID is required as a query parameter'\n        }\n      });\n    }\n    \n    logger.info(`Starting log stream for preview ${previewId}`);\n    \n    res.writeHead(200, {\n      'Content-Type': 'text/event-stream',\n      'Cache-Control': 'no-cache',\n      'Connection': 'keep-alive',\n      'Access-Control-Allow-Origin': '*'\n    });\n    \n    previewManager.addSSEConnection(previewId, res);\n    \n    const preview = await req.app.locals.db.get(\n      'SELECT * FROM preview_processes WHERE id = ? AND execution_id = ?',\n      [previewId, executionId]\n    );\n    \n    if (!preview) {\n      res.write(`event: error\\ndata: ${JSON.stringify({ message: 'Preview not found' })}\\n\\n`);\n      res.end();\n      return;\n    }\n    \n    const recentLogs = await req.app.locals.db.all(\n      'SELECT * FROM preview_logs WHERE preview_id = ? ORDER BY timestamp DESC LIMIT 50',\n      [previewId]\n    );\n    \n    recentLogs.reverse().forEach(log => {\n      res.write(`event: log\\ndata: ${JSON.stringify({\n        timestamp: log.timestamp,\n        type: log.type,\n        content: log.content\n      })}\\n\\n`);\n    });\n    \n    const urls = JSON.parse(preview.urls || '{}');\n    res.write(`event: status\\ndata: ${JSON.stringify({\n      status: preview.status,\n      port: preview.port,\n      url: urls.local\n    })}\\n\\n`);\n    \n    const heartbeat = setInterval(() => {\n      res.write(':heartbeat\\n\\n');\n    }, 30000);\n    \n    req.on('close', () => {\n      clearInterval(heartbeat);\n      previewManager.removeSSEConnection(previewId, res);\n      logger.info(`Log stream closed for preview ${previewId}`);\n    });\n  } catch (error) {\n    logger.error('Error streaming logs:', error);\n    res.status(500).json({\n      error: {\n        code: 'STREAM_FAILED',\n        message: error.message,\n        details: error.stack\n      }\n    });\n  }\n});\n\nrouter.post('/:executionId/install', async (req, res) => {\n  try {\n    const { executionId } = req.params;\n    const { refType, refId } = req.query;\n    const options = { ...req.body, refType, refId };\n    \n    logger.info(`Installing dependencies for execution ${executionId}`, options);\n    \n    const result = await previewManager.installDependencies(executionId, options);\n    \n    res.json(result);\n  } catch (error) {\n    logger.error('Error installing dependencies:', error);\n    \n    let errorCode = 'INSTALL_FAILED';\n    let statusCode = 500;\n    \n    if (error.message === 'Execution not found') {\n      errorCode = 'EXECUTION_NOT_FOUND';\n      statusCode = 404;\n    } else if (error.message === 'No package manager detected') {\n      errorCode = 'NO_PACKAGE_MANAGER';\n      statusCode = 400;\n    }\n    \n    res.status(statusCode).json({\n      error: {\n        code: errorCode,\n        message: error.message,\n        details: error.stack\n      }\n    });\n  }\n});\n\nexport default router;","import express from 'express';\nconst router = express.Router();\nimport { createLogger } from '../logger.js';\nimport RefManager from '../services/RefManager.js';\nimport { promises as fs } from 'node:fs';\nimport path from 'node:path';\n\nconst logger = createLogger('refs-routes');\n\n// Initialize RefManager lazily to get workspace from app.locals\nlet refManager;\nfunction getRefManager(req) {\n  if (!refManager) {\n    refManager = new RefManager(req.app.locals.workspace.workspace);\n  }\n  return refManager;\n}\n\n// List all references\nrouter.get('/refs', async (req, res, next) => {\n  try {\n    const manager = getRefManager(req);\n    const refsDir = path.join(req.app.locals.workspace.workspace, 'refs');\n    \n    // Get all directories in refs folder\n    const refs = [];\n    try {\n      const entries = await fs.readdir(refsDir, { withFileTypes: true });\n      \n      for (const entry of entries) {\n        if (entry.isDirectory()) {\n          const refId = entry.name;\n          const refPath = path.join(refsDir, refId);\n          \n          try {\n            // Get basic git info\n            const branchInfo = await manager.listBranches(refId);\n            const branches = branchInfo.branches;\n            const currentBranch = branchInfo.current;\n            \n            // Get last commit info\n            const lastCommit = await manager.execGit(refPath, \n              'log -1 --format=%H%n%an%n%ae%n%at%n%s'\n            );\n            const [hash, author, email, timestamp, subject] = lastCommit.split('\\n');\n            \n            // Check for active worktrees (executions)\n            const worktrees = await manager.listWorktrees(refId);\n            const activeExecutions = worktrees\n              .filter(w => w.branch && w.branch.startsWith('exec-'))\n              .map(w => w.branch.replace('exec-', ''));\n            \n            refs.push({\n              refId,\n              currentBranch,\n              branches: branches.map(b => b.name),\n              lastCommit: {\n                hash,\n                author,\n                email,\n                timestamp: new Date(parseInt(timestamp) * 1000).toISOString(),\n                message: subject\n              },\n              activeExecutions\n            });\n          } catch (error) {\n            logger.error(`Error getting info for ref ${refId}:`, error);\n            refs.push({\n              refId,\n              error: 'Failed to get reference info'\n            });\n          }\n        }\n      }\n    } catch (error) {\n      if (error.code === 'ENOENT') {\n        // refs directory doesn't exist yet\n        return res.json({ refs: [] });\n      }\n      throw error;\n    }\n    \n    res.json({ refs });\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Get detailed reference info\nrouter.get('/refs/:refId/info', async (req, res, next) => {\n  try {\n    const { refId } = req.params;\n    const manager = getRefManager(req);\n    \n    if (!await manager.refExists(refId)) {\n      return res.status(404).json({\n        error: {\n          code: 'REF_NOT_FOUND',\n          message: `Reference '${refId}' not found`\n        }\n      });\n    }\n    \n    const refPath = path.join(req.app.locals.workspace.workspace, 'refs', refId);\n    \n    // Get current branch\n    const currentBranch = await manager.execGit(refPath, 'rev-parse --abbrev-ref HEAD');\n    \n    // Get all branches with last commit info\n    const branchInfo = await manager.listBranches(refId);\n    const branches = branchInfo.branches;\n    const branchDetails = [];\n    \n    for (const branch of branches) {\n      const commitInfo = await manager.execGit(refPath,\n        `log -1 --format=%H%n%at%n%s ${branch.name}`\n      );\n      const [hash, timestamp, subject] = commitInfo.split('\\n');\n      \n      branchDetails.push({\n        name: branch.name,\n        isHead: branch.isHead,\n        lastCommit: {\n          hash,\n          timestamp: new Date(parseInt(timestamp) * 1000).toISOString(),\n          message: subject\n        }\n      });\n    }\n    \n    // Get recent commits\n    const recentCommits = await manager.execGit(refPath,\n      'log -10 --format=%H%n%an%n%ae%n%at%n%s%n'\n    );\n    const commits = [];\n    const lines = recentCommits.trim().split('\\n');\n    \n    for (let i = 0; i < lines.length; i += 6) {\n      if (lines[i]) {\n        commits.push({\n          hash: lines[i],\n          author: lines[i + 1],\n          email: lines[i + 2],\n          timestamp: new Date(parseInt(lines[i + 3]) * 1000).toISOString(),\n          message: lines[i + 4]\n        });\n      }\n    }\n    \n    // Get active executions\n    const worktrees = await manager.listWorktrees(refId);\n    const activeExecutions = worktrees\n      .filter(w => w.branch && w.branch.startsWith('exec-'))\n      .map(w => ({\n        executionId: w.branch.replace('exec-', ''),\n        branch: w.branch,\n        path: w.worktree\n      }));\n    \n    // Get repository stats\n    const fileCount = await manager.execGit(refPath, 'ls-files | wc -l');\n    const size = await manager.execGit(refPath, 'count-objects -v');\n    const sizeMatch = size.match(/size: (\\d+)/);\n    \n    res.json({\n      refId,\n      currentBranch,\n      branches: branchDetails,\n      recentCommits: commits,\n      activeExecutions,\n      stats: {\n        fileCount: parseInt(fileCount.trim()),\n        sizeKB: sizeMatch ? parseInt(sizeMatch[1]) : 0\n      }\n    });\n  } catch (error) {\n    next(error);\n  }\n});\n\n// List branches\nrouter.get('/refs/:refId/branches', async (req, res, next) => {\n  try {\n    const { refId } = req.params;\n    const manager = getRefManager(req);\n    \n    if (!await manager.refExists(refId)) {\n      return res.status(404).json({\n        error: {\n          code: 'REF_NOT_FOUND',\n          message: `Reference '${refId}' not found`\n        }\n      });\n    }\n    \n    const branchInfo = await manager.listBranches(refId);\n    const branches = branchInfo.branches;\n    const currentBranch = branchInfo.current;\n    const refPath = path.join(req.app.locals.workspace.workspace, 'refs', refId);\n    \n    // Get detailed info for each branch\n    const branchDetails = [];\n    for (const branch of branches) {\n      const commitInfo = await manager.execGit(refPath,\n        `log -1 --format=%H%n%an%n%at%n%s ${branch.name}`\n      );\n      const [hash, author, timestamp, subject] = commitInfo.split('\\n');\n      \n      branchDetails.push({\n        name: branch.name,\n        isHead: branch.isHead,\n        isCurrent: branch.name === currentBranch,\n        isExecutionBranch: branch.name.startsWith('exec-'),\n        lastCommit: {\n          hash,\n          author,\n          timestamp: new Date(parseInt(timestamp) * 1000).toISOString(),\n          message: subject\n        }\n      });\n    }\n    \n    res.json({\n      currentBranch,\n      branches: branchDetails\n    });\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Switch branch (UI only - doesn't affect executions)\nrouter.post('/refs/:refId/checkout', async (req, res, next) => {\n  try {\n    const { refId } = req.params;\n    const { branch } = req.body;\n    const manager = getRefManager(req);\n    \n    if (!branch) {\n      return res.status(400).json({\n        error: {\n          code: 'MISSING_BRANCH',\n          message: 'Branch name is required'\n        }\n      });\n    }\n    \n    if (!await manager.refExists(refId)) {\n      return res.status(404).json({\n        error: {\n          code: 'REF_NOT_FOUND',\n          message: `Reference '${refId}' not found`\n        }\n      });\n    }\n    \n    const refPath = path.join(req.app.locals.workspace.workspace, 'refs', refId);\n    \n    // Check if branch exists\n    const branchInfo = await manager.listBranches(refId);\n    const branchExists = branchInfo.branches.some(b => b.name === branch);\n    \n    if (!branchExists) {\n      return res.status(404).json({\n        error: {\n          code: 'BRANCH_NOT_FOUND',\n          message: `Branch '${branch}' not found in reference '${refId}'`\n        }\n      });\n    }\n    \n    // Switch branch\n    await manager.execGit(refPath, `checkout ${manager.escapeArg(branch)}`);\n    \n    res.json({\n      refId,\n      branch,\n      success: true\n    });\n  } catch (error) {\n    next(error);\n  }\n});\n\n// List files in reference\nrouter.get('/refs/:refId/files', async (req, res, next) => {\n  try {\n    const { refId } = req.params;\n    const { branch = 'HEAD', path: dirPath = '', recursive = false } = req.query;\n    const manager = getRefManager(req);\n    \n    if (!await manager.refExists(refId)) {\n      return res.status(404).json({\n        error: {\n          code: 'REF_NOT_FOUND',\n          message: `Reference '${refId}' not found`\n        }\n      });\n    }\n    \n    if (recursive === 'true' || recursive === true) {\n      // Use ls-tree for recursive listing\n      const files = await manager.listFiles(refId, branch, dirPath);\n      res.json({ files });\n    } else {\n      // Use listDirectory for single-level listing with metadata\n      const entries = await manager.listDirectory(refId, branch, dirPath);\n      res.json({ entries });\n    }\n  } catch (error) {\n    // Handle specific git errors\n    if ((error.message.includes('pathspec') && error.message.includes('did not match')) ||\n        (error.message.includes('Branch') && error.message.includes('or path') && error.message.includes('not found'))) {\n      return res.status(404).json({\n        error: {\n          code: 'PATH_NOT_FOUND',\n          message: 'Path not found in repository'\n        }\n      });\n    }\n    \n    if (error.message.includes('unknown revision')) {\n      return res.status(404).json({\n        error: {\n          code: 'BRANCH_NOT_FOUND',\n          message: 'Branch or revision not found'\n        }\n      });\n    }\n    \n    next(error);\n  }\n});\n\n// Read file content\nrouter.get('/refs/:refId/file', async (req, res, next) => {\n  try {\n    const { refId } = req.params;\n    const { branch = 'HEAD', path: filePath } = req.query;\n    const manager = getRefManager(req);\n    \n    if (!filePath) {\n      return res.status(400).json({\n        error: {\n          code: 'MISSING_PATH',\n          message: 'File path is required'\n        }\n      });\n    }\n    \n    if (!await manager.refExists(refId)) {\n      return res.status(404).json({\n        error: {\n          code: 'REF_NOT_FOUND',\n          message: `Reference '${refId}' not found`\n        }\n      });\n    }\n    \n    try {\n      // Get file info first\n      const fileInfo = await manager.getFileInfo(refId, branch, filePath);\n      \n      if (!fileInfo) {\n        return res.status(404).json({\n          error: {\n            code: 'FILE_NOT_FOUND',\n            message: 'File not found in repository'\n          }\n        });\n      }\n      \n      if (fileInfo.type !== 'blob') {\n        return res.status(400).json({\n          error: {\n            code: 'NOT_A_FILE',\n            message: 'Path is not a file'\n          }\n        });\n      }\n      \n      // Read file content\n      const fileData = await manager.readFile(refId, branch, filePath);\n      \n      if (!fileData.found) {\n        return res.status(404).json({\n          error: {\n            code: 'FILE_NOT_FOUND',\n            message: 'File not found in repository'\n          }\n        });\n      }\n      \n      const buffer = fileData.content;\n      const isBinary = fileData.isBinary;\n      \n      if (isBinary) {\n        // Return as base64 for binary files\n        res.json({\n          path: filePath,\n          encoding: 'base64',\n          content: buffer.toString('base64'),\n          size: fileInfo.size,\n          mode: fileInfo.mode\n        });\n      } else {\n        // Return as UTF-8 for text files\n        res.json({\n          path: filePath,\n          encoding: 'utf8',\n          content: buffer.toString('utf8'),\n          size: fileInfo.size,\n          mode: fileInfo.mode\n        });\n      }\n    } catch (error) {\n      if (error.message.includes('pathspec') && error.message.includes('did not match')) {\n        return res.status(404).json({\n          error: {\n            code: 'FILE_NOT_FOUND',\n            message: 'File not found in repository'\n          }\n        });\n      }\n      throw error;\n    }\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Get executions for a specific reference\nrouter.get('/refs/:refId/executions', async (req, res, next) => {\n  try {\n    const { refId } = req.params;\n    const { db } = req.app.locals;\n    \n    // Query executions where this ref was used as a mutate item\n    const executions = await db.all(`\n      SELECT DISTINCT \n        e.id,\n        e.status,\n        e.phase,\n        e.agent_type,\n        e.created_at as created,\n        e.completed_at as completed,\n        e.rollback_reason as error,\n        e.message_count,\n        e.workspace_path\n      FROM executions e\n      INNER JOIN execution_refs er ON e.id = er.execution_id\n      WHERE er.ref_id = ? AND er.permission = 'mutate'\n      ORDER BY e.created_at DESC\n    `, [refId]);\n    \n    // For each execution, get the read references\n    const executionsWithRefs = await Promise.all(executions.map(async (exec) => {\n      const readRefs = await db.all(`\n        SELECT ref_id\n        FROM execution_refs\n        WHERE execution_id = ? AND permission = 'read'\n      `, [exec.id]);\n      \n      return {\n        ...exec,\n        readReferences: readRefs.map(r => r.ref_id)\n      };\n    }));\n    \n    res.json({\n      refId,\n      executions: executionsWithRefs\n    });\n  } catch (error) {\n    logger.error('Failed to get executions for ref', { refId: req.params.refId, error: error.message });\n    next(error);\n  }\n});\n\n// Merge branches\nrouter.post('/refs/:refId/merge', async (req, res, next) => {\n  try {\n    const { refId } = req.params;\n    const { sourceBranch, targetBranch = 'main', strategy = 'merge', commitMessage } = req.body;\n    const manager = getRefManager(req);\n    \n    // Validate required parameters\n    if (!sourceBranch) {\n      return res.status(400).json({\n        error: {\n          code: 'MISSING_SOURCE_BRANCH',\n          message: 'Source branch is required'\n        }\n      });\n    }\n    \n    if (!await manager.refExists(refId)) {\n      return res.status(404).json({\n        error: {\n          code: 'REF_NOT_FOUND',\n          message: `Reference '${refId}' not found`\n        }\n      });\n    }\n    \n    const refPath = path.join(req.app.locals.workspace.workspace, 'refs', refId);\n    \n    // Check if both branches exist\n    const branchInfo = await manager.listBranches(refId);\n    const branches = branchInfo.branches.map(b => b.name);\n    \n    if (!branches.includes(sourceBranch)) {\n      return res.status(404).json({\n        error: {\n          code: 'SOURCE_BRANCH_NOT_FOUND',\n          message: `Source branch '${sourceBranch}' not found`\n        }\n      });\n    }\n    \n    if (!branches.includes(targetBranch)) {\n      return res.status(404).json({\n        error: {\n          code: 'TARGET_BRANCH_NOT_FOUND',\n          message: `Target branch '${targetBranch}' not found`\n        }\n      });\n    }\n    \n    // Get original state of target branch before merge\n    const originalTargetCommit = await manager.execGit(refPath, `rev-parse ${manager.escapeArg(targetBranch)}`);\n    \n    // Switch to target branch\n    await manager.execGit(refPath, `checkout ${manager.escapeArg(targetBranch)}`);\n    \n    try {\n      let mergeOutput;\n      let mergeCommit;\n      \n      if (strategy === 'rebase') {\n        // Rebase source branch onto target\n        mergeOutput = await manager.execGit(refPath, `rebase ${manager.escapeArg(sourceBranch)}`);\n        mergeCommit = await manager.execGit(refPath, 'rev-parse HEAD');\n      } else if (strategy === 'squash') {\n        // Squash merge\n        mergeOutput = await manager.execGit(refPath, `merge --squash ${manager.escapeArg(sourceBranch)}`);\n        const message = commitMessage || `Squash merge of ${sourceBranch} into ${targetBranch}`;\n        await manager.execGit(refPath, `commit -m ${manager.escapeArg(message)}`);\n        mergeCommit = await manager.execGit(refPath, 'rev-parse HEAD');\n      } else if (strategy === 'ff-only') {\n        // Fast-forward only merge\n        mergeOutput = await manager.execGit(refPath, `merge --ff-only ${manager.escapeArg(sourceBranch)}`);\n        mergeCommit = await manager.execGit(refPath, 'rev-parse HEAD');\n      } else {\n        // Default merge strategy\n        const message = commitMessage || `Merge ${sourceBranch} into ${targetBranch}`;\n        mergeOutput = await manager.execGit(refPath, \n          `merge ${manager.escapeArg(sourceBranch)} -m ${manager.escapeArg(message)}`\n        );\n        mergeCommit = await manager.execGit(refPath, 'rev-parse HEAD');\n      }\n      \n      // Get commit info\n      const commitInfo = await manager.execGit(refPath, 'log -1 --format=%H%n%an%n%ae%n%at%n%s');\n      const [hash, author, email, timestamp, subject] = commitInfo.split('\\n');\n      \n      // Get diff of the merge\n      const diffOutput = await manager.execGit(refPath, `diff --stat ${originalTargetCommit}..HEAD`);\n      \n      // Record merge in database if available\n      if (req.app.locals.db) {\n        try {\n          await req.app.locals.db.run(\n            `INSERT INTO ref_changes (execution_id, ref_id, change_type, branch_name, commit_hash, commit_message, merge_status) \n             VALUES (?, ?, ?, ?, ?, ?, ?)`,\n            [null, refId, 'merge', sourceBranch, mergeCommit, subject, 'success']\n          );\n        } catch (dbError) {\n          logger.warn('Failed to record merge in database:', dbError);\n          // Don't fail the merge if database recording fails\n        }\n      }\n      \n      res.json({\n        success: true,\n        refId,\n        merge: {\n          sourceBranch,\n          targetBranch,\n          strategy,\n          commit: {\n            hash,\n            author,\n            email,\n            timestamp: new Date(parseInt(timestamp) * 1000).toISOString(),\n            message: subject\n          },\n          diff: {\n            summary: diffOutput,\n            originalCommit: originalTargetCommit,\n            mergeCommit\n          },\n          output: mergeOutput\n        }\n      });\n      \n    } catch (error) {\n      // Handle merge conflicts\n      if (error.message.includes('CONFLICT') || error.message.includes('conflict')) {\n        // Get conflict details\n        let conflictInfo = {};\n        \n        try {\n          const status = await manager.execGit(refPath, 'status --porcelain');\n          const conflictFiles = status.split('\\n')\n            .filter(line => line.startsWith('UU ') || line.startsWith('AA ') || line.startsWith('DD '))\n            .map(line => line.substring(3).trim());\n          \n          conflictInfo = {\n            files: conflictFiles,\n            count: conflictFiles.length\n          };\n          \n          // Get conflict markers for first few files\n          if (conflictFiles.length > 0) {\n            const conflictDetails = [];\n            for (const file of conflictFiles.slice(0, 3)) { // Limit to first 3 files\n              try {\n                const content = await fs.readFile(path.join(refPath, file), 'utf8');\n                const conflicts = [];\n                const lines = content.split('\\n');\n                \n                let inConflict = false;\n                let conflictStart = -1;\n                for (let i = 0; i < lines.length; i++) {\n                  if (lines[i].startsWith('<<<<<<<')) {\n                    inConflict = true;\n                    conflictStart = i;\n                  } else if (lines[i].startsWith('>>>>>>>') && inConflict) {\n                    conflicts.push({\n                      startLine: conflictStart + 1,\n                      endLine: i + 1,\n                      lines: lines.slice(conflictStart, i + 1)\n                    });\n                    inConflict = false;\n                  }\n                }\n                \n                conflictDetails.push({\n                  file,\n                  conflicts\n                });\n              } catch (readError) {\n                conflictDetails.push({\n                  file,\n                  error: 'Could not read conflict details'\n                });\n              }\n            }\n            \n            conflictInfo.details = conflictDetails;\n          }\n          \n          // Abort the merge\n          try {\n            if (strategy === 'rebase') {\n              await manager.execGit(refPath, 'rebase --abort');\n            } else {\n              await manager.execGit(refPath, 'merge --abort');\n            }\n          } catch (abortError) {\n            logger.warn('Failed to abort merge:', abortError);\n          }\n          \n        } catch (statusError) {\n          logger.warn('Failed to get conflict details:', statusError);\n        }\n        \n        return res.status(409).json({\n          success: false,\n          error: {\n            code: 'MERGE_CONFLICT',\n            message: 'Merge conflicts detected',\n            conflicts: conflictInfo\n          },\n          refId,\n          merge: {\n            sourceBranch,\n            targetBranch,\n            strategy,\n            aborted: true\n          }\n        });\n      }\n      \n      // Handle other merge errors\n      throw error;\n    }\n    \n  } catch (error) {\n    logger.error(`Merge failed for ${req.params.refId}:`, error);\n    \n    // Try to get back to a clean state\n    try {\n      const manager = getRefManager(req);\n      const refPath = path.join(req.app.locals.workspace.workspace, 'refs', req.params.refId);\n      await manager.execGit(refPath, 'checkout main');\n    } catch (cleanupError) {\n      logger.warn('Failed to cleanup after merge error:', cleanupError);\n    }\n    \n    res.status(500).json({\n      success: false,\n      error: {\n        code: 'MERGE_FAILED',\n        message: error.message\n      },\n      refId: req.params.refId\n    });\n  }\n});\n\n// Get diff between branches\nrouter.get('/refs/:refId/diff', async (req, res, next) => {\n  try {\n    const { refId } = req.params;\n    const { from, to = 'main', format = 'unified' } = req.query;\n    const manager = getRefManager(req);\n    \n    if (!from) {\n      return res.status(400).json({\n        error: {\n          code: 'MISSING_FROM_BRANCH',\n          message: 'From branch is required'\n        }\n      });\n    }\n    \n    if (!await manager.refExists(refId)) {\n      return res.status(404).json({\n        error: {\n          code: 'REF_NOT_FOUND',\n          message: `Reference '${refId}' not found`\n        }\n      });\n    }\n    \n    const refPath = path.join(req.app.locals.workspace.workspace, 'refs', refId);\n    \n    // Check if both branches exist\n    const branchInfo = await manager.listBranches(refId);\n    const branches = branchInfo.branches.map(b => b.name);\n    \n    if (!branches.includes(from)) {\n      return res.status(404).json({\n        error: {\n          code: 'FROM_BRANCH_NOT_FOUND',\n          message: `From branch '${from}' not found`\n        }\n      });\n    }\n    \n    if (!branches.includes(to)) {\n      return res.status(404).json({\n        error: {\n          code: 'TO_BRANCH_NOT_FOUND',\n          message: `To branch '${to}' not found`\n        }\n      });\n    }\n    \n    // Get diff statistics\n    const diffStat = await manager.execGit(refPath, \n      `diff --stat ${manager.escapeArg(to)}..${manager.escapeArg(from)}`\n    );\n    \n    // Get commit count difference\n    const commitCount = await manager.execGit(refPath,\n      `rev-list --count ${manager.escapeArg(to)}..${manager.escapeArg(from)}`\n    );\n    \n    let diffContent;\n    if (format === 'name-only') {\n      diffContent = await manager.execGit(refPath,\n        `diff --name-only ${manager.escapeArg(to)}..${manager.escapeArg(from)}`\n      );\n    } else if (format === 'name-status') {\n      diffContent = await manager.execGit(refPath,\n        `diff --name-status ${manager.escapeArg(to)}..${manager.escapeArg(from)}`\n      );\n    } else {\n      // Unified diff format\n      diffContent = await manager.execGit(refPath,\n        `diff ${manager.escapeArg(to)}..${manager.escapeArg(from)}`\n      );\n    }\n    \n    // Parse changed files\n    const changedFiles = [];\n    if (diffStat) {\n      const statLines = diffStat.split('\\n').slice(0, -1); // Remove summary line\n      for (const line of statLines) {\n        const match = line.match(/^\\s*(.+?)\\s+\\|\\s+(\\d+)\\s+([+-]+)$/);\n        if (match) {\n          const [, filename, changes, indicators] = match;\n          const additions = (indicators.match(/\\+/g) || []).length;\n          const deletions = (indicators.match(/-/g) || []).length;\n          \n          changedFiles.push({\n            filename,\n            changes: parseInt(changes),\n            additions,\n            deletions\n          });\n        }\n      }\n    }\n    \n    res.json({\n      refId,\n      diff: {\n        from,\n        to,\n        format,\n        commitCount: parseInt(commitCount) || 0,\n        changedFiles,\n        summary: diffStat,\n        content: diffContent\n      }\n    });\n    \n  } catch (error) {\n    next(error);\n  }\n});\n\n// Get logs for a specific execution\nrouter.get('/executions/:executionId/logs', async (req, res, next) => {\n  try {\n    const { executionId } = req.params;\n    const { db } = req.app.locals;\n    \n    // Get logs for this execution\n    const logs = await db.all(`\n      SELECT timestamp, type, content\n      FROM logs\n      WHERE execution_id = ?\n      ORDER BY timestamp ASC\n    `, [executionId]);\n    \n    res.json({\n      executionId,\n      logs: logs.map(log => ({\n        timestamp: log.timestamp,\n        type: log.type,\n        content: typeof log.content === 'string' ? JSON.parse(log.content) : log.content\n      }))\n    });\n  } catch (error) {\n    logger.error('Failed to get logs for execution', { executionId: req.params.executionId, error: error.message });\n    next(error);\n  }\n});\n\nexport default router;","import express from 'express';\nimport { v4 as uuidv4 } from 'uuid';\nimport path from 'node:path';\nimport { promises as fs } from 'node:fs';\nimport { createLogger } from '../logger.js';\nimport { spawn } from 'node:child_process';\nimport { EventEmitter } from 'node:events';\n\nconst logger = createLogger('ref-preview-routes');\nconst router = express.Router();\n\n// Store active previews\nconst activePreviews = new Map();\n\n// Port management\nlet currentPort = 3000;\nconst MAX_PORT = 3999;\n\nfunction getNextAvailablePort() {\n  currentPort++;\n  if (currentPort > MAX_PORT) {\n    currentPort = 3000;\n  }\n  return currentPort;\n}\n\n// Helper to detect package manager\nasync function detectPackageManager(refPath) {\n  try {\n    await fs.access(path.join(refPath, 'package-lock.json'));\n    return 'npm';\n  } catch {}\n  \n  try {\n    await fs.access(path.join(refPath, 'yarn.lock'));\n    return 'yarn';\n  } catch {}\n  \n  try {\n    await fs.access(path.join(refPath, 'pnpm-lock.yaml'));\n    return 'pnpm';\n  } catch {}\n  \n  try {\n    await fs.access(path.join(refPath, 'bun.lockb'));\n    return 'bun';\n  } catch {}\n  \n  // Default to npm if package.json exists\n  try {\n    await fs.access(path.join(refPath, 'package.json'));\n    return 'npm';\n  } catch {}\n  \n  return null;\n}\n\n// Get the ref path from workspace\nfunction getRefPath(workspace, refId) {\n  return path.join(workspace, 'refs', refId);\n}\n\n// Start preview for a ref\nrouter.post('/refs/:refId/preview/start', async (req, res) => {\n  try {\n    const { refId } = req.params;\n    const { workspace } = req.app.locals;\n    \n    logger.info(`Starting preview for ref ${refId}`);\n    \n    // Check if preview already exists\n    if (activePreviews.has(refId)) {\n      const preview = activePreviews.get(refId);\n      if (preview.status === 'running') {\n        return res.json({\n          success: true,\n          previewId: preview.id,\n          port: preview.port,\n          url: `http://localhost:${preview.port}`,\n          status: 'running'\n        });\n      }\n    }\n    \n    const refPath = getRefPath(workspace.workspace, refId);\n    \n    // Check if ref exists\n    try {\n      await fs.access(refPath);\n    } catch {\n      return res.status(404).json({\n        error: {\n          code: 'REF_NOT_FOUND',\n          message: `Reference ${refId} not found`\n        }\n      });\n    }\n    \n    // Detect package manager\n    const packageManager = await detectPackageManager(refPath);\n    if (!packageManager) {\n      return res.status(400).json({\n        error: {\n          code: 'NO_PACKAGE_JSON',\n          message: 'No package.json found in reference'\n        }\n      });\n    }\n    \n    // Create preview record\n    const previewId = uuidv4();\n    const port = getNextAvailablePort();\n    const preview = {\n      id: previewId,\n      refId,\n      port,\n      status: 'installing',\n      logs: [],\n      process: null,\n      eventEmitter: new EventEmitter()\n    };\n    \n    activePreviews.set(refId, preview);\n    \n    // Start installation process\n    logger.info(`Installing dependencies with ${packageManager} for ref ${refId}`);\n    \n    const installCmd = packageManager === 'npm' ? 'npm' : packageManager;\n    const installArgs = ['install'];\n    \n    const installProcess = spawn(installCmd, installArgs, {\n      cwd: refPath,\n      env: { ...process.env, CI: 'true' }\n    });\n    \n    installProcess.stdout.on('data', (data) => {\n      const log = { timestamp: new Date().toISOString(), type: 'info', content: data.toString() };\n      preview.logs.push(log);\n      preview.eventEmitter.emit('log', log);\n    });\n    \n    installProcess.stderr.on('data', (data) => {\n      const log = { timestamp: new Date().toISOString(), type: 'error', content: data.toString() };\n      preview.logs.push(log);\n      preview.eventEmitter.emit('log', log);\n    });\n    \n    installProcess.on('close', (code) => {\n      if (code !== 0) {\n        preview.status = 'error';\n        preview.eventEmitter.emit('status', { status: 'error' });\n        return;\n      }\n      \n      // Start the dev server\n      preview.status = 'starting';\n      preview.eventEmitter.emit('status', { status: 'starting' });\n      \n      logger.info(`Starting dev server on port ${port} for ref ${refId}`);\n      \n      const devCmd = packageManager === 'npm' ? 'npm' : packageManager;\n      const devArgs = ['run', 'dev'];\n      \n      const devProcess = spawn(devCmd, devArgs, {\n        cwd: refPath,\n        env: {\n          ...process.env,\n          PORT: port.toString(),\n          VITE_PORT: port.toString(), // For Vite\n          NEXT_PORT: port.toString(), // For Next.js\n          REACT_APP_PORT: port.toString(), // For CRA\n        }\n      });\n      \n      preview.process = devProcess;\n      \n      devProcess.stdout.on('data', (data) => {\n        const log = { timestamp: new Date().toISOString(), type: 'info', content: data.toString() };\n        preview.logs.push(log);\n        preview.eventEmitter.emit('log', log);\n        \n        // Check if server is ready\n        const output = data.toString().toLowerCase();\n        if (output.includes('ready') || output.includes('running') || output.includes('started') || output.includes(`localhost:${port}`)) {\n          preview.status = 'running';\n          preview.eventEmitter.emit('status', { \n            status: 'running', \n            port: preview.port,\n            url: `http://localhost:${preview.port}`\n          });\n        }\n      });\n      \n      devProcess.stderr.on('data', (data) => {\n        const log = { timestamp: new Date().toISOString(), type: 'error', content: data.toString() };\n        preview.logs.push(log);\n        preview.eventEmitter.emit('log', log);\n      });\n      \n      devProcess.on('close', (code) => {\n        logger.info(`Dev server for ref ${refId} exited with code ${code}`);\n        preview.status = 'stopped';\n        preview.eventEmitter.emit('status', { status: 'stopped' });\n        activePreviews.delete(refId);\n      });\n    });\n    \n    res.json({\n      success: true,\n      previewId,\n      port,\n      status: 'installing'\n    });\n  } catch (error) {\n    logger.error('Error starting preview:', error);\n    res.status(500).json({\n      error: {\n        code: 'PREVIEW_START_FAILED',\n        message: error.message\n      }\n    });\n  }\n});\n\n// Get preview status\nrouter.get('/refs/:refId/preview/status', async (req, res) => {\n  try {\n    const { refId } = req.params;\n    \n    const preview = activePreviews.get(refId);\n    if (!preview) {\n      return res.json({\n        status: 'stopped',\n        running: false\n      });\n    }\n    \n    res.json({\n      status: preview.status,\n      running: preview.status === 'running',\n      port: preview.port,\n      url: preview.status === 'running' ? `http://localhost:${preview.port}` : undefined,\n      previewId: preview.id\n    });\n  } catch (error) {\n    logger.error('Error getting preview status:', error);\n    res.status(500).json({\n      error: {\n        code: 'STATUS_FAILED',\n        message: error.message\n      }\n    });\n  }\n});\n\n// Stop preview\nrouter.post('/refs/:refId/preview/stop', async (req, res) => {\n  try {\n    const { refId } = req.params;\n    \n    const preview = activePreviews.get(refId);\n    if (!preview) {\n      return res.json({ success: true });\n    }\n    \n    if (preview.process) {\n      preview.process.kill('SIGTERM');\n      // Give it time to terminate gracefully\n      setTimeout(() => {\n        if (preview.process && !preview.process.killed) {\n          preview.process.kill('SIGKILL');\n        }\n      }, 5000);\n    }\n    \n    activePreviews.delete(refId);\n    \n    res.json({ success: true });\n  } catch (error) {\n    logger.error('Error stopping preview:', error);\n    res.status(500).json({\n      error: {\n        code: 'STOP_FAILED',\n        message: error.message\n      }\n    });\n  }\n});\n\n// Stream logs via SSE\nrouter.get('/refs/:refId/preview/logs', async (req, res) => {\n  try {\n    const { refId } = req.params;\n    const { previewId } = req.query;\n    \n    const preview = activePreviews.get(refId);\n    if (!preview || preview.id !== previewId) {\n      return res.status(404).json({\n        error: {\n          code: 'PREVIEW_NOT_FOUND',\n          message: 'Preview not found'\n        }\n      });\n    }\n    \n    logger.info(`Starting log stream for ref ${refId} preview ${previewId}`);\n    \n    res.writeHead(200, {\n      'Content-Type': 'text/event-stream',\n      'Cache-Control': 'no-cache',\n      'Connection': 'keep-alive',\n      'Access-Control-Allow-Origin': '*'\n    });\n    \n    // Send recent logs\n    preview.logs.slice(-50).forEach(log => {\n      res.write(`event: log\\ndata: ${JSON.stringify(log)}\\n\\n`);\n    });\n    \n    // Send current status\n    res.write(`event: status\\ndata: ${JSON.stringify({\n      status: preview.status,\n      port: preview.port,\n      url: preview.status === 'running' ? `http://localhost:${preview.port}` : undefined\n    })}\\n\\n`);\n    \n    // Listen for new logs\n    const logHandler = (log) => {\n      res.write(`event: log\\ndata: ${JSON.stringify(log)}\\n\\n`);\n    };\n    \n    const statusHandler = (status) => {\n      res.write(`event: status\\ndata: ${JSON.stringify(status)}\\n\\n`);\n    };\n    \n    preview.eventEmitter.on('log', logHandler);\n    preview.eventEmitter.on('status', statusHandler);\n    \n    // Heartbeat\n    const heartbeat = setInterval(() => {\n      res.write(':heartbeat\\n\\n');\n    }, 30000);\n    \n    // Cleanup on disconnect\n    req.on('close', () => {\n      clearInterval(heartbeat);\n      preview.eventEmitter.off('log', logHandler);\n      preview.eventEmitter.off('status', statusHandler);\n      logger.info(`Log stream closed for ref ${refId}`);\n    });\n  } catch (error) {\n    logger.error('Error streaming logs:', error);\n    res.status(500).json({\n      error: {\n        code: 'STREAM_FAILED',\n        message: error.message\n      }\n    });\n  }\n});\n\nexport default router;","import { promises as fs } from 'node:fs';\nimport path from 'node:path';\nimport { createLogger } from '../logger.js';\n\nconst logger = createLogger('CleanupManager');\n\nclass CleanupManager {\n  constructor(workspaceManager, refManager, contextManager, db) {\n    this.workspaceManager = workspaceManager;\n    this.refManager = refManager;\n    this.contextManager = contextManager;\n    this.db = db;\n  }\n\n  /**\n   * Clean up all resources for an execution\n   */\n  async cleanupExecution(executionId, options = {}) {\n    logger.info(`Starting cleanup for execution ${executionId}`);\n    const results = {\n      success: true,\n      worktrees: { removed: 0, failed: 0 },\n      workspace: { removed: false },\n      branches: { removed: 0, failed: 0 },\n      errors: []\n    };\n\n    try {\n      // Get execution manifest\n      const manifest = await this.contextManager.getExecutionManifest(executionId);\n      if (!manifest) {\n        logger.warn(`No manifest found for execution ${executionId}, cleaning workspace only`);\n        return await this.cleanupWorkspaceOnly(executionId, options);\n      }\n\n      // Clean up worktrees\n      if (manifest.worktrees) {\n        const worktreeResults = await this.cleanupWorktrees(executionId, manifest.worktrees, options);\n        results.worktrees = worktreeResults;\n      }\n\n      // Clean up execution branches (after worktrees are removed)\n      if (!options.keepBranches && manifest.worktrees) {\n        const branchResults = await this.cleanupBranches(executionId, manifest.worktrees);\n        results.branches = branchResults;\n      }\n\n      // Clean up execution workspace\n      if (!options.keepWorkspace) {\n        try {\n          await this.contextManager.cleanupExecutionWorkspace(executionId);\n          results.workspace.removed = true;\n        } catch (error) {\n          logger.error(`Failed to cleanup workspace for ${executionId}:`, error);\n          results.errors.push({ type: 'workspace', error: error.message });\n          results.success = false;\n        }\n      }\n\n      // Update database\n      if (options.updateDatabase !== false) {\n        await this.updateCleanupStatus(executionId, results);\n      }\n\n    } catch (error) {\n      logger.error(`Cleanup failed for execution ${executionId}:`, error);\n      results.success = false;\n      results.errors.push({ type: 'general', error: error.message });\n    }\n\n    logger.info(`Cleanup completed for execution ${executionId}`, results);\n    return results;\n  }\n\n  /**\n   * Clean up worktrees\n   */\n  async cleanupWorktrees(executionId, worktrees, options = {}) {\n    const results = { removed: 0, failed: 0, details: {} };\n\n    for (const [refId, worktreeInfo] of Object.entries(worktrees)) {\n      try {\n        logger.info(`Removing worktree for ref ${refId} in execution ${executionId}`);\n        \n        // Force removal if specified\n        if (options.force) {\n          // First try to remove any uncommitted changes\n          try {\n            await this.refManager.execGit(worktreeInfo.worktreePath, 'reset --hard HEAD');\n            await this.refManager.execGit(worktreeInfo.worktreePath, 'clean -fd');\n          } catch (e) {\n            // Ignore errors in cleanup attempt\n          }\n        }\n\n        await this.refManager.removeWorktree(refId, worktreeInfo.worktreePath);\n        results.removed++;\n        results.details[refId] = { success: true };\n      } catch (error) {\n        logger.error(`Failed to remove worktree for ref ${refId}:`, error);\n        results.failed++;\n        results.details[refId] = { success: false, error: error.message };\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Clean up execution branches (DISABLED - we preserve branches for audit trail)\n   */\n  async cleanupBranches(executionId, worktrees) {\n    const results = { removed: 0, failed: 0, details: {} };\n    const branchName = `exec-${executionId}`;\n\n    // NOTE: We intentionally preserve execution branches for audit trail\n    // Each execution branch shows exactly what changes that execution made\n    logger.info(`Preserving execution branch ${branchName} for audit trail`);\n    \n    for (const [refId, worktreeInfo] of Object.entries(worktrees)) {\n      results.details[refId] = { \n        success: true, \n        action: 'preserved',\n        message: 'Execution branch preserved for audit trail'\n      };\n    }\n\n    return results;\n  }\n\n  /**\n   * Clean up workspace when no manifest exists\n   */\n  async cleanupWorkspaceOnly(executionId, options = {}) {\n    const results = {\n      success: true,\n      workspace: { removed: false },\n      errors: []\n    };\n\n    if (!options.keepWorkspace) {\n      try {\n        const executionPath = path.join(this.workspaceManager.getWorkspacePath(), '.execution', `exec-${executionId}`);\n        await fs.rm(executionPath, { recursive: true, force: true });\n        results.workspace.removed = true;\n      } catch (error) {\n        logger.error(`Failed to cleanup workspace for ${executionId}:`, error);\n        results.success = false;\n        results.errors.push({ type: 'workspace', error: error.message });\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Clean up orphaned executions older than specified hours\n   */\n  async cleanupOrphanedExecutions(olderThanHours = 24) {\n    logger.info(`Cleaning up orphaned executions older than ${olderThanHours} hours`);\n    const results = {\n      checked: 0,\n      cleaned: 0,\n      failed: 0,\n      errors: []\n    };\n\n    try {\n      // Get all execution directories\n      const executionsDir = path.join(this.workspaceManager.getWorkspacePath(), '.execution');\n      const entries = await fs.readdir(executionsDir, { withFileTypes: true });\n      \n      const cutoffTime = Date.now() - (olderThanHours * 60 * 60 * 1000);\n\n      for (const entry of entries) {\n        if (entry.isDirectory() && entry.name.startsWith('exec-')) {\n          results.checked++;\n          const executionId = entry.name.substring(5);\n          const executionPath = path.join(executionsDir, entry.name);\n\n          try {\n            // Check if execution exists in database\n            const execution = await this.db.get(\n              'SELECT id, status, created_at, workspace_preserved FROM executions WHERE id = ?',\n              [executionId]\n            );\n\n            const stat = await fs.stat(executionPath);\n            const isOld = stat.mtimeMs < cutoffTime;\n\n            // Clean up if:\n            // 1. Not in database and old\n            // 2. In database but completed/failed and old AND not preserved\n            if (!execution && isOld) {\n              logger.info(`Cleaning orphaned execution ${executionId} (not in database)`);\n              await this.cleanupExecution(executionId, { force: true });\n              results.cleaned++;\n            } else if (execution && isOld && ['completed', 'failed'].includes(execution.status)) {\n              // Check if workspace is preserved\n              if (execution.workspace_preserved === 1) {\n                logger.info(`Skipping preserved execution ${executionId}`);\n              } else {\n                logger.info(`Cleaning old ${execution.status} execution ${executionId}`);\n                await this.cleanupExecution(executionId, { force: true });\n                results.cleaned++;\n              }\n            }\n          } catch (error) {\n            logger.error(`Failed to process execution ${executionId}:`, error);\n            results.failed++;\n            results.errors.push({ executionId, error: error.message });\n          }\n        }\n      }\n    } catch (error) {\n      logger.error('Failed to list execution directories:', error);\n      results.errors.push({ type: 'list', error: error.message });\n    }\n\n    logger.info('Orphaned execution cleanup completed', results);\n    return results;\n  }\n\n  /**\n   * Rollback an execution (remove without merging)\n   */\n  async rollbackExecution(executionId, reason = 'User requested rollback') {\n    logger.info(`Rolling back execution ${executionId}: ${reason}`);\n    \n    try {\n      // Get execution info\n      const execution = await this.db.get(\n        'SELECT * FROM executions WHERE id = ?',\n        [executionId]\n      );\n\n      if (!execution) {\n        throw new Error(`Execution ${executionId} not found`);\n      }\n\n      // Record rollback in database\n      await this.db.run(\n        `INSERT INTO ref_changes (execution_id, ref_id, change_type, commit_message) \n         VALUES (?, ?, ?, ?)`,\n        [executionId, null, 'rollback', reason]\n      );\n\n      // Clean up with force flag\n      const results = await this.cleanupExecution(executionId, {\n        force: true,\n        keepBranches: false,\n        keepWorkspace: false\n      });\n\n      // Update execution status\n      await this.db.run(\n        'UPDATE executions SET status = ?, completed_at = CURRENT_TIMESTAMP WHERE id = ?',\n        ['rolled_back', executionId]\n      );\n\n      return {\n        success: true,\n        executionId,\n        reason,\n        cleanup: results\n      };\n\n    } catch (error) {\n      logger.error(`Rollback failed for execution ${executionId}:`, error);\n      return {\n        success: false,\n        executionId,\n        error: error.message\n      };\n    }\n  }\n\n  /**\n   * Update cleanup status in database\n   */\n  async updateCleanupStatus(executionId, results) {\n    try {\n      const cleanupData = JSON.stringify({\n        timestamp: new Date().toISOString(),\n        results\n      });\n\n      await this.db.run(\n        `UPDATE executions \n         SET cleanup_status = ?, cleanup_at = CURRENT_TIMESTAMP \n         WHERE id = ?`,\n        [cleanupData, executionId]\n      );\n    } catch (error) {\n      logger.error(`Failed to update cleanup status for ${executionId}:`, error);\n    }\n  }\n\n  /**\n   * Get cleanup status for an execution\n   */\n  async getCleanupStatus(executionId) {\n    const execution = await this.db.get(\n      'SELECT cleanup_status, cleanup_at FROM executions WHERE id = ?',\n      [executionId]\n    );\n\n    if (!execution || !execution.cleanup_status) {\n      return null;\n    }\n\n    try {\n      return JSON.parse(execution.cleanup_status);\n    } catch (error) {\n      return execution.cleanup_status;\n    }\n  }\n}\n\nexport default CleanupManager;","import express from 'express';\nimport { createLogger } from '../logger.js';\nimport CleanupManager from '../services/CleanupManager.js';\nimport RefManager from '../services/RefManager.js';\nimport ExecutionContextManager from '../services/ExecutionContextManager.js';\nimport * as validators from '../validators.js';\nimport { NotFoundError, ProcessError, createErrorResponse } from '../errors.js';\nimport { ErrorCodes, ExecutionStatus } from '../constants.js';\n\nconst logger = createLogger('cleanup-routes');\nconst router = express.Router();\n\n// POST /executions/:executionId/cleanup - Clean up a specific execution\nrouter.post('/executions/:executionId/cleanup', async (req, res, next) => {\n  try {\n    const { executionId } = req.params;\n    const { force = false, keepBranches = false, keepWorkspace = false } = req.body;\n    \n    const { workspaceManager, db } = req.app.locals;\n    const refManager = new RefManager(workspaceManager.getWorkspacePath());\n    const contextManager = new ExecutionContextManager(workspaceManager, refManager);\n    const cleanupManager = new CleanupManager(workspaceManager, refManager, contextManager, db);\n    \n    logger.info(`Manual cleanup requested for execution ${executionId}`, { force, keepBranches, keepWorkspace });\n    \n    const results = await cleanupManager.cleanupExecution(executionId, {\n      force,\n      keepBranches,\n      keepWorkspace\n    });\n    \n    res.json({\n      executionId,\n      cleanup: results\n    });\n    \n  } catch (error) {\n    logger.error('Cleanup error:', error);\n    next(error);\n  }\n});\n\n// POST /executions/:executionId/rollback - Rollback an execution\nrouter.post('/executions/:executionId/rollback', async (req, res, next) => {\n  try {\n    const { executionId } = req.params;\n    const { reason = 'Manual rollback requested' } = req.body;\n    \n    const { workspaceManager, db } = req.app.locals;\n    const refManager = new RefManager(workspaceManager.getWorkspacePath());\n    const contextManager = new ExecutionContextManager(workspaceManager, refManager);\n    const cleanupManager = new CleanupManager(workspaceManager, refManager, contextManager, db);\n    \n    logger.info(`Rollback requested for execution ${executionId}`, { reason });\n    \n    const result = await cleanupManager.rollbackExecution(executionId, reason);\n    \n    if (result.success) {\n      res.json(result);\n    } else {\n      res.status(400).json({\n        error: {\n          code: 'ROLLBACK_FAILED',\n          message: result.error\n        }\n      });\n    }\n    \n  } catch (error) {\n    logger.error('Rollback error:', error);\n    next(error);\n  }\n});\n\n// GET /executions/:executionId/cleanup/status - Get cleanup status\nrouter.get('/executions/:executionId/cleanup/status', async (req, res, next) => {\n  try {\n    const { executionId } = req.params;\n    \n    const { workspaceManager, db } = req.app.locals;\n    const refManager = new RefManager(workspaceManager.getWorkspacePath());\n    const contextManager = new ExecutionContextManager(workspaceManager, refManager);\n    const cleanupManager = new CleanupManager(workspaceManager, refManager, contextManager, db);\n    \n    const status = await cleanupManager.getCleanupStatus(executionId);\n    \n    if (status) {\n      res.json({\n        executionId,\n        cleanupStatus: status\n      });\n    } else {\n      res.status(404).json({\n        error: {\n          code: 'NO_CLEANUP_STATUS',\n          message: 'No cleanup status found for this execution'\n        }\n      });\n    }\n    \n  } catch (error) {\n    logger.error('Get cleanup status error:', error);\n    next(error);\n  }\n});\n\n// POST /cleanup/orphaned - Clean up orphaned executions\nrouter.post('/cleanup/orphaned', async (req, res, next) => {\n  try {\n    const { olderThanHours = 24 } = req.body;\n    \n    const { workspaceManager, db } = req.app.locals;\n    const refManager = new RefManager(workspaceManager.getWorkspacePath());\n    const contextManager = new ExecutionContextManager(workspaceManager, refManager);\n    const cleanupManager = new CleanupManager(workspaceManager, refManager, contextManager, db);\n    \n    logger.info(`Cleaning orphaned executions older than ${olderThanHours} hours`);\n    \n    const results = await cleanupManager.cleanupOrphanedExecutions(olderThanHours);\n    \n    res.json({\n      olderThanHours,\n      results\n    });\n    \n  } catch (error) {\n    logger.error('Orphaned cleanup error:', error);\n    next(error);\n  }\n});\n\n/**\n * DELETE /executions/:executionId/workspace - Delete execution workspace manually\n */\nrouter.delete('/executions/:executionId/workspace', async (req, res, next) => {\n  try {\n    const executionId = validators.validateExecutionId(req.params.executionId);\n    const { workspaceManager, db } = req.app.locals;\n    \n    // Check if execution exists\n    const execution = await db.get(\n      'SELECT id, status FROM executions WHERE id = ?',\n      [executionId]\n    );\n    \n    if (!execution) {\n      throw new NotFoundError(`Execution not found: ${executionId}`);\n    }\n    \n    // Only allow cleanup of completed/failed executions\n    if (execution.status === ExecutionStatus.RUNNING || execution.status === ExecutionStatus.STARTING) {\n      throw new ProcessError(\n        ErrorCodes.PROCESS_RUNNING,\n        `Cannot delete workspace for running execution (status: ${execution.status})`\n      );\n    }\n    \n    logger.info(`Manual workspace deletion requested for execution ${executionId}`);\n    \n    // Initialize cleanup manager\n    const refManager = new RefManager(workspaceManager.getWorkspacePath());\n    const contextManager = new ExecutionContextManager(workspaceManager, refManager);\n    const cleanupManager = new CleanupManager(workspaceManager, refManager, contextManager, db);\n    \n    // Perform cleanup\n    const results = await cleanupManager.cleanupExecution(executionId, {\n      keepBranches: true,  // Still preserve branches for audit\n      keepWorkspace: false,\n      updateDatabase: true\n    });\n    \n    // Update workspace_preserved flag\n    await db.run(\n      'UPDATE executions SET workspace_preserved = 0 WHERE id = ?',\n      [executionId]\n    );\n    \n    res.json({\n      success: results.success,\n      executionId,\n      cleanup: results\n    });\n    \n  } catch (error) {\n    if (error.name === 'ValidationError') {\n      return res.status(400).json(createErrorResponse(error));\n    }\n    if (error.name === 'NotFoundError') {\n      return res.status(404).json(createErrorResponse(error));\n    }\n    if (error.name === 'ProcessError') {\n      return res.status(400).json(createErrorResponse(error));\n    }\n    next(error);\n  }\n});\n\nexport default router;","import express from 'express';\nimport { createLogger } from '../logger.js';\n\nconst logger = createLogger('resources-routes');\nconst router = express.Router();\n\n// GET /resources/status - Get current resource status\nrouter.get('/resources/status', async (req, res, next) => {\n  try {\n    const { resourceMonitor } = req.app.locals;\n    \n    if (!resourceMonitor) {\n      return res.status(503).json({\n        error: {\n          code: 'RESOURCE_MONITOR_UNAVAILABLE',\n          message: 'Resource monitoring is not enabled'\n        }\n      });\n    }\n    \n    const report = await resourceMonitor.getResourceReport();\n    \n    res.json({\n      status: report.healthy ? 'healthy' : 'warning',\n      timestamp: report.timestamp,\n      limits: report.limits,\n      usage: report.usage\n    });\n    \n  } catch (error) {\n    logger.error('Resource status error:', error);\n    next(error);\n  }\n});\n\n// GET /resources/can-execute - Check if new execution can start\nrouter.get('/resources/can-execute', async (req, res, next) => {\n  try {\n    const { resourceMonitor } = req.app.locals;\n    \n    if (!resourceMonitor) {\n      return res.json({\n        canExecute: true,\n        reason: 'Resource monitoring disabled'\n      });\n    }\n    \n    const canExecute = await resourceMonitor.canStartExecution();\n    const checks = await Promise.all([\n      resourceMonitor.checkConcurrentExecutions(),\n      resourceMonitor.checkDiskUsage(),\n      resourceMonitor.checkSystemResources()\n    ]);\n    \n    const blockedBy = checks.filter(check => !check.allowed);\n    \n    res.json({\n      canExecute,\n      checks: checks.reduce((acc, check) => {\n        acc[check.type] = {\n          allowed: check.allowed,\n          current: check.current,\n          limit: check.limit,\n          message: check.message\n        };\n        return acc;\n      }, {}),\n      blockedBy: blockedBy.map(check => check.type)\n    });\n    \n  } catch (error) {\n    logger.error('Can execute check error:', error);\n    next(error);\n  }\n});\n\n// GET /resources/usage/history - Get resource usage history\nrouter.get('/resources/usage/history', async (req, res, next) => {\n  try {\n    const { db } = req.app.locals;\n    const { \n      hours = 24, \n      type = null,\n      limit = 100 \n    } = req.query;\n    \n    let sql = `\n      SELECT * FROM resource_usage \n      WHERE timestamp > datetime('now', '-${parseInt(hours)} hours')\n    `;\n    const params = [];\n    \n    if (type) {\n      sql += ' AND type = ?';\n      params.push(type);\n    }\n    \n    sql += ' ORDER BY timestamp DESC LIMIT ?';\n    params.push(parseInt(limit));\n    \n    const history = await db.all(sql, params);\n    \n    res.json({\n      history: history.map(record => ({\n        timestamp: record.timestamp,\n        type: record.type,\n        current: record.current_value,\n        limit: record.limit_value,\n        exceeded: Boolean(record.exceeded),\n        details: record.details ? JSON.parse(record.details) : null\n      })),\n      totalRecords: history.length,\n      hoursBack: parseInt(hours)\n    });\n    \n  } catch (error) {\n    logger.error('Resource history error:', error);\n    next(error);\n  }\n});\n\nexport default router;","import express from 'express';\nimport { createLogger } from '../logger.js';\n\nconst logger = createLogger('monitoring-routes');\nconst router = express.Router();\n\n// GET /monitoring/metrics - Get performance metrics\nrouter.get('/monitoring/metrics', async (req, res, next) => {\n  try {\n    const { performanceMonitor } = req.app.locals;\n    \n    if (!performanceMonitor) {\n      return res.status(503).json({\n        error: {\n          code: 'PERFORMANCE_MONITOR_UNAVAILABLE',\n          message: 'Performance monitoring is not enabled'\n        }\n      });\n    }\n    \n    const metrics = performanceMonitor.getMetrics();\n    const slowOps = performanceMonitor.getSlowOperations(parseInt(req.query.slowThreshold) || 5000);\n    const activeOps = performanceMonitor.getActiveOperations();\n    const stuckOps = performanceMonitor.getStuckOperations(parseInt(req.query.stuckThreshold) || 300000);\n    \n    res.json({\n      metrics: metrics.metrics,\n      summary: {\n        activeOperations: metrics.activeOperations,\n        slowOperations: slowOps.length,\n        stuckOperations: stuckOps.length,\n        generatedAt: metrics.generatedAt\n      },\n      slowOperations: slowOps,\n      activeOperations: activeOps,\n      stuckOperations: stuckOps\n    });\n    \n  } catch (error) {\n    logger.error('Get metrics error:', error);\n    next(error);\n  }\n});\n\n// GET /monitoring/audit/:executionId - Get audit trail for execution\nrouter.get('/monitoring/audit/:executionId', async (req, res, next) => {\n  try {\n    const { executionId } = req.params;\n    const { auditLogger } = req.app.locals;\n    \n    if (!auditLogger) {\n      return res.status(503).json({\n        error: {\n          code: 'AUDIT_LOGGER_UNAVAILABLE',\n          message: 'Audit logging is not enabled'\n        }\n      });\n    }\n    \n    const auditTrail = await auditLogger.getExecutionAuditTrail(executionId);\n    \n    res.json({\n      execution: executionId,\n      auditTrail\n    });\n    \n  } catch (error) {\n    logger.error('Get audit trail error:', error);\n    next(error);\n  }\n});\n\n// GET /monitoring/system - Get system-wide metrics\nrouter.get('/monitoring/system', async (req, res, next) => {\n  try {\n    const { auditLogger } = req.app.locals;\n    const { timeWindow = '24 hours' } = req.query;\n    \n    if (!auditLogger) {\n      return res.status(503).json({\n        error: {\n          code: 'AUDIT_LOGGER_UNAVAILABLE',\n          message: 'Audit logging is not enabled'\n        }\n      });\n    }\n    \n    const systemMetrics = await auditLogger.getSystemMetrics(timeWindow);\n    \n    res.json(systemMetrics);\n    \n  } catch (error) {\n    logger.error('Get system metrics error:', error);\n    next(error);\n  }\n});\n\n// GET /monitoring/logs - Query audit logs\nrouter.get('/monitoring/logs', async (req, res, next) => {\n  try {\n    const { db } = req.app.locals;\n    const {\n      type = 'all', // 'git', 'events', 'performance', 'resources', 'all'\n      executionId = null,\n      operation = null,\n      success = null,\n      limit = 100,\n      offset = 0,\n      timeWindow = '24 hours'\n    } = req.query;\n    \n    const results = {};\n    const baseTimeFilter = `timestamp > datetime('now', '-${timeWindow}')`;\n    \n    // Build queries based on type\n    const queries = [];\n    \n    if (type === 'all' || type === 'git') {\n      let gitQuery = `\n        SELECT 'git' as log_type, * FROM git_operations_log \n        WHERE ${baseTimeFilter}\n      `;\n      const gitParams = [];\n      \n      if (executionId) {\n        gitQuery += ' AND execution_id = ?';\n        gitParams.push(executionId);\n      }\n      if (operation) {\n        gitQuery += ' AND operation = ?';\n        gitParams.push(operation);\n      }\n      if (success !== null) {\n        gitQuery += ' AND success = ?';\n        gitParams.push(success === 'true' ? 1 : 0);\n      }\n      \n      gitQuery += ' ORDER BY timestamp DESC LIMIT ? OFFSET ?';\n      gitParams.push(parseInt(limit), parseInt(offset));\n      \n      queries.push({ name: 'git', query: gitQuery, params: gitParams });\n    }\n    \n    if (type === 'all' || type === 'events') {\n      let eventsQuery = `\n        SELECT 'events' as log_type, * FROM execution_events_log \n        WHERE ${baseTimeFilter}\n      `;\n      const eventsParams = [];\n      \n      if (executionId) {\n        eventsQuery += ' AND execution_id = ?';\n        eventsParams.push(executionId);\n      }\n      if (operation) {\n        eventsQuery += ' AND event = ?';\n        eventsParams.push(operation);\n      }\n      if (success !== null) {\n        eventsQuery += ' AND success = ?';\n        eventsParams.push(success === 'true' ? 1 : 0);\n      }\n      \n      eventsQuery += ' ORDER BY timestamp DESC LIMIT ? OFFSET ?';\n      eventsParams.push(parseInt(limit), parseInt(offset));\n      \n      queries.push({ name: 'events', query: eventsQuery, params: eventsParams });\n    }\n    \n    if (type === 'all' || type === 'performance') {\n      let perfQuery = `\n        SELECT 'performance' as log_type, * FROM performance_metrics \n        WHERE ${baseTimeFilter}\n      `;\n      const perfParams = [];\n      \n      if (executionId) {\n        perfQuery += ' AND execution_id = ?';\n        perfParams.push(executionId);\n      }\n      if (operation) {\n        perfQuery += ' AND operation = ?';\n        perfParams.push(operation);\n      }\n      if (success !== null) {\n        perfQuery += ' AND success = ?';\n        perfParams.push(success === 'true' ? 1 : 0);\n      }\n      \n      perfQuery += ' ORDER BY timestamp DESC LIMIT ? OFFSET ?';\n      perfParams.push(parseInt(limit), parseInt(offset));\n      \n      queries.push({ name: 'performance', query: perfQuery, params: perfParams });\n    }\n    \n    if (type === 'all' || type === 'resources') {\n      let resourceQuery = `\n        SELECT 'resources' as log_type, * FROM resource_usage \n        WHERE ${baseTimeFilter}\n      `;\n      const resourceParams = [];\n      \n      if (executionId) {\n        resourceQuery += ' AND execution_id = ?';\n        resourceParams.push(executionId);\n      }\n      \n      resourceQuery += ' ORDER BY timestamp DESC LIMIT ? OFFSET ?';\n      resourceParams.push(parseInt(limit), parseInt(offset));\n      \n      queries.push({ name: 'resources', query: resourceQuery, params: resourceParams });\n    }\n    \n    // Execute queries\n    for (const { name, query, params } of queries) {\n      const logs = await db.all(query, params);\n      results[name] = logs.map(log => {\n        // Parse JSON fields\n        if (log.metadata) {\n          try {\n            log.metadata = JSON.parse(log.metadata);\n          } catch (e) {\n            // Keep as string if parsing fails\n          }\n        }\n        if (log.details) {\n          try {\n            log.details = JSON.parse(log.details);\n          } catch (e) {\n            // Keep as string if parsing fails\n          }\n        }\n        return log;\n      });\n    }\n    \n    res.json({\n      filters: {\n        type,\n        executionId,\n        operation,\n        success,\n        timeWindow,\n        limit: parseInt(limit),\n        offset: parseInt(offset)\n      },\n      results,\n      totalByType: Object.keys(results).reduce((acc, key) => {\n        acc[key] = results[key].length;\n        return acc;\n      }, {})\n    });\n    \n  } catch (error) {\n    logger.error('Query logs error:', error);\n    next(error);\n  }\n});\n\n// POST /monitoring/cleanup - Clean up old audit logs\nrouter.post('/monitoring/cleanup', async (req, res, next) => {\n  try {\n    const { auditLogger } = req.app.locals;\n    const { retentionDays = 30 } = req.body;\n    \n    if (!auditLogger) {\n      return res.status(503).json({\n        error: {\n          code: 'AUDIT_LOGGER_UNAVAILABLE',\n          message: 'Audit logging is not enabled'\n        }\n      });\n    }\n    \n    const result = await auditLogger.cleanupOldLogs(parseInt(retentionDays));\n    \n    res.json({\n      message: 'Audit log cleanup completed',\n      result\n    });\n    \n  } catch (error) {\n    logger.error('Cleanup logs error:', error);\n    next(error);\n  }\n});\n\n// POST /monitoring/reset-metrics - Reset performance metrics\nrouter.post('/monitoring/reset-metrics', async (req, res, next) => {\n  try {\n    const { performanceMonitor } = req.app.locals;\n    \n    if (!performanceMonitor) {\n      return res.status(503).json({\n        error: {\n          code: 'PERFORMANCE_MONITOR_UNAVAILABLE',\n          message: 'Performance monitoring is not enabled'\n        }\n      });\n    }\n    \n    performanceMonitor.resetMetrics();\n    \n    res.json({\n      message: 'Performance metrics reset successfully',\n      resetAt: new Date().toISOString()\n    });\n    \n  } catch (error) {\n    logger.error('Reset metrics error:', error);\n    next(error);\n  }\n});\n\nexport default router;","import express from 'express';\nimport path from 'node:path';\nimport { promises as fs } from 'node:fs';\nimport * as validators from '../validators.js';\nimport { NotFoundError, createErrorResponse } from '../errors.js';\nimport { createLogger } from '../logger.js';\n\nconst logger = createLogger('routes/executionFiles');\nconst router = express.Router();\n\n/**\n * GET /executions/:executionId/files - List files and folders in execution workspace\n */\nrouter.get('/executions/:executionId/files', async (req, res, next) => {\n  try {\n    const executionId = validators.validateExecutionId(req.params.executionId);\n    const { path: dirPath = '', recursive = false } = req.query;\n    const { db, workspaceManager } = req.app.locals;\n    \n    // Check if execution exists\n    const execution = await db.get(\n      'SELECT id, status FROM executions WHERE id = ?',\n      [executionId]\n    );\n    \n    if (!execution) {\n      throw new NotFoundError(`Execution not found: ${executionId}`);\n    }\n    \n    // Build execution workspace path\n    const workspacePath = path.join(\n      workspaceManager.getWorkspacePath(),\n      '.execution',\n      `exec-${executionId}`\n    );\n    \n    // Check if workspace exists\n    try {\n      await fs.access(workspacePath);\n    } catch (error) {\n      return res.status(404).json({\n        error: {\n          code: 'WORKSPACE_NOT_FOUND',\n          message: 'Execution workspace not found'\n        }\n      });\n    }\n    \n    // Build full path\n    const fullPath = path.join(workspacePath, dirPath);\n    \n    // Ensure path is within workspace (prevent directory traversal)\n    if (!fullPath.startsWith(workspacePath)) {\n      return res.status(400).json({\n        error: {\n          code: 'INVALID_PATH',\n          message: 'Invalid path'\n        }\n      });\n    }\n    \n    try {\n      const stats = await fs.stat(fullPath);\n      \n      if (!stats.isDirectory()) {\n        return res.status(400).json({\n          error: {\n            code: 'NOT_A_DIRECTORY',\n            message: 'Path is not a directory'\n          }\n        });\n      }\n      \n      if (recursive === 'true' || recursive === true) {\n        // Recursive listing\n        const files = await listFilesRecursive(fullPath, workspacePath);\n        res.json({ files });\n      } else {\n        // Single-level listing with metadata\n        const entries = await listDirectory(fullPath, workspacePath);\n        res.json({ entries });\n      }\n      \n    } catch (error) {\n      if (error.code === 'ENOENT') {\n        return res.status(404).json({\n          error: {\n            code: 'PATH_NOT_FOUND',\n            message: 'Path not found in workspace'\n          }\n        });\n      }\n      throw error;\n    }\n    \n  } catch (error) {\n    if (error.name === 'ValidationError') {\n      return res.status(400).json(createErrorResponse(error));\n    }\n    if (error.name === 'NotFoundError') {\n      return res.status(404).json(createErrorResponse(error));\n    }\n    next(error);\n  }\n});\n\n/**\n * GET /executions/:executionId/file - Read file content from execution workspace\n */\nrouter.get('/executions/:executionId/file', async (req, res, next) => {\n  try {\n    const executionId = validators.validateExecutionId(req.params.executionId);\n    const { path: filePath } = req.query;\n    const { db, workspaceManager } = req.app.locals;\n    \n    if (!filePath) {\n      return res.status(400).json({\n        error: {\n          code: 'MISSING_PATH',\n          message: 'File path is required'\n        }\n      });\n    }\n    \n    // Check if execution exists\n    const execution = await db.get(\n      'SELECT id, status FROM executions WHERE id = ?',\n      [executionId]\n    );\n    \n    if (!execution) {\n      throw new NotFoundError(`Execution not found: ${executionId}`);\n    }\n    \n    // Build execution workspace path\n    const workspacePath = path.join(\n      workspaceManager.getWorkspacePath(),\n      '.execution',\n      `exec-${executionId}`\n    );\n    \n    // Check if workspace exists\n    try {\n      await fs.access(workspacePath);\n    } catch (error) {\n      return res.status(404).json({\n        error: {\n          code: 'WORKSPACE_NOT_FOUND',\n          message: 'Execution workspace not found'\n        }\n      });\n    }\n    \n    // Build full path\n    const fullPath = path.join(workspacePath, filePath);\n    \n    // Ensure path is within workspace (prevent directory traversal)\n    if (!fullPath.startsWith(workspacePath)) {\n      return res.status(400).json({\n        error: {\n          code: 'INVALID_PATH',\n          message: 'Invalid path'\n        }\n      });\n    }\n    \n    try {\n      const stats = await fs.stat(fullPath);\n      \n      if (!stats.isFile()) {\n        return res.status(400).json({\n          error: {\n            code: 'NOT_A_FILE',\n            message: 'Path is not a file'\n          }\n        });\n      }\n      \n      // Check file size\n      const maxSize = 10 * 1024 * 1024; // 10MB\n      if (stats.size > maxSize) {\n        return res.status(400).json({\n          error: {\n            code: 'FILE_TOO_LARGE',\n            message: `File too large (max ${maxSize} bytes)`\n          }\n        });\n      }\n      \n      // Read file content\n      const content = await fs.readFile(fullPath, 'utf8');\n      \n      res.json({\n        path: path.relative(workspacePath, fullPath),\n        size: stats.size,\n        modified: stats.mtime,\n        content\n      });\n      \n    } catch (error) {\n      if (error.code === 'ENOENT') {\n        return res.status(404).json({\n          error: {\n            code: 'FILE_NOT_FOUND',\n            message: 'File not found in workspace'\n          }\n        });\n      }\n      if (error.code === 'EISDIR') {\n        return res.status(400).json({\n          error: {\n            code: 'IS_DIRECTORY',\n            message: 'Path is a directory, not a file'\n          }\n        });\n      }\n      throw error;\n    }\n    \n  } catch (error) {\n    if (error.name === 'ValidationError') {\n      return res.status(400).json(createErrorResponse(error));\n    }\n    if (error.name === 'NotFoundError') {\n      return res.status(404).json(createErrorResponse(error));\n    }\n    next(error);\n  }\n});\n\n/**\n * Helper function to list directory contents\n */\nasync function listDirectory(dirPath, basePath) {\n  const entries = [];\n  const items = await fs.readdir(dirPath, { withFileTypes: true });\n  \n  for (const item of items) {\n    const itemPath = path.join(dirPath, item.name);\n    const relativePath = path.relative(basePath, itemPath);\n    const stats = await fs.stat(itemPath);\n    \n    entries.push({\n      name: item.name,\n      path: relativePath,\n      type: item.isDirectory() ? 'directory' : 'file',\n      size: stats.size,\n      modified: stats.mtime\n    });\n  }\n  \n  // Sort directories first, then files\n  entries.sort((a, b) => {\n    if (a.type === b.type) {\n      return a.name.localeCompare(b.name);\n    }\n    return a.type === 'directory' ? -1 : 1;\n  });\n  \n  return entries;\n}\n\n/**\n * Helper function to recursively list files\n */\nasync function listFilesRecursive(dirPath, basePath, files = []) {\n  const items = await fs.readdir(dirPath, { withFileTypes: true });\n  \n  for (const item of items) {\n    const itemPath = path.join(dirPath, item.name);\n    const relativePath = path.relative(basePath, itemPath);\n    \n    if (item.isDirectory()) {\n      await listFilesRecursive(itemPath, basePath, files);\n    } else {\n      files.push(relativePath);\n    }\n  }\n  \n  return files;\n}\n\nexport default router;","import { app as electronApp } from 'electron'\nimport path from 'node:path'\nimport { EventEmitter } from 'node:events'\nimport { fileURLToPath } from 'node:url'\n\n// Import server modules directly as TypeScript\nimport express from 'express'\nimport cors from 'cors'\nimport { Database } from './server/db.js'\nimport { createLogger } from './server/logger.js'\nimport { config } from './server/config.js'\nimport { Events } from './server/constants.js'\nimport WorkspaceManager from './server/services/WorkspaceManager.js'\nimport ProcessManager from './server/processManager.js'\nimport StreamHandler from './server/streamHandler.js'\nimport IntegrationManager from './server/services/IntegrationManager.js'\nimport RefManager from './server/services/RefManager.js'\nimport ResourceMonitor from './server/services/ResourceMonitor.js'\nimport AuditLogger from './server/services/AuditLogger.js'\nimport PerformanceMonitor from './server/services/PerformanceMonitor.js'\nimport ClaudeSDKManager from './server/claudeSDKManager.js'\nimport PreviewManager from './server/preview/previewManager.js'\n\n// Import routes\nimport executeRoutes from './server/routes/execute.js'\nimport statusRoutes from './server/routes/status.js'\nimport messageRoutes from './server/routes/message.js'\nimport logsRoutes from './server/routes/logs.js'\nimport filesRoutes from './server/routes/files.js'\nimport previewRoutes from './server/routes/preview.js'\nimport refsRoutes from './server/routes/refs.js'\nimport refPreviewRoutes from './server/routes/refPreview.js'\nimport cleanupRoutes from './server/routes/cleanup.js'\nimport resourcesRoutes from './server/routes/resources.js'\nimport monitoringRoutes from './server/routes/monitoring.js'\nimport executionFilesRoutes from './server/routes/executionFiles.js'\n\nconst __dirname = path.dirname(fileURLToPath(import.meta.url))\n\nexport interface ServerOptions {\n  port?: number\n  workspace?: string\n}\n\nexport class IntentServer {\n  private server: any\n  private db: Database | null = null\n  private eventEmitter: EventEmitter\n  private isRunning: boolean = false\n  private port: number\n\n  constructor(options: ServerOptions = {}) {\n    this.port = options.port || 3000\n    this.eventEmitter = new EventEmitter()\n  }\n\n  async start(): Promise<void> {\n    if (this.isRunning) {\n      console.log('Intent server is already running')\n      return\n    }\n\n    try {\n      const logger = createLogger('serverIntegration')\n\n      // Create Express app\n      const app = express()\n\n      // Middleware\n      app.use(express.json())\n      app.use(cors({\n        origin: ['http://localhost:5173', 'http://localhost:3001'], // Allow Vite dev server and React app\n        credentials: true\n      }))\n\n      // Request logging middleware\n      app.use((req: any, res: any, next: any) => {\n        console.log(`${new Date().toISOString()} ${req.method} ${req.path}`)\n        next()\n      })\n\n      // Health check endpoint\n      app.get('/health', (req: any, res: any) => {\n        res.json({ \n          status: 'ok', \n          timestamp: new Date().toISOString(),\n          version: '1.0.0',\n          electron: true\n        })\n      })\n\n      // Use Electron's userData directory for workspace\n      const userDataPath = electronApp.getPath('userData')\n      const workspacePath = path.join(userDataPath, 'intent-workspace')\n\n      // Initialize services\n\n      // Initialize workspace\n      const workspaceManager = new WorkspaceManager(workspacePath)\n      const workspace = await workspaceManager.initialize()\n      \n      // Store workspace paths globally for use in endpoints\n      app.locals.workspace = workspace\n      app.locals.workspaceManager = workspaceManager\n      \n      // Initialize database with workspace-specific path\n      const dbPath = path.join(workspace.dataDir, 'agent-wrapper.db')\n      this.db = new Database(dbPath)\n      await this.db.initialize()\n      \n      // Make db and eventEmitter available to routes\n      app.locals.db = this.db\n      app.locals.eventEmitter = this.eventEmitter\n      app.locals.config = config\n      \n      // Initialize managers\n      app.locals.processManager = new ProcessManager(this.db, config, this.eventEmitter)\n      app.locals.streamHandler = new StreamHandler(this.db, this.eventEmitter)\n      \n      // Initialize audit logger\n      app.locals.auditLogger = new AuditLogger(this.db)\n      \n      // Initialize performance monitor with audit logger\n      app.locals.performanceMonitor = new PerformanceMonitor(app.locals.auditLogger)\n      \n      // Initialize integration manager with instrumented ref manager\n      const refManager = new RefManager(workspace.workspace, app.locals.performanceMonitor)\n      app.locals.integrationManager = new IntegrationManager(workspaceManager, refManager, null, null, this.db)\n      \n      // Initialize resource monitor\n      app.locals.resourceMonitor = new ResourceMonitor(workspaceManager, this.db, {\n        maxConcurrentExecutions: process.env.MAX_CONCURRENT_EXECUTIONS || 100,\n        maxDiskUsageMB: process.env.MAX_DISK_USAGE_MB || 10000,\n        maxExecutionTimeMinutes: process.env.MAX_EXECUTION_TIME_MINUTES || 60,\n        checkInterval: process.env.RESOURCE_CHECK_INTERVAL || 300000 // 5 minutes\n      })\n      \n      // Start resource monitoring\n      app.locals.resourceMonitor.start()\n\n      // Set up routes\n\n      app.use('/', executeRoutes)\n      app.use('/', statusRoutes)\n      app.use('/', messageRoutes)\n      app.use('/', logsRoutes)\n      app.use('/', filesRoutes)\n      app.use('/preview', previewRoutes)\n      app.use('/', refsRoutes)\n      app.use('/', refPreviewRoutes)\n      app.use('/', cleanupRoutes)\n      app.use('/', resourcesRoutes)\n      app.use('/', monitoringRoutes)\n      app.use('/', executionFilesRoutes)\n\n      // Error handling middleware\n      app.use((err: any, req: any, res: any, next: any) => {\n        console.error('Error:', err)\n        \n        // Handle different error types\n        if (err.name === 'ValidationError') {\n          return res.status(400).json({\n            error: {\n              code: 'VALIDATION_ERROR',\n              message: err.message,\n              details: err.details || {}\n            }\n          })\n        }\n        \n        if (err.name === 'NotFoundError') {\n          return res.status(404).json({\n            error: {\n              code: 'NOT_FOUND',\n              message: err.message\n            }\n          })\n        }\n        \n        // Default to 500 internal server error\n        res.status(500).json({\n          error: {\n            code: 'INTERNAL_ERROR',\n            message: 'An unexpected error occurred',\n            details: process.env.NODE_ENV === 'development' ? err.message : undefined\n          }\n        })\n      })\n\n      // 404 handler\n      app.use((req: any, res: any) => {\n        res.status(404).json({\n          error: {\n            code: 'ENDPOINT_NOT_FOUND',\n            message: `Endpoint ${req.method} ${req.path} not found`\n          }\n        })\n      })\n\n      // Start server\n      this.server = app.listen(this.port, () => {\n        logger.info(`Intent server running on port ${this.port}`)\n        logger.info(`Workspace: ${workspace.workspace}`)\n        this.isRunning = true\n      })\n\n      // Initialize Claude SDK Manager\n      app.locals.claudeSDKManager = new ClaudeSDKManager(\n        this.db, \n        config, \n        this.eventEmitter,\n        workspaceManager\n      )\n\n      // Initialize Preview Manager\n      app.locals.previewManager = new PreviewManager(this.db, app.locals.processManager, this.eventEmitter)\n\n      // Listen for process exit events to trigger integration\n      this.eventEmitter.on(Events.PROCESS_EXIT, async ({ executionId, code }: any) => {\n        logger.info(`Process exited for execution ${executionId} with code ${code}`)\n        \n        // Only integrate on successful completion\n        if (code === 0) {\n          // Check if this execution has references\n          const refs = await this.db.all(\n            'SELECT DISTINCT ref_id FROM execution_refs WHERE execution_id = ?',\n            [executionId]\n          )\n          \n          if (refs.length > 0) {\n            logger.info(`Starting integration for execution ${executionId} with ${refs.length} references`)\n            \n            // Run integration asynchronously\n            setTimeout(async () => {\n              try {\n                const result = await app.locals.integrationManager.integrateExecutionChanges(executionId, {\n                  commitMessage: `Changes from execution ${executionId}`,\n                  merge: true,\n                  cleanup: false  // Keep execution workspace for message resume\n                })\n                \n                if (result.success) {\n                  logger.info(`Integration completed successfully for execution ${executionId}`)\n                } else {\n                  logger.error(`Integration failed for execution ${executionId}:`, result.error)\n                }\n              } catch (error) {\n                logger.error(`Integration error for execution ${executionId}:`, error)\n              }\n            }, 1000) // Small delay to ensure all logs are flushed\n          }\n        }\n      })\n\n    } catch (error) {\n      console.error('Failed to start Intent server:', error)\n      throw error\n    }\n  }\n\n  async stop(): Promise<void> {\n    if (!this.isRunning) {\n      return\n    }\n\n    const logger = createLogger('serverIntegration')\n    \n    logger.info('Shutting down Intent server...')\n    \n    if (this.server) {\n      await new Promise<void>((resolve) => {\n        this.server.close(() => {\n          logger.info('HTTP server closed')\n          resolve()\n        })\n      })\n    }\n    \n    if (this.db) {\n      await this.db.close()\n    }\n    \n    this.isRunning = false\n  }\n\n  getPort(): number {\n    return this.port\n  }\n\n  isServerRunning(): boolean {\n    return this.isRunning\n  }\n}","import { app, BrowserWindow, shell, ipcMain } from 'electron'\nimport { createRequire } from 'node:module'\nimport { fileURLToPath } from 'node:url'\nimport path from 'node:path'\nimport os from 'node:os'\nimport { exec } from 'node:child_process'\nimport { promisify } from 'node:util'\nimport { update } from './update'\nimport { IntentServer } from './serverIntegration'\n\nconst require = createRequire(import.meta.url)\nconst __dirname = path.dirname(fileURLToPath(import.meta.url))\n\n// The built directory structure\n//\n//  dist-electron\n//   main\n//    index.js    > Electron-Main\n//   preload\n//     index.mjs   > Preload-Scripts\n//  dist\n//   index.html    > Electron-Renderer\n//\nprocess.env.APP_ROOT = path.join(__dirname, '../..')\n\nexport const MAIN_DIST = path.join(process.env.APP_ROOT, 'dist-electron')\nexport const RENDERER_DIST = path.join(process.env.APP_ROOT, 'dist')\nexport const VITE_DEV_SERVER_URL = process.env.VITE_DEV_SERVER_URL\n\nprocess.env.VITE_PUBLIC = VITE_DEV_SERVER_URL\n  ? path.join(process.env.APP_ROOT, 'public')\n  : RENDERER_DIST\n\n// Disable GPU Acceleration for Windows 7\nif (os.release().startsWith('6.1')) app.disableHardwareAcceleration()\n\n// Set application name for Windows 10+ notifications\nif (process.platform === 'win32') app.setAppUserModelId(app.getName())\n\nif (!app.requestSingleInstanceLock()) {\n  app.quit()\n  process.exit(0)\n}\n\nlet win: BrowserWindow | null = null\nconst preload = path.join(__dirname, '../preload/index.mjs')\nconst indexHtml = path.join(RENDERER_DIST, 'index.html')\n\n// Initialize Intent server\nlet intentServer: IntentServer | null = null\n\nasync function createWindow() {\n  win = new BrowserWindow({\n    title: 'Main window',\n    icon: path.join(process.env.VITE_PUBLIC, 'favicon.ico'),\n    width: 1440,\n    height: 810,\n    webPreferences: {\n      preload,\n      // Warning: Enable nodeIntegration and disable contextIsolation is not secure in production\n      // nodeIntegration: true,\n\n      // Consider using contextBridge.exposeInMainWorld\n      // Read more on https://www.electronjs.org/docs/latest/tutorial/context-isolation\n      // contextIsolation: false,\n    },\n  })\n\n  if (VITE_DEV_SERVER_URL) { // #298\n    win.loadURL(VITE_DEV_SERVER_URL)\n    // Open devTool if the app is not packaged\n    // win.webContents.openDevTools()\n  } else {\n    win.loadFile(indexHtml)\n  }\n\n  // Test actively push message to the Electron-Renderer\n  win.webContents.on('did-finish-load', () => {\n    win?.webContents.send('main-process-message', new Date().toLocaleString())\n  })\n\n  // Make all links open with the browser, not with the application\n  win.webContents.setWindowOpenHandler(({ url }) => {\n    if (url.startsWith('https:')) shell.openExternal(url)\n    return { action: 'deny' }\n  })\n\n  // Auto update\n  update(win)\n}\n\napp.whenReady().then(async () => {\n  // Check for Git installation\n  try {\n    const { stdout } = await execAsync('git --version')\n    console.log('Git is installed:', stdout.trim())\n  } catch (error) {\n    console.warn('Git is not installed. Some features may not work properly.')\n    // We'll handle the installation prompt in the renderer process\n  }\n  \n  // Start Intent server first\n  try {\n    intentServer = new IntentServer({ port: 3456 })\n    await intentServer.start()\n    console.log('Intent server started successfully on port 3456')\n  } catch (error) {\n    console.error('Failed to start Intent server:', error)\n  }\n  \n  // Then create the window\n  createWindow()\n})\n\napp.on('window-all-closed', async () => {\n  win = null\n  \n  // Stop Intent server\n  if (intentServer) {\n    try {\n      await intentServer.stop()\n      console.log('Intent server stopped')\n    } catch (error) {\n      console.error('Error stopping Intent server:', error)\n    }\n  }\n  \n  if (process.platform !== 'darwin') app.quit()\n})\n\napp.on('second-instance', () => {\n  if (win) {\n    // Focus on the main window if the user tried to open another\n    if (win.isMinimized()) win.restore()\n    win.focus()\n  }\n})\n\napp.on('activate', () => {\n  const allWindows = BrowserWindow.getAllWindows()\n  if (allWindows.length) {\n    allWindows[0].focus()\n  } else {\n    createWindow()\n  }\n})\n\n// New window example arg: new windows url\nipcMain.handle('open-win', (_, arg) => {\n  const childWindow = new BrowserWindow({\n    webPreferences: {\n      preload,\n      nodeIntegration: true,\n      contextIsolation: false,\n    },\n  })\n\n  if (VITE_DEV_SERVER_URL) {\n    childWindow.loadURL(`${VITE_DEV_SERVER_URL}#${arg}`)\n  } else {\n    childWindow.loadFile(indexHtml, { hash: arg })\n  }\n})\n\n// Intent server status handler\nipcMain.handle('intent-server:status', () => {\n  return {\n    running: intentServer?.isServerRunning() || false,\n    port: intentServer?.getPort() || null\n  }\n})\n\n// File operation handlers\nipcMain.handle('intent:get-workspace-path', () => {\n  const userDataPath = app.getPath('userData')\n  return path.join(userDataPath, 'intent-workspace', 'refs')\n})\n\nipcMain.handle('intent:list-files', async (event, dirPath) => {\n  const { promises: fs } = await import('node:fs')\n  const userDataPath = app.getPath('userData')\n  const workspacePath = path.join(userDataPath, 'intent-workspace')\n  \n  // Ensure path is within workspace for security\n  const fullPath = path.join(workspacePath, dirPath)\n  if (!fullPath.startsWith(workspacePath)) {\n    throw new Error('Access denied: Path outside workspace')\n  }\n  \n  try {\n    const items = await fs.readdir(fullPath, { withFileTypes: true })\n    return items.map(item => ({\n      name: item.name,\n      path: path.join(dirPath, item.name),\n      type: item.isDirectory() ? 'directory' : 'file'\n    }))\n  } catch (error) {\n    console.error('Error listing files:', error)\n    return []\n  }\n})\n\nipcMain.handle('intent:read-file', async (event, filePath) => {\n  const { promises: fs } = await import('node:fs')\n  const userDataPath = app.getPath('userData')\n  const workspacePath = path.join(userDataPath, 'intent-workspace')\n  \n  const fullPath = path.join(workspacePath, filePath)\n  if (!fullPath.startsWith(workspacePath)) {\n    throw new Error('Access denied: Path outside workspace')\n  }\n  \n  return fs.readFile(fullPath, 'utf-8')\n})\n\nipcMain.handle('intent:write-file', async (event, filePath, content) => {\n  const { promises: fs } = await import('node:fs')\n  const userDataPath = app.getPath('userData')\n  const workspacePath = path.join(userDataPath, 'intent-workspace')\n  \n  const fullPath = path.join(workspacePath, filePath)\n  if (!fullPath.startsWith(workspacePath)) {\n    throw new Error('Access denied: Path outside workspace')\n  }\n  \n  await fs.writeFile(fullPath, content, 'utf-8')\n  return true\n})\n\nipcMain.handle('intent:create-file', async (event, filePath, content = '') => {\n  const { promises: fs } = await import('node:fs')\n  const userDataPath = app.getPath('userData')\n  const workspacePath = path.join(userDataPath, 'intent-workspace')\n  \n  const fullPath = path.join(workspacePath, filePath)\n  if (!fullPath.startsWith(workspacePath)) {\n    throw new Error('Access denied: Path outside workspace')\n  }\n  \n  // Ensure directory exists\n  await fs.mkdir(path.dirname(fullPath), { recursive: true })\n  await fs.writeFile(fullPath, content, 'utf-8')\n  return true\n})\n\nipcMain.handle('intent:delete-file', async (event, filePath) => {\n  const { promises: fs } = await import('node:fs')\n  const userDataPath = app.getPath('userData')\n  const workspacePath = path.join(userDataPath, 'intent-workspace')\n  \n  const fullPath = path.join(workspacePath, filePath)\n  if (!fullPath.startsWith(workspacePath)) {\n    throw new Error('Access denied: Path outside workspace')\n  }\n  \n  // Check if it's a directory\n  const stat = await fs.stat(fullPath)\n  if (stat.isDirectory()) {\n    await fs.rm(fullPath, { recursive: true, force: true })\n  } else {\n    await fs.unlink(fullPath)\n  }\n  return true\n})\n\nipcMain.handle('intent:create-directory', async (event, dirPath) => {\n  const { promises: fs } = await import('node:fs')\n  const userDataPath = app.getPath('userData')\n  const workspacePath = path.join(userDataPath, 'intent-workspace')\n  \n  const fullPath = path.join(workspacePath, dirPath)\n  if (!fullPath.startsWith(workspacePath)) {\n    throw new Error('Access denied: Path outside workspace')\n  }\n  \n  await fs.mkdir(fullPath, { recursive: true })\n  return true\n})\n\nipcMain.handle('intent:rename-file', async (event, oldPath, newPath) => {\n  const { promises: fs } = await import('node:fs')\n  const userDataPath = app.getPath('userData')\n  const workspacePath = path.join(userDataPath, 'intent-workspace')\n  \n  const fullOldPath = path.join(workspacePath, oldPath)\n  const fullNewPath = path.join(workspacePath, newPath)\n  \n  if (!fullOldPath.startsWith(workspacePath) || !fullNewPath.startsWith(workspacePath)) {\n    throw new Error('Access denied: Path outside workspace')\n  }\n  \n  await fs.rename(fullOldPath, fullNewPath)\n  return true\n})\n\n// Project management handlers\nipcMain.handle('intent:scan-refs', async () => {\n  const { promises: fs } = await import('node:fs')\n  const userDataPath = app.getPath('userData')\n  const refsPath = path.join(userDataPath, 'intent-workspace', 'refs')\n  \n  try {\n    const items = await fs.readdir(refsPath, { withFileTypes: true })\n    const refs = items\n      .filter(item => item.isDirectory())\n      .map(item => ({\n        id: item.name,\n        name: item.name,\n        path: path.join('refs', item.name)\n      }))\n    return refs\n  } catch (error) {\n    console.error('Error scanning refs:', error)\n    return []\n  }\n})\n\nipcMain.handle('intent:check-metadata-exists', async (event, filePath) => {\n  const { promises: fs } = await import('node:fs')\n  const userDataPath = app.getPath('userData')\n  const workspacePath = path.join(userDataPath, 'intent-workspace')\n  const fullPath = path.join(workspacePath, filePath)\n  \n  try {\n    await fs.access(fullPath)\n    return true\n  } catch {\n    return false\n  }\n})\n\nipcMain.handle('intent:copy-file', async (event, sourcePath, destPath) => {\n  const { promises: fs } = await import('node:fs')\n  const userDataPath = app.getPath('userData')\n  const workspacePath = path.join(userDataPath, 'intent-workspace')\n  \n  const fullDestPath = path.join(workspacePath, destPath)\n  if (!fullDestPath.startsWith(workspacePath)) {\n    throw new Error('Access denied: Destination path outside workspace')\n  }\n  \n  // Ensure destination directory exists\n  const destDir = path.dirname(fullDestPath)\n  await fs.mkdir(destDir, { recursive: true })\n  \n  // Copy the file\n  await fs.copyFile(sourcePath, fullDestPath)\n  return true\n})\n\nipcMain.handle('intent:write-file-buffer', async (event, filePath, buffer) => {\n  const { promises: fs } = await import('node:fs')\n  const userDataPath = app.getPath('userData')\n  const workspacePath = path.join(userDataPath, 'intent-workspace')\n  \n  const fullPath = path.join(workspacePath, filePath)\n  if (!fullPath.startsWith(workspacePath)) {\n    throw new Error('Access denied: Path outside workspace')\n  }\n  \n  // Ensure directory exists\n  const dir = path.dirname(fullPath)\n  await fs.mkdir(dir, { recursive: true })\n  \n  // Write the buffer to file\n  await fs.writeFile(fullPath, Buffer.from(buffer))\n  return true\n})\n\nipcMain.handle('intent:get-file-url', async (event, filePath) => {\n  const { promises: fs } = await import('node:fs')\n  const userDataPath = app.getPath('userData')\n  const workspacePath = path.join(userDataPath, 'intent-workspace')\n  \n  const fullPath = path.join(workspacePath, filePath)\n  if (!fullPath.startsWith(workspacePath)) {\n    throw new Error('Access denied: Path outside workspace')\n  }\n  \n  // Read file and return as data URL\n  const buffer = await fs.readFile(fullPath)\n  const ext = path.extname(filePath).toLowerCase().slice(1)\n  \n  // Determine MIME type\n  let mimeType = 'application/octet-stream'\n  const mimeTypes: Record<string, string> = {\n    // Images\n    jpg: 'image/jpeg',\n    jpeg: 'image/jpeg',\n    png: 'image/png',\n    gif: 'image/gif',\n    bmp: 'image/bmp',\n    svg: 'image/svg+xml',\n    webp: 'image/webp',\n    ico: 'image/x-icon',\n    // Videos\n    mp4: 'video/mp4',\n    webm: 'video/webm',\n    ogg: 'video/ogg',\n    mov: 'video/quicktime',\n    avi: 'video/x-msvideo',\n    wmv: 'video/x-ms-wmv',\n    flv: 'video/x-flv',\n    mkv: 'video/x-matroska',\n    // Audio\n    mp3: 'audio/mpeg',\n    wav: 'audio/wav',\n    flac: 'audio/flac',\n    aac: 'audio/aac',\n    ogg: 'audio/ogg',\n    wma: 'audio/x-ms-wma',\n    m4a: 'audio/mp4'\n  }\n  \n  if (ext in mimeTypes) {\n    mimeType = mimeTypes[ext]\n  }\n  \n  // Return data URL\n  return `data:${mimeType};base64,${buffer.toString('base64')}`\n})\n\n// Git-related handlers\nconst execAsync = promisify(exec)\n\n// Check if Git is installed\nipcMain.handle('intent:check-git', async () => {\n  try {\n    const { stdout } = await execAsync('git --version')\n    return { installed: true, version: stdout.trim() }\n  } catch (error) {\n    return { installed: false }\n  }\n})\n\n// Initialize Git repository\nipcMain.handle('intent:init-git', async (event, refPath) => {\n  const userDataPath = app.getPath('userData')\n  const workspacePath = path.join(userDataPath, 'intent-workspace')\n  const fullPath = path.join(workspacePath, refPath)\n  \n  if (!fullPath.startsWith(workspacePath)) {\n    throw new Error('Access denied: Path outside workspace')\n  }\n  \n  try {\n    // Initialize git repo\n    await execAsync('git init', { cwd: fullPath })\n    \n    // Create .gitignore\n    const gitignoreContent = `# Intent Worker\n.DS_Store\nnode_modules/\n*.log\n.env\n.env.local\n`\n    const { promises: fs } = await import('node:fs')\n    await fs.writeFile(path.join(fullPath, '.gitignore'), gitignoreContent)\n    \n    // Initial commit\n    await execAsync('git add .', { cwd: fullPath })\n    await execAsync('git commit -m \"Initial commit\"', { cwd: fullPath })\n    \n    return { success: true }\n  } catch (error) {\n    console.error('Git init error:', error)\n    return { success: false, error: error.message }\n  }\n})\n\n// Create Next.js app\nipcMain.handle('intent:create-next-app', async (event, refPath) => {\n  const userDataPath = app.getPath('userData')\n  const workspacePath = path.join(userDataPath, 'intent-workspace')\n  const fullPath = path.join(workspacePath, refPath)\n  \n  if (!fullPath.startsWith(workspacePath)) {\n    throw new Error('Access denied: Path outside workspace')\n  }\n  \n  try {\n    console.log(`[Main] Running create-next-app in ${fullPath}`)\n    \n    const { spawn } = await import('node:child_process')\n    \n    return new Promise((resolve, reject) => {\n      const createNextProcess = spawn('npx', [\n        'create-next-app@latest',\n        '.',\n        '--ts',\n        '--tailwind',\n        '--eslint',\n        '--app',\n        '--use-npm',\n        '--import-alias', '@/*',\n        '--src-dir',\n        '--turbopack',\n        '--example', 'https://github.com/resonancelabsai/intent-01-app-starter'\n      ], {\n        cwd: fullPath,\n        stdio: 'pipe',\n        shell: true\n      })\n      \n      let output = ''\n      \n      createNextProcess.stdout.on('data', (data) => {\n        output += data.toString()\n        console.log(`[create-next-app] ${data.toString().trim()}`)\n      })\n      \n      createNextProcess.stderr.on('data', (data) => {\n        output += data.toString()\n        console.log(`[create-next-app stderr] ${data.toString().trim()}`)\n      })\n      \n      createNextProcess.on('close', (code) => {\n        if (code === 0) {\n          console.log(`[Main] create-next-app completed successfully`)\n          resolve({ success: true })\n        } else {\n          reject(new Error(`create-next-app failed with code ${code}: ${output}`))\n        }\n      })\n      \n      createNextProcess.on('error', (error) => {\n        reject(new Error(`Failed to run create-next-app: ${error.message}`))\n      })\n    })\n  } catch (error) {\n    console.error('create-next-app error:', error)\n    return { success: false, error: error.message }\n  }\n})\n\n// Install Git if not present (macOS/Windows)\nipcMain.handle('intent:install-git', async () => {\n  const platform = os.platform()\n  \n  try {\n    if (platform === 'darwin') {\n      // On macOS, try to trigger Xcode command line tools installation\n      // This will prompt the user to install if not present\n      await execAsync('xcode-select --install')\n      return { success: true, message: 'Git installation initiated. Please follow the system prompts.' }\n    } else if (platform === 'win32') {\n      // On Windows, open the Git download page\n      shell.openExternal('https://git-scm.com/download/win')\n      return { success: true, message: 'Please download and install Git from the opened webpage.' }\n    } else {\n      // On Linux, provide package manager commands\n      return { \n        success: false, \n        message: 'Please install Git using your package manager:\\n' +\n                 'Ubuntu/Debian: sudo apt-get install git\\n' +\n                 'Fedora: sudo dnf install git\\n' +\n                 'Arch: sudo pacman -S git'\n      }\n    }\n  } catch (error) {\n    return { success: false, error: error.message }\n  }\n})\n"],"names":["win","logger","fs","path","config","process","execAsync","refManager","previewManager","promisify","uuidv4","query","router","validators.validateAgent","validators.validatePrompt","validators.validateWorkingDir","validators.ValidationError","validators.validateExecutionId","validators.validateMessage","eventEmitter","workspaceManager","workspacePath","childProcess","streamHandler","exec","preview","code","app","electronApp","executeRoutes","statusRoutes","messageRoutes","logsRoutes","filesRoutes","previewRoutes","refsRoutes","refPreviewRoutes","cleanupRoutes","resourcesRoutes","monitoringRoutes","executionFilesRoutes","spawn"],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAQA,MAAM,EAAE,YAAA,IAAgB,cAAc,YAAY,GAAG,EAAE,kBAAkB;AAElE,SAAS,OAAOA,MAA6B;AAGlD,cAAY,eAAe;AAC3B,cAAY,sBAAsB;AAClC,cAAY,iBAAiB;AAG7B,cAAY,GAAG,uBAAuB,WAAY;AAAA,EAAE,CAAC;AAErD,cAAY,GAAG,oBAAoB,CAAC,QAAoB;AACtD,IAAAA,KAAI,YAAY,KAAK,wBAAwB,EAAE,QAAQ,MAAM,SAAS,IAAI,WAAA,GAAc,YAAY,2BAAK,SAAS;AAAA,EACpH,CAAC;AAED,cAAY,GAAG,wBAAwB,CAAC,QAAoB;AAC1D,IAAAA,KAAI,YAAY,KAAK,wBAAwB,EAAE,QAAQ,OAAO,SAAS,IAAI,WAAA,GAAc,YAAY,2BAAK,SAAS;AAAA,EACrH,CAAC;AAGD,UAAQ,OAAO,gBAAgB,YAAY;AACzC,QAAI,CAAC,IAAI,YAAY;AACnB,YAAM,QAAQ,IAAI,MAAM,yDAAyD;AACjF,aAAO,EAAE,SAAS,MAAM,SAAS,MAAA;AAAA,IACnC;AAEA,QAAI;AACF,aAAO,MAAM,YAAY,yBAAA;AAAA,IAC3B,SAAS,OAAO;AACd,aAAO,EAAE,SAAS,iBAAiB,MAAA;AAAA,IACrC;AAAA,EACF,CAAC;AAGD,UAAQ,OAAO,kBAAkB,CAAC,UAAuC;AACvE;AAAA,MACE,CAAC,OAAO,iBAAiB;AACvB,YAAI,OAAO;AAET,gBAAM,OAAO,KAAK,gBAAgB,EAAE,SAAS,MAAM,SAAS,OAAO;AAAA,QACrE,OAAO;AAEL,gBAAM,OAAO,KAAK,qBAAqB,YAAY;AAAA,QACrD;AAAA,MACF;AAAA,MACA,MAAM;AAEJ,cAAM,OAAO,KAAK,mBAAmB;AAAA,MACvC;AAAA,IAAA;AAAA,EAEJ,CAAC;AAGD,UAAQ,OAAO,oBAAoB,MAAM;AACvC,gBAAY,eAAe,OAAO,IAAI;AAAA,EACxC,CAAC;AACH;AAEA,SAAS,cACP,UACA,UACA;AACA,cAAY,GAAG,qBAAqB,CAAC,SAAuB,SAAS,MAAM,IAAI,CAAC;AAChF,cAAY,GAAG,SAAS,CAAC,UAAiB,SAAS,OAAO,IAAI,CAAC;AAC/D,cAAY,GAAG,qBAAqB,QAAQ;AAC5C,cAAY,eAAA;AACd;ACvEA,IAAI;AACF,SAAO,OAAA;AACT,SAAS,KAAK;AAEd;AAsDO,MAAM,SAAiB;AAAA,EAC5B,QAAQ;AAAA,IACN,MAAM,SAAS,QAAA,IAAY,QAAQ,MAAM;AAAA,IACzC,aAAa,QAAA,IAAY,eACrB,QAAA,IAAY,aAAa,MAAM,GAAG,IAClC,CAAC,yBAAyB,yBAAyB,yBAAyB,uBAAuB,yBAAyB;AAAA,EAAA;AAAA,EAElI,WAAW;AAAA;AAAA,IAET,MAAM,YAAY,iBAAiB;AAAA;AAAA,IAEnC,YAAY,QAAA,IAAY,0BAA0B,SAC9C,SAAS,QAAA,IAAY,qBAAqB,IAC1C;AAAA;AAAA,IAEJ,eAAe,QAAA,IAAY,6BAA6B,SACpD,SAAS,QAAA,IAAY,wBAAwB,IAC7C;AAAA,EAAA;AAAA,EAEN,UAAU;AAAA;AAAA;AAAA,IAGR,MAAM,YAAY,WAAW;AAAA,EAAA;AAAA,EAE/B,QAAQ;AAAA,IACN,QAAQ;AAAA,MACN,SAAS,YAAY,kBAAkB;AAAA,MACvC,aAAa;AAAA,QACX;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MAAA;AAAA,IACF;AAAA,IAEF,QAAQ;AAAA,MACN,SAAS,YAAY,kBAAkB;AAAA,MACvC,aAAa,CAAA;AAAA,IAAC;AAAA,EAChB;AAAA,EAEF,WAAW;AAAA,IACT,mBAAmB,QAAQ,IAAA;AAAA,IAC3B,yBAAyB,SAAS,QAAA,IAAY,6BAA6B,IAAI;AAAA,IAC/E,gBAAgB,SAAS,QAAA,IAAY,mBAAmB,GAAG;AAAA;AAAA,EAAA;AAAA,EAE7D,SAAS;AAAA,IACP,OAAO,YAAY,aAAa;AAAA,IAChC,cAAc,SAAS,QAAA,IAAY,kBAAkB,OAAO;AAAA,EAAA;AAAA,EAE9D,WAAW;AAAA,IACT,mBAAmB,SAAS,QAAA,IAAY,0BAA0B,OAAO;AAAA;AAAA,IACzE,eAAe,SAAS,QAAA,IAAY,mBAAmB,OAAO;AAAA;AAAA,EAAA;AAElE;AAGA,SAAS,iBAA0B;AACjC,MAAI,OAAO,OAAO,OAAO,KAAK,OAAO,OAAO,OAAO,OAAO;AACxD,UAAM,IAAI,MAAM,wBAAwB,OAAO,OAAO,IAAI,EAAE;AAAA,EAC9D;AAEA,MAAI,CAAC,CAAC,UAAU,QAAQ,EAAE,MAAM,CAAA,UAAS,OAAO,OAAO,KAAK,CAAC,GAAG;AAC9D,UAAM,IAAI,MAAM,6BAA6B;AAAA,EAC/C;AAEA,MAAI,OAAO,UAAU,0BAA0B,GAAG;AAChD,UAAM,IAAI,MAAM,4CAA4C;AAAA,EAC9D;AAEA,MAAI,OAAO,UAAU,aAAa,GAAG;AACnC,UAAM,IAAI,MAAM,2CAA2C;AAAA,EAC7D;AAEA,MAAI,OAAO,UAAU,gBAAgB,GAAG;AACtC,UAAM,IAAI,MAAM,4CAA4C;AAAA,EAC9D;AAEA,SAAO;AACT;AAGA,eAAA;AC5IA,MAAM,aAAa;AAAA,EACjB,OAAO;AAAA,EACP,MAAM;AAAA,EACN,MAAM;AAAA,EACN,OAAO;AACT;AAIO,MAAM,OAAO;AAAA,EAIlB,YAAY,MAAc;AAHlB;AACA;AAGN,SAAK,OAAO;AACZ,SAAK,QAAQ,WAAW,OAAO,QAAQ,KAAiB,KAAK,WAAW;AAAA,EAC1E;AAAA,EAEQ,cAAc,OAAiB,YAAoB,MAAqB;AAC9E,UAAM,aAAY,oBAAI,KAAA,GAAO,YAAA;AAC7B,UAAM,SAAS,IAAI,SAAS,MAAM,MAAM,YAAA,CAAa,MAAM,KAAK,IAAI;AAGpE,UAAM,gBAAgB,KAAK,IAAI,CAAA,QAAO;AACpC,UAAI,eAAe,OAAO;AACxB,eAAO,GAAG,IAAI,OAAO;AAAA,EAAK,IAAI,KAAK;AAAA,MACrC;AACA,UAAI,OAAO,QAAQ,UAAU;AAC3B,eAAO,KAAK,UAAU,KAAK,MAAM,CAAC;AAAA,MACpC;AACA,aAAO;AAAA,IACT,CAAC;AAED,WAAO,GAAG,MAAM,IAAI,OAAO,IAAI,cAAc,KAAK,GAAG,CAAC,GAAG,KAAA;AAAA,EAC3D;AAAA,EAEQ,IAAI,OAAiB,YAAoB,MAAmB;AAClE,QAAI,WAAW,KAAK,KAAK,KAAK,OAAO;AACnC,YAAM,YAAY,KAAK,cAAc,OAAO,SAAS,GAAG,IAAI;AAE5D,UAAI,UAAU,SAAS;AACrB,gBAAQ,MAAM,SAAS;AAAA,MACzB,WAAW,UAAU,QAAQ;AAC3B,gBAAQ,KAAK,SAAS;AAAA,MACxB,OAAO;AACL,gBAAQ,IAAI,SAAS;AAAA,MACvB;AAAA,IACF;AAAA,EACF;AAAA,EAEA,MAAM,YAAoB,MAAmB;AAC3C,SAAK,IAAI,SAAS,SAAS,GAAG,IAAI;AAAA,EACpC;AAAA,EAEA,KAAK,YAAoB,MAAmB;AAC1C,SAAK,IAAI,QAAQ,SAAS,GAAG,IAAI;AAAA,EACnC;AAAA,EAEA,KAAK,YAAoB,MAAmB;AAC1C,SAAK,IAAI,QAAQ,SAAS,GAAG,IAAI;AAAA,EACnC;AAAA,EAEA,MAAM,YAAoB,MAAmB;AAC3C,SAAK,IAAI,SAAS,SAAS,GAAG,IAAI;AAAA,EACpC;AACF;AAGO,SAAS,aAAa,MAAsB;AACjD,SAAO,IAAI,OAAO,IAAI;AACxB;ACnEA,MAAMC,WAAS,aAAa,UAAU;AAO/B,MAAM,SAAS;AAAA,EAIpB,YAAY,SAAiB,2BAA2B;AAHhD;AACA,8BAA8B;AAGpC,SAAK,SAAS;AAAA,EAChB;AAAA,EAEA,MAAM,UAAyB;AAC7B,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,YAAM,MAAM,KAAK,QAAQ,KAAK,MAAM;AACpC,UAAI,CAAC,GAAG,WAAW,GAAG,GAAG;AACvB,WAAG,UAAU,KAAK,EAAE,WAAW,MAAM;AAAA,MACvC;AAEA,YAAM,SAAS,QAAQ,QAAA;AACvB,WAAK,KAAK,IAAI,OAAO,SAAS,KAAK,QAAQ,CAAC,QAAQ;AAClD,YAAI,KAAK;AACP,iBAAO,GAAG;AAAA,QACZ,OAAO;AACLA,mBAAO,KAAK,8BAA8B;AAC1C,kBAAA;AAAA,QACF;AAAA,MACF,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AAAA,EAEA,MAAM,aAA4B;AAChC,UAAM,KAAK,QAAA;AACX,UAAM,KAAK,aAAA;AACX,UAAM,KAAK,cAAA;AAAA,EACb;AAAA,EAEA,MAAM,eAA8B;AAClC,UAAM,mBAAmB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA0BzB,UAAM,aAAa;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWnB,UAAM,uBAAuB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAe7B,UAAM,yBAAyB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAqB/B,UAAM,oBAAoB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAW1B,UAAM,wBAAwB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAU9B,UAAM,sBAAsB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAW5B,UAAM,mBAAmB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAezB,UAAM,sBAAsB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAa5B,UAAM,yBAAyB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAmB/B,UAAM,2BAA2B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAejC,UAAM,2BAA2B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAajC,UAAM,eAAe;AAAA,MACnB;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA;AAAA,MAEA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IAAA;AAGF,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,UAAI,CAAC,KAAK,IAAI;AACZ,eAAO,IAAI,MAAM,wBAAwB,CAAC;AAC1C;AAAA,MACF;AAEA,WAAK,GAAG,UAAU,MAAM;AACtB,aAAK,GAAI,IAAI,kBAAkB,CAAC,QAAQ;AACtC,cAAI,YAAY,GAAG;AAAA,QACrB,CAAC;AAED,aAAK,GAAI,IAAI,YAAY,CAAC,QAAQ;AAChC,cAAI,YAAY,GAAG;AAAA,QACrB,CAAC;AAED,aAAK,GAAI,IAAI,sBAAsB,CAAC,QAAQ;AAC1C,cAAI,YAAY,GAAG;AAAA,QACrB,CAAC;AAED,aAAK,GAAI,IAAI,wBAAwB,CAAC,QAAQ;AAC5C,cAAI,YAAY,GAAG;AAAA,QACrB,CAAC;AAED,aAAK,GAAI,IAAI,mBAAmB,CAAC,QAAQ;AACvC,cAAI,YAAY,GAAG;AAAA,QACrB,CAAC;AAED,aAAK,GAAI,IAAI,uBAAuB,CAAC,QAAQ;AAC3C,cAAI,YAAY,GAAG;AAAA,QACrB,CAAC;AAGD,aAAK,GAAI,IAAI,qBAAqB,CAAC,QAAQ;AACzC,cAAI,YAAY,GAAG;AAAA,QACrB,CAAC;AAED,aAAK,GAAI,IAAI,kBAAkB,CAAC,QAAQ;AACtC,cAAI,YAAY,GAAG;AAAA,QACrB,CAAC;AAED,aAAK,GAAI,IAAI,qBAAqB,CAAC,QAAQ;AACzC,cAAI,YAAY,GAAG;AAAA,QACrB,CAAC;AAED,aAAK,GAAI,IAAI,wBAAwB,CAAC,QAAQ;AAC5C,cAAI,YAAY,GAAG;AAAA,QACrB,CAAC;AAED,aAAK,GAAI,IAAI,0BAA0B,CAAC,QAAQ;AAC9C,cAAI,YAAY,GAAG;AAAA,QACrB,CAAC;AAED,aAAK,GAAI,IAAI,0BAA0B,CAAC,QAAQ;AAC9C,cAAI,YAAY,GAAG;AAAA,QACrB,CAAC;AAED,qBAAa,QAAQ,CAAA,WAAU;AAC7B,eAAK,GAAI,IAAI,QAAQ,CAAC,QAAQ;AAC5B,gBAAI,YAAY,GAAG;AAAA,UACrB,CAAC;AAAA,QACH,CAAC;AAED,gBAAA;AAAA,MACF,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AAAA,EAEA,MAAM,IAAI,KAAa,SAAgB,IAAwB;AAC7D,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,UAAI,CAAC,KAAK,IAAI;AACZ,eAAO,IAAI,MAAM,wBAAwB,CAAC;AAC1C;AAAA,MACF;AAEA,WAAK,GAAG,IAAI,KAAK,QAAQ,SAAS,KAAK;AACrC,YAAI,KAAK;AACP,iBAAO,GAAG;AAAA,QACZ,OAAO;AACL,kBAAQ,EAAE,IAAI,KAAK,QAAQ,SAAS,KAAK,SAAS;AAAA,QACpD;AAAA,MACF,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AAAA,EAEA,MAAM,IAAa,KAAa,SAAgB,IAA4B;AAC1E,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,UAAI,CAAC,KAAK,IAAI;AACZ,eAAO,IAAI,MAAM,wBAAwB,CAAC;AAC1C;AAAA,MACF;AAEA,WAAK,GAAG,IAAI,KAAK,QAAQ,CAAC,KAAK,QAAQ;AACrC,YAAI,KAAK;AACP,iBAAO,GAAG;AAAA,QACZ,OAAO;AACL,kBAAQ,GAAQ;AAAA,QAClB;AAAA,MACF,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AAAA,EAEA,MAAM,IAAa,KAAa,SAAgB,IAAkB;AAChE,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,UAAI,CAAC,KAAK,IAAI;AACZ,eAAO,IAAI,MAAM,wBAAwB,CAAC;AAC1C;AAAA,MACF;AAEA,WAAK,GAAG,IAAI,KAAK,QAAQ,CAAC,KAAK,SAAS;AACtC,YAAI,KAAK;AACP,iBAAO,GAAG;AAAA,QACZ,OAAO;AACL,kBAAQ,IAAW;AAAA,QACrB;AAAA,MACF,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AAAA,EAEA,MAAM,gBAA+B;AAGnCA,aAAO,KAAK,kDAAkD;AAAA,EAChE;AAAA,EAEA,MAAM,QAAuB;AAC3B,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,UAAI,CAAC,KAAK,IAAI;AACZ,gBAAA;AACA;AAAA,MACF;AAEA,WAAK,GAAG,MAAM,CAAC,QAAQ;AACrB,YAAI,KAAK;AACP,iBAAO,GAAG;AAAA,QACZ,OAAO;AACLA,mBAAO,KAAK,4BAA4B;AACxC,kBAAA;AAAA,QACF;AAAA,MACF,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AACF;ACjYO,MAAM,SAAS;AAAA,EACpB,eAAe;AAAA,EACf,cAAc;AAAA,EACd,eAAe;AAAA,EACf,WAAW;AAAA,EACX,cAAc;AAChB;AAWO,MAAM,SAAS;AAAA,EACpB,iBAAiB,OAAO;AAAA;AAAA,EACxB,iBAAiB;AAAA;AAAA,EACjB,eAAe;AAAA;AACjB;AAGO,MAAM,aAAa;AAAA;AAAA,EAExB,kBAAkB;AAAA,EAClB,eAAe;AAAA,EACf,gBAAgB;AAAA,EAChB,cAAc;AAAA;AAAA,EAGd,qBAAqB;AAAA;AAAA,EAGrB,cAAc;AAAA,EACd,qBAAqB;AAAA,EACrB,oBAAoB;AAAA;AAAA,EAGpB,gBAAgB;AAAA,EAChB,kBAAkB;AAAA,EAClB,gBAAgB;AAAA;AAAA,EAGhB,gBAAgB;AAAA,EAChB,qBAAqB;AAAA,EACrB,wBAAwB;AAAA,EACxB,gBAAgB;AAAA,EAChB,mBAAmB;AAAA,EACnB,kBAAkB;AAAA,EAClB,qBAAqB;AAAA,EACrB,aAAa;AAAA,EACb,wBAAwB;AAC1B;AAGO,MAAM,kBAAkB;AAAA,EAC7B,UAAU;AAAA,EACV,SAAS;AAAA,EACT,WAAW;AAAA,EACX,QAAQ;AACV;AAGO,MAAM,UAAU;AAAA,EACrB,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,QAAQ;AACV;AC5DO,MAAM,iBAAiB;AAAA,EAG5B,YAAY,eAAwB;AAF5B;AAIN,SAAK,gBAAgB,iBACD,QAAA,IAAY,iBACZ,KAAK,KAAK,QAAQ,IAAA,GAAO,WAAW;AAGxD,SAAK,gBAAgB,KAAK,QAAQ,KAAK,aAAa;AAAA,EACtD;AAAA,EAEA,MAAM,aAAuC;AAC3C,YAAQ,IAAI,8BAA8B,KAAK,aAAa,EAAE;AAG9D,QAAI,CAAC,MAAM,KAAK,OAAO,KAAK,aAAa,GAAG;AAC1C,YAAMC,SAAG,MAAM,KAAK,eAAe,EAAE,WAAW,MAAM;AACtD,cAAQ,IAAI,gCAAgC,KAAK,aAAa,EAAE;AAAA,IAClE;AAGA,UAAM,KAAK,kBAAA;AAGX,UAAM,UAAU;AAAA,MACd,KAAK,KAAK,KAAK,eAAe,MAAM;AAAA,MACpC,KAAK,KAAK,KAAK,eAAe,YAAY;AAAA,MAC1C,KAAK,KAAK,KAAK,eAAe,MAAM;AAAA,IAAA;AAGtC,eAAW,OAAO,SAAS;AACzB,UAAI,CAAC,MAAM,KAAK,OAAO,GAAG,GAAG;AAC3B,cAAMA,SAAG,MAAM,KAAK,EAAE,WAAW,MAAM;AACvC,gBAAQ,IAAI,sBAAsB,GAAG,EAAE;AAAA,MACzC;AAAA,IACF;AAGA,UAAM,KAAK,0BAAA;AAEX,WAAO;AAAA,MACL,WAAW,KAAK;AAAA,MAChB,SAAS,KAAK,KAAK,KAAK,eAAe,MAAM;AAAA,MAC7C,eAAe,KAAK,KAAK,KAAK,eAAe,YAAY;AAAA,MACzD,SAAS,KAAK,KAAK,KAAK,eAAe,MAAM;AAAA,IAAA;AAAA,EAEjD;AAAA,EAEA,MAAc,OAAOC,OAAgC;AACnD,QAAI;AACF,YAAMD,SAAG,OAAOC,KAAI;AACpB,aAAO;AAAA,IACT,QAAQ;AACN,aAAO;AAAA,IACT;AAAA,EACF;AAAA,EAEA,MAAc,oBAAmC;AAC/C,QAAI;AAEF,YAAM,WAAW,KAAK,KAAK,KAAK,eAAe,kBAAkB;AACjE,YAAMD,SAAG,UAAU,UAAU,MAAM;AACnC,YAAMA,SAAG,OAAO,QAAQ;AAAA,IAC1B,SAAS,OAAY;AACnB,UAAI,MAAM,SAAS,UAAU;AAC3B,cAAM,IAAI,MAAM,gDAAgD,KAAK,aAAa,EAAE;AAAA,MACtF;AACA,YAAM;AAAA,IACR;AAAA,EACF;AAAA,EAEA,MAAc,4BAA2C;AACvD,UAAM,gBAAgB,KAAK,KAAK,KAAK,eAAe,YAAY;AAEhE,QAAI;AACF,YAAM,OAAO,MAAMA,SAAG,QAAQ,aAAa;AAE3C,iBAAW,OAAO,MAAM;AACtB,YAAI,IAAI,WAAW,OAAO,GAAG;AAC3B,gBAAM,WAAW,KAAK,KAAK,eAAe,GAAG;AAC7C,gBAAM,QAAQ,MAAMA,SAAG,KAAK,QAAQ;AAGpC,gBAAM,aAAa,KAAK,IAAA,IAAQ,MAAM,MAAM,QAAA,MAAc,MAAO,KAAK,KAAK;AAC3E,cAAI,YAAY,GAAG;AACjB,kBAAMA,SAAG,GAAG,UAAU,EAAE,WAAW,MAAM,OAAO,MAAM;AACtD,oBAAQ,IAAI,uCAAuC,GAAG,EAAE;AAAA,UAC1D;AAAA,QACF;AAAA,MACF;AAAA,IACF,SAAS,OAAY;AAEnB,UAAI,MAAM,SAAS,UAAU;AAC3B,gBAAQ,MAAM,iCAAiC,KAAK;AAAA,MACtD;AAAA,IACF;AAAA,EACF;AAAA,EAEA,MAAM,yBAAyB,aAAsC;AACnE,UAAM,WAAW,KAAK,KAAK,KAAK,eAAe,cAAc,QAAQ,WAAW,EAAE;AAClF,UAAMA,SAAG,MAAM,UAAU,EAAE,WAAW,MAAM;AAC5C,WAAO;AAAA,EACT;AAAA,EAEA,MAAM,mBAAmB,OAAgC;AACvD,UAAM,UAAU,KAAK,KAAK,KAAK,eAAe,QAAQ,KAAK;AAC3D,UAAMA,SAAG,MAAM,SAAS,EAAE,WAAW,MAAM;AAC3C,WAAO;AAAA,EACT;AAAA,EAEA,MAAM,iBAAiB,aAAoC;AACzD,UAAM,WAAW,KAAK,KAAK,KAAK,eAAe,cAAc,QAAQ,WAAW,EAAE;AAElF,QAAI;AACF,YAAMA,SAAG,GAAG,UAAU,EAAE,WAAW,MAAM,OAAO,MAAM;AACtD,cAAQ,IAAI,mCAAmC,WAAW,EAAE;AAAA,IAC9D,SAAS,OAAY;AACnB,UAAI,MAAM,SAAS,UAAU;AAC3B,gBAAQ,MAAM,+BAA+B,WAAW,KAAK,KAAK;AAAA,MACpE;AAAA,IACF;AAAA,EACF;AAAA,EAEA,MAAM,qBAAqB,WAAmB,IAAqB;AACjE,UAAM,gBAAgB,KAAK,KAAK,KAAK,eAAe,YAAY;AAChE,UAAM,aAAa,KAAK,IAAA,IAAS,WAAW,KAAK,KAAK;AACtD,QAAI,eAAe;AAEnB,QAAI;AACF,YAAM,OAAO,MAAMA,SAAG,QAAQ,aAAa;AAE3C,iBAAW,OAAO,MAAM;AACtB,YAAI,IAAI,WAAW,OAAO,GAAG;AAC3B,gBAAM,WAAW,KAAK,KAAK,eAAe,GAAG;AAC7C,gBAAM,QAAQ,MAAMA,SAAG,KAAK,QAAQ;AAEpC,cAAI,MAAM,MAAM,QAAA,IAAY,YAAY;AACtC,kBAAMA,SAAG,GAAG,UAAU,EAAE,WAAW,MAAM,OAAO,MAAM;AACtD;AACA,oBAAQ,IAAI,6BAA6B,GAAG,EAAE;AAAA,UAChD;AAAA,QACF;AAAA,MACF;AAAA,IACF,SAAS,OAAY;AACnB,UAAI,MAAM,SAAS,UAAU;AAC3B,gBAAQ,MAAM,qCAAqC,KAAK;AAAA,MAC1D;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,MAAM,oBAIH;AACD,UAAM,QAAQ;AAAA,MACZ,WAAW;AAAA,MACX,gBAAgB;AAAA,MAChB,UAAU;AAAA,IAAA;AAIZ,QAAI;AACF,YAAM,WAAW,MAAMA,SAAG,QAAQ,KAAK,KAAK,KAAK,eAAe,YAAY,CAAC;AAC7E,YAAM,iBAAiB,SAAS,OAAO,CAAA,MAAK,EAAE,WAAW,OAAO,CAAC,EAAE;AAAA,IACrE,SAAS,OAAO;AAAA,IAEhB;AAGA,QAAI;AACF,YAAM,UAAU,MAAMA,SAAG,QAAQ,KAAK,KAAK,KAAK,eAAe,MAAM,CAAC;AACtE,YAAM,WAAW,QAAQ;AAAA,IAC3B,SAAS,OAAO;AAAA,IAEhB;AAGA,UAAM,YAAY,MAAM,KAAK,iBAAiB,KAAK,aAAa;AAEhE,WAAO;AAAA,EACT;AAAA,EAEA,MAAc,iBAAiB,SAAkC;AAC/D,QAAI,YAAY;AAEhB,QAAI;AACF,YAAM,UAAU,MAAMA,SAAG,QAAQ,SAAS,EAAE,eAAe,MAAM;AAEjE,iBAAW,SAAS,SAAS;AAC3B,cAAM,WAAW,KAAK,KAAK,SAAS,MAAM,IAAI;AAE9C,YAAI,MAAM,eAAe;AACvB,uBAAa,MAAM,KAAK,iBAAiB,QAAQ;AAAA,QACnD,OAAO;AACL,gBAAM,QAAQ,MAAMA,SAAG,KAAK,QAAQ;AACpC,uBAAa,MAAM;AAAA,QACrB;AAAA,MACF;AAAA,IACF,SAAS,OAAO;AAAA,IAEhB;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,mBAA2B;AACzB,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,WAAW,OAAuB;AAChC,WAAO,KAAK,KAAK,KAAK,eAAe,QAAQ,KAAK;AAAA,EACpD;AAAA,EAEA,iBAAiB,aAA6B;AAC5C,WAAO,KAAK,KAAK,KAAK,eAAe,cAAc,QAAQ,WAAW,EAAE;AAAA,EAC1E;AAAA,EAEA,mBAA2B;AACzB,WAAO,KAAK,KAAK,KAAK,eAAe,YAAY;AAAA,EACnD;AACF;AC1NA,MAAMD,WAAS,aAAa,gBAAgB;AAOrC,MAAM,eAAe;AAAA,EAM1B,YAAY,IAAcG,SAAgB,cAA4B;AAL9D;AACA;AACA;AACA;AAGN,SAAK,KAAK;AACV,SAAK,SAASA;AACd,SAAK,eAAe;AACpB,SAAK,sCAAsB,IAAA;AAAA,EAC7B;AAAA,EAEA,MAAM,MACJ,aACA,OACA,QACA,aAA4B,MAC5B,iBAA0B,OACH;AACvB,QAAI;AAEF,UAAI,CAAC,CAAC,UAAU,QAAQ,EAAE,SAAS,KAAK,GAAG;AACzC,cAAM,IAAI,MAAM,uBAAuB,KAAK,EAAE;AAAA,MAChD;AAGA,YAAM,qBAAqB,KAAK,mBAAmB,UAAU;AAG7D,YAAM,KAAK,oBAAoB,aAAa,gBAAgB,QAAQ;AACpEH,eAAO,KAAK,YAAY,KAAK,YAAY,EAAE,aAAa,YAAY,oBAAoB,eAAA,CAAgB;AAGxG,YAAM,EAAE,KAAK,KAAA,IAAS,KAAK,aAAa,OAAO,QAAQ,oBAAoB,cAAc;AAGzF,YAAM,eAAe,MAAM,KAAK,MAAM;AAAA,QACpC,KAAK;AAAA,QACL,KAAK,QAAA;AAAA,QACL,OAAO;AAAA,QACP,OAAO,CAAC,QAAQ,QAAQ,MAAM;AAAA,MAAA,CAC/B;AAGD,WAAK,gBAAgB,IAAI,aAAa,YAAY;AAGlD,mBAAa,GAAG,SAAS,MAAM;AAC7BA,iBAAO,KAAK,mBAAmB,EAAE,aAAa,KAAK,aAAa,KAAK;AACrE,aAAK,oBAAoB,aAAa,gBAAgB,SAAS,aAAa,GAAG;AAC/E,aAAK,aAAa,KAAK,OAAO,eAAe,EAAE,aAAa,KAAK,aAAa,KAAK;AAGnF,YAAI,UAAU,YAAY,KAAK,OAAO,OAAO,OAAO,YAAY,SAAS,SAAS,GAAG;AACnF,uBAAa,MAAO,IAAA;AAAA,QACtB;AAAA,MACF,CAAC;AAGD,mBAAa,GAAG,QAAQ,CAAC,MAAM,WAAW;AACxC,aAAK,kBAAkB,aAAa,MAAM,MAAM;AAAA,MAClD,CAAC;AAGD,mBAAa,GAAG,SAAS,CAAC,UAAU;AAClC,aAAK,mBAAmB,aAAa,KAAK;AAAA,MAC5C,CAAC;AAGDA,eAAO,KAAK,oBAAoB;AAAA,QAC9B;AAAA,QACA,SAAS;AAAA,QACT;AAAA,QACA,KAAK;AAAA,MAAA,CACN;AAGD,YAAM,eAAe,WAAW,MAAM;AACpC,YAAI,KAAK,WAAW,WAAW,KAAK,CAAC,aAAa,KAAK;AACrD,uBAAa,KAAA;AACb,eAAK,mBAAmB,aAAa,IAAI,MAAM,uBAAuB,CAAC;AAAA,QACzE;AAAA,MACF,GAAG,OAAO,aAAa;AAEvB,mBAAa,KAAK,SAAS,MAAM,aAAa,YAAY,CAAC;AAE3D,aAAO;AAAA,IACT,SAAS,OAAO;AACdA,eAAO,MAAM,2BAA2B,EAAE,aAAa,OAAO;AAC9D,YAAM,KAAK,oBAAoB,aAAa,gBAAgB,MAAM;AAClE,YAAM;AAAA,IACR;AAAA,EACF;AAAA,EAEQ,aAAa,OAAe,QAAgB,YAAoB,iBAA0B,OAAsB;AACtH,UAAM,cAAc,KAAK,OAAO,OAAO,KAAK;AAC5C,QAAI,CAAC,aAAa;AAChB,YAAM,IAAI,MAAM,qCAAqC,KAAK,EAAE;AAAA,IAC9D;AAEA,UAAM,UAAU,YAAY;AAC5B,UAAM,OAAO,CAAC,GAAG,YAAY,WAAW;AAExC,QAAI,UAAU,UAAU;AAEtB,UAAI,YAAY;AACd,aAAK,KAAK,SAAS,UAAU;AAAA,MAC/B;AAGA,UAAI,CAAC,gBAAgB;AAEnB,aAAK,KAAK,MAAM;AAAA,MAClB;AAAA,IAEF,WAAW,UAAU,UAAU;AAE7B,WAAK,KAAK,MAAM;AAAA,IAClB;AAEA,WAAO,EAAE,KAAK,SAAS,KAAA;AAAA,EACzB;AAAA,EAEQ,mBAAmB,YAAmC;AAC5D,QAAI,CAAC,YAAY;AACf,aAAO,KAAK,OAAO,UAAU;AAAA,IAC/B;AAGA,UAAM,WAAW,KAAK,QAAQ,UAAU;AAGxC,QAAI,CAAC,GAAG,WAAW,QAAQ,GAAG;AAC5B,YAAM,IAAI,MAAM,qCAAqC,QAAQ,EAAE;AAAA,IACjE;AAEA,QAAI,CAAC,GAAG,SAAS,QAAQ,EAAE,eAAe;AACxC,YAAM,IAAI,MAAM,4BAA4B,QAAQ,EAAE;AAAA,IACxD;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,MAAM,UAAU,aAAqB,OAA8B;AACjE,UAAMI,WAAU,KAAK,WAAW,WAAW;AAC3C,QAAI,CAACA,UAAS;AACZ,YAAM,IAAI,MAAM,mBAAmB;AAAA,IACrC;AAEA,QAAI,CAACA,SAAQ,SAASA,SAAQ,MAAM,WAAW;AAC7C,YAAM,IAAI,MAAM,gCAAgC;AAAA,IAClD;AAEA,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtCA,eAAQ,MAAO,MAAM,QAAQ,MAAM,CAAC,QAAQ;AAC1C,YAAI,KAAK;AACP,iBAAO,GAAG;AAAA,QACZ,OAAO;AACL,kBAAA;AAAA,QACF;AAAA,MACF,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AAAA,EAEA,MAAM,UAAU,aAAoC;AAClD,UAAMA,WAAU,KAAK,WAAW,WAAW;AAC3C,QAAI,CAACA,UAAS;AACZJ,eAAO,KAAK,kCAAkC,WAAW,EAAE;AAC3D;AAAA,IACF;AAEAA,aAAO,KAAK,qCAAqC,WAAW,EAAE;AAG9DI,aAAQ,KAAK,SAAS;AAGtB,eAAW,MAAM;AACf,UAAI,KAAK,WAAW,WAAW,GAAG;AAChCJ,iBAAO,KAAK,uCAAuC,WAAW,EAAE;AAChEI,iBAAQ,KAAK,SAAS;AAAA,MACxB;AAAA,IACF,GAAG,GAAI;AAAA,EACT;AAAA,EAEA,WAAW,aAA+C;AACxD,WAAO,KAAK,gBAAgB,IAAI,WAAW;AAAA,EAC7C;AAAA,EAEA,iBAAiB,aAA8B;AAC7C,UAAMA,WAAU,KAAK,WAAW,WAAW;AAC3C,WAAO,CAAC,CAACA,YAAW,CAACA,SAAQ;AAAA,EAC/B;AAAA,EAEA,MAAc,oBAAoB,aAAqB,QAA6B,KAA6B;AAC/G,UAAM,eAAyB,CAAC,YAAY;AAC5C,UAAM,eAAsB,CAAC,MAAM;AAEnC,QAAI,QAAQ,QAAW;AACrB,mBAAa,KAAK,SAAS;AAC3B,mBAAa,KAAK,GAAG;AAAA,IACvB;AAEA,QAAI,WAAW,gBAAgB,aAAa,WAAW,gBAAgB,QAAQ;AAC7E,mBAAa,KAAK,kCAAkC;AAAA,IACtD;AAEA,iBAAa,KAAK,WAAW;AAE7B,UAAM,KAAK,GAAG;AAAA,MACZ,yBAAyB,aAAa,KAAK,IAAI,CAAC;AAAA,MAChD;AAAA,IAAA;AAAA,EAEJ;AAAA,EAEA,MAAc,kBAAkB,aAAqB,MAAqB,QAA8C;AACtHJ,aAAO,KAAK,kBAAkB,EAAE,aAAa,MAAM,QAAQ;AAG3D,SAAK,gBAAgB,OAAO,WAAW;AAGvC,UAAM,SAAS,SAAS,IAAI,gBAAgB,YAAY,gBAAgB;AACxE,UAAM,KAAK,oBAAoB,aAAa,MAAM;AAGlD,SAAK,aAAa,KAAK,OAAO,cAAc,EAAE,aAAa,MAAM,QAAQ;AAGzE,SAAK,aAAa,KAAK,OAAO,cAAc,EAAE,aAAa;AAAA,EAC7D;AAAA,EAEA,MAAc,mBAAmB,aAAqB,OAA6B;AACjFA,aAAO,MAAM,iBAAiB,EAAE,aAAa,OAAO;AAGpD,SAAK,gBAAgB,OAAO,WAAW;AAGvC,UAAM,KAAK,oBAAoB,aAAa,gBAAgB,MAAM;AAGlE,UAAM,KAAK,GAAG;AAAA,MACZ;AAAA,MACA,CAAC,aAAa,QAAQ,QAAQ,kBAAkB,MAAM,OAAO,EAAE;AAAA,IAAA;AAIjE,SAAK,aAAa,KAAK,OAAO,eAAe,EAAE,aAAa,OAAO;AAAA,EACrE;AAAA,EAEA,MAAM,wBAA2C;AAC/C,WAAO,MAAM,KAAK,KAAK,gBAAgB,MAAM;AAAA,EAC/C;AAAA,EAEA,MAAM,eAA8B;AAClC,UAAM,eAAe,MAAM,KAAK,sBAAA;AAEhC,eAAW,eAAe,cAAc;AACtC,UAAI;AACF,cAAM,KAAK,UAAU,WAAW;AAAA,MAClC,SAAS,OAAO;AACdA,iBAAO,MAAM,+BAA+B,WAAW,KAAK,KAAK;AAAA,MACnE;AAAA,IACF;AAAA,EACF;AACF;AC9RA,MAAMA,WAAS,aAAa,eAAe;AAQpC,MAAM,cAAc;AAAA,EAKzB,YAAY,IAAc,cAA4B;AAJ9C;AACA;AACA;AAGN,SAAK,KAAK;AACV,SAAK,eAAe;AACpB,SAAK,8BAAc,IAAA;AAAA,EACrB;AAAA,EAEA,MAAM,aAAa,aAAqB,QAAsB,MAA6B;AACzF,QAAI;AACF,YAAM,UAAU,KAAK,SAAS,MAAM;AAGpC,UAAI,QAAA,IAAY,wBAAwB,QAAQ;AAC9CA,iBAAO,MAAM,WAAW,MAAM,IAAI,EAAE,aAAa,SAAS,QAAQ,KAAA,EAAK,CAAG;AAAA,MAC5E;AAGA,WAAK,eAAe,aAAa,OAAO;AAGxC,YAAM,KAAK,qBAAqB,aAAa,MAAM;AAAA,IAErD,SAAS,OAAO;AACdA,eAAO,MAAM,yBAAyB,EAAE,aAAa,OAAO;AAAA,IAC9D;AAAA,EACF;AAAA,EAEQ,eAAe,aAAqB,MAAoB;AAC9D,QAAI,SAAS,KAAK,QAAQ,IAAI,WAAW,KAAK;AAC9C,cAAU;AAGV,QAAI,OAAO,SAAS,OAAO,iBAAiB;AAC1CA,eAAO,KAAK,oCAAoC,EAAE,aAAa,MAAM,OAAO,QAAQ;AACpF,eAAS,OAAO,MAAM,QAAuB;AAAA,IAC/C;AAEA,SAAK,QAAQ,IAAI,aAAa,MAAM;AAAA,EACtC;AAAA,EAEA,MAAc,qBAAqB,aAAqB,YAAyC;AAC/F,QAAI,SAAS,KAAK,QAAQ,IAAI,WAAW,KAAK;AAC9C,UAAM,QAAQ,OAAO,MAAM,IAAI;AAG/B,UAAM,aAAa,MAAM,IAAA,KAAS;AAClC,SAAK,QAAQ,IAAI,aAAa,UAAU;AAGxC,eAAW,QAAQ,OAAO;AACxB,UAAI,KAAK,SAAS,GAAG;AACnB,cAAM,KAAK,QAAQ,aAAa,YAAY,IAAI;AAChD,aAAK,aAAa,aAAa;AAAA,UAC7B,YAAW,oBAAI,KAAA,GAAO,YAAA;AAAA,UACtB,MAAM;AAAA,UACN,SAAS;AAAA,QAAA,CACV;AAAA,MACH;AAAA,IACF;AAAA,EACF;AAAA,EAEA,MAAM,YAAY,aAAoC;AACpD,UAAM,SAAS,KAAK,QAAQ,IAAI,WAAW;AAE3C,QAAI,UAAU,OAAO,SAAS,GAAG;AAC/BA,eAAO,MAAM,mBAAmB,EAAE,aAAa,QAAQ,OAAO,QAAQ;AAEtE,YAAM,KAAK,QAAQ,aAAa,QAAQ,QAAQ,MAAM;AACtD,WAAK,aAAa,aAAa;AAAA,QAC7B,YAAW,oBAAI,KAAA,GAAO,YAAA;AAAA,QACtB,MAAM,QAAQ;AAAA,QACd,SAAS;AAAA,MAAA,CACV;AAAA,IACH;AAEA,SAAK,YAAY,WAAW;AAAA,EAC9B;AAAA,EAEA,YAAY,aAA2B;AACrC,SAAK,QAAQ,OAAO,WAAW;AAAA,EACjC;AAAA,EAEA,MAAc,QAAQ,aAAqB,MAAoB,SAAgC;AAC7F,QAAI;AAEF,YAAM,mBAAmB,QAAQ,SAAS,OAAO,kBAC7C,QAAQ,UAAU,GAAG,OAAO,eAAe,IAAI,oBAC/C;AAEJ,YAAM,KAAK,GAAG;AAAA,QACZ;AAAA,QACA,CAAC,aAAa,MAAM,gBAAgB;AAAA,MAAA;AAAA,IAExC,SAAS,OAAO;AACdA,eAAO,MAAM,sBAAsB,EAAE,aAAa,OAAO;AAAA,IAC3D;AAAA,EACF;AAAA,EAEQ,aAAa,aAAqB,UAA0B;AAClE,SAAK,aAAa,KAAK,OAAO,WAAW;AAAA,MACvC;AAAA,MACA,GAAG;AAAA,IAAA,CACJ;AAAA,EACH;AAAA,EAEA,YAAY,MAAsB;AAEhC,WAAO,KAAK,SAAS,MAAM,EAAE,KAAA;AAAA,EAC/B;AACF;ACzHA,MAAMK,cAAY,UAAU,IAAI;AAEhC,MAAM,WAAW;AAAA,EACf,YAAY,eAAe,qBAAqB,MAAM;AACpD,SAAK,gBAAgB;AACrB,SAAK,UAAU,KAAK,KAAK,eAAe,MAAM;AAC9C,YAAQ,IAAI,4CAA4C,aAAa,EAAE;AACvE,YAAQ,IAAI,gCAAgC,KAAK,OAAO,EAAE;AAC1D,SAAK,qBAAqB;AAAA,EAC5B;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,QAAQ,KAAK,SAAS,UAAU,CAAA,GAAI;AACxC,UAAM,EAAE,cAAc,MAAM,QAAQ,MAAM,YAAY,cAAc;AAGpE,UAAM,eAAe,KAAK,oBAAoB,OAAO;AAErD,QAAI,KAAK,oBAAoB;AAC3B,aAAO,MAAM,KAAK,mBAAmB,uBAAuB;AAAA,QAC1D;AAAA,QACA;AAAA,QACA,WAAW;AAAA,QACX,QAAQ,QAAQ,UAAU;AAAA,QAC1B,SAAS,OAAO,OAAO;AAAA,QACvB,YAAY;AAAA,MAAA,GACX,YAAY;AACb,eAAO,MAAM,KAAK,iBAAiB,KAAK,SAAS,OAAO;AAAA,MAC1D,CAAC;AAAA,IACH,OAAO;AACL,aAAO,MAAM,KAAK,iBAAiB,KAAK,SAAS,OAAO;AAAA,IAC1D;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,iBAAiB,KAAK,SAAS,UAAU,CAAA,GAAI;AACjD,QAAI;AACF,YAAM,EAAE,QAAQ,WAAW,MAAMA,YAAU,OAAO,OAAO,IAAI;AAAA,QAC3D;AAAA,QACA,UAAU,QAAQ,YAAY;AAAA,QAC9B,WAAW,KAAK,OAAO;AAAA;AAAA,QACvB,GAAG;AAAA,MAAA,CACJ;AAGD,UAAI,QAAQ,aAAa,UAAU;AACjC,eAAO;AAAA,MACT;AAEA,aAAO,OAAO,KAAA;AAAA,IAChB,SAAS,OAAO;AAEd,UAAI,MAAM,QAAQ;AAChB,cAAM,UAAU,GAAG,MAAM,OAAO;AAAA,EAAK,MAAM,MAAM;AAAA,MACnD;AACA,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,oBAAoB,SAAS;AAC3B,UAAM,QAAQ,QAAQ,KAAA,EAAO,MAAM,GAAG;AACtC,QAAI,MAAM,WAAW,EAAG,QAAO;AAE/B,UAAM,YAAY,MAAM,CAAC;AAGzB,QAAI,cAAc,cAAc,MAAM,CAAC,GAAG;AACxC,aAAO,YAAY,MAAM,CAAC,CAAC;AAAA,IAC7B;AACA,QAAI,cAAc,WAAW;AAC3B,aAAO;AAAA,IACT;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,UAAU,OAAO,SAAS,QAAQ,UAAU,IAAI;AACpD,UAAM,UAAU,KAAK,KAAK,KAAK,SAAS,KAAK;AAG7C,UAAM,KAAK,gBAAgB,KAAK;AAEhC,QAAI;AACF,UAAI;AACJ,UAAI,SAAS;AAEX,iBAAS,MAAM,KAAK;AAAA,UAAQ;AAAA,UAC1B,sCAAsC,KAAK,UAAU,MAAM,CAAC,IAAI,KAAK,UAAU,OAAO,CAAC;AAAA,QAAA;AAAA,MAE3F,OAAO;AAEL,iBAAS,MAAM,KAAK;AAAA,UAAQ;AAAA,UAC1B,0BAA0B,KAAK,UAAU,MAAM,CAAC;AAAA,QAAA;AAAA,MAEpD;AAEA,aAAO,OAAO,MAAM,IAAI,EAAE,OAAO,OAAO;AAAA,IAC1C,SAAS,OAAO;AACd,UAAI,MAAM,QAAQ,SAAS,yBAAyB,GAAG;AACrD,cAAM,IAAI,MAAM,WAAW,MAAM,6BAA6B,KAAK,GAAG;AAAA,MACxE;AACA,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,SAAS,OAAO,QAAQ,UAAU;AACtC,UAAM,UAAU,KAAK,KAAK,KAAK,SAAS,KAAK;AAG7C,UAAM,KAAK,gBAAgB,KAAK;AAEhC,QAAI;AAEF,YAAM,UAAU,MAAM,KAAK;AAAA,QAAQ;AAAA,QACjC,QAAQ,KAAK,UAAU,MAAM,CAAC,IAAI,KAAK,UAAU,QAAQ,CAAC;AAAA,QAC1D,EAAE,UAAU,SAAA;AAAA,MAAS;AAIvB,YAAM,WAAW,QAAQ,SAAS,CAAI;AAEtC,aAAO;AAAA,QACL;AAAA,QACA,OAAO;AAAA,QACP;AAAA,QACA,UAAU,WAAW,WAAW;AAAA,MAAA;AAAA,IAEpC,SAAS,OAAO;AACd,UAAI,MAAM,QAAQ,SAAS,gBAAgB,GAAG;AAC5C,eAAO,EAAE,OAAO,MAAA;AAAA,MAClB;AACA,UAAI,MAAM,QAAQ,SAAS,yBAAyB,GAAG;AACrD,cAAM,IAAI,MAAM,WAAW,MAAM,6BAA6B,KAAK,GAAG;AAAA,MACxE;AACA,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,cAAc,OAAO,SAAS,QAAQ,UAAU,IAAI;AACxD,UAAM,UAAU,KAAK,KAAK,KAAK,SAAS,KAAK;AAG7C,UAAM,KAAK,gBAAgB,KAAK;AAEhC,QAAI;AACF,YAAM,UAAU,UAAU,GAAG,MAAM,IAAI,OAAO,KAAK;AACnD,YAAM,SAAS,MAAM,KAAK;AAAA,QAAQ;AAAA,QAChC,cAAc,KAAK,UAAU,OAAO,CAAC;AAAA,MAAA;AAGvC,YAAM,UAAU,CAAA;AAChB,iBAAW,QAAQ,OAAO,MAAM,IAAI,EAAE,OAAO,OAAO,GAAG;AAErD,cAAM,QAAQ,KAAK,MAAM,sDAAsD;AAC/E,YAAI,OAAO;AACT,kBAAQ,KAAK;AAAA,YACX,MAAM,MAAM,CAAC;AAAA,YACb,MAAM,MAAM,CAAC,MAAM,SAAS,cAAc;AAAA,YAC1C,MAAM,MAAM,CAAC,MAAM,MAAM,OAAO,SAAS,MAAM,CAAC,CAAC;AAAA,YACjD,MAAM,MAAM,CAAC;AAAA,YACb,MAAM,MAAM,CAAC;AAAA,UAAA,CACd;AAAA,QACH;AAAA,MACF;AAEA,aAAO;AAAA,IACT,SAAS,OAAO;AACd,UAAI,MAAM,QAAQ,SAAS,yBAAyB,GAAG;AACrD,cAAM,IAAI,MAAM,WAAW,MAAM,cAAc,OAAO,6BAA6B,KAAK,GAAG;AAAA,MAC7F;AACA,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,YAAY,OAAO,QAAQ,UAAU;AACzC,UAAM,UAAU,KAAK,KAAK,KAAK,SAAS,KAAK;AAG7C,UAAM,KAAK,gBAAgB,KAAK;AAEhC,QAAI;AACF,YAAM,OAAO,MAAM,KAAK;AAAA,QAAQ;AAAA,QAC9B,cAAc,KAAK,UAAU,MAAM,CAAC,OAAO,KAAK,UAAU,QAAQ,CAAC;AAAA,MAAA;AAGrE,UAAI,CAAC,KAAK,QAAQ;AAChB,eAAO;AAAA,MACT;AAEA,YAAM,QAAQ,KAAK,KAAA,EAAO,MAAM,KAAK;AACrC,UAAI,MAAM,SAAS,GAAG;AACpB,eAAO;AAAA,MACT;AAEA,YAAM,CAAC,MAAM,MAAM,MAAM,MAAM,GAAG,SAAS,IAAI;AAC/C,YAAM,OAAO,UAAU,KAAK,GAAG;AAG/B,YAAM,eAAe,MAAM,KAAK;AAAA,QAAQ;AAAA,QACtC,uBAAuB,KAAK,UAAU,MAAM,CAAC,OAAO,KAAK,UAAU,QAAQ,CAAC;AAAA,MAAA;AAG9E,aAAO;AAAA,QACL;AAAA,QACA;AAAA,QACA;AAAA,QACA,MAAM,SAAS,IAAI;AAAA,QACnB;AAAA,QACA,cAAc,aAAa,KAAA;AAAA,MAAK;AAAA,IAEpC,SAAS,OAAO;AACd,UAAI,MAAM,QAAQ,SAAS,yBAAyB,GAAG;AACrD,cAAM,IAAI,MAAM,WAAW,MAAM,6BAA6B,KAAK,GAAG;AAAA,MACxE;AACA,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,eAAe,OAAO,aAAa,YAAY;AACnD,UAAM,UAAU,KAAK,KAAK,KAAK,SAAS,KAAK;AAC7C,UAAM,aAAa,QAAQ,WAAW;AAGtC,UAAM,KAAK,gBAAgB,KAAK;AAEhC,QAAI;AAEF,YAAM,aAAa,mBAAmB,KAAK,UAAU,UAAU,CAAC,IAAI,KAAK,UAAU,UAAU,CAAC;AAC9F,cAAQ,IAAI,oDAAoD,UAAU,EAAE;AAC5E,YAAM,KAAK,QAAQ,SAAS,UAAU;AACtC,cAAQ,IAAI,iDAAiD,UAAU,gBAAgB,UAAU,EAAE;AAEnG,aAAO;AAAA,QACL,cAAc;AAAA,QACd,QAAQ;AAAA,MAAA;AAAA,IAEZ,SAAS,OAAO;AACd,UAAI,MAAM,QAAQ,SAAS,gBAAgB,GAAG;AAC5C,cAAM,IAAI,MAAM,qCAAqC,WAAW,kBAAkB;AAAA,MACpF;AACA,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,eAAe,OAAO,cAAc;AACxC,UAAM,UAAU,KAAK,KAAK,KAAK,SAAS,KAAK;AAE7C,QAAI;AAEF,YAAM,KAAK;AAAA,QAAQ;AAAA,QACjB,2BAA2B,KAAK,UAAU,YAAY,CAAC;AAAA,MAAA;AAAA,IAE3D,SAAS,OAAO;AAEd,UAAI,CAAC,MAAM,QAAQ,SAAS,oBAAoB,GAAG;AACjD,cAAM;AAAA,MACR;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,cAAc,OAAO;AACzB,UAAM,UAAU,KAAK,KAAK,KAAK,SAAS,KAAK;AAG7C,UAAM,KAAK,gBAAgB,KAAK;AAEhC,UAAM,SAAS,MAAM,KAAK,QAAQ,SAAS,2BAA2B;AAEtE,UAAM,YAAY,CAAA;AAClB,QAAI,UAAU,CAAA;AAEd,eAAW,QAAQ,OAAO,MAAM,IAAI,GAAG;AACrC,UAAI,KAAK,WAAW,WAAW,GAAG;AAChC,YAAI,QAAQ,MAAM;AAChB,oBAAU,KAAK,OAAO;AAAA,QACxB;AACA,kBAAU,EAAE,MAAM,KAAK,UAAU,CAAC,EAAA;AAAA,MACpC,WAAW,KAAK,WAAW,OAAO,GAAG;AACnC,gBAAQ,OAAO,KAAK,UAAU,CAAC;AAAA,MACjC,WAAW,KAAK,WAAW,SAAS,GAAG;AACrC,gBAAQ,SAAS,KAAK,UAAU,CAAC;AAAA,MACnC,WAAW,SAAS,YAAY;AAC9B,gBAAQ,WAAW;AAAA,MACrB,WAAW,SAAS,IAAI;AAEtB,YAAI,QAAQ,MAAM;AAChB,oBAAU,KAAK,OAAO;AACtB,oBAAU,CAAA;AAAA,QACZ;AAAA,MACF;AAAA,IACF;AAGA,QAAI,QAAQ,MAAM;AAChB,gBAAU,KAAK,OAAO;AAAA,IACxB;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,aAAa,OAAO;AACxB,UAAM,UAAU,KAAK,KAAK,KAAK,SAAS,KAAK;AAG7C,UAAM,KAAK,gBAAgB,KAAK;AAEhC,UAAM,SAAS,MAAM,KAAK,QAAQ,SAAS,qFAAqF;AAEhI,UAAM,WAAW,CAAA;AACjB,eAAW,QAAQ,OAAO,MAAM,IAAI,EAAE,OAAO,OAAO,GAAG;AACrD,YAAM,CAAC,MAAM,MAAM,MAAM,GAAG,YAAY,IAAI,KAAK,MAAM,GAAG;AAC1D,eAAS,KAAK;AAAA,QACZ,MAAM,KAAK,QAAQ,WAAW,EAAE;AAAA,QAChC;AAAA,QACA;AAAA,QACA,SAAS,aAAa,KAAK,GAAG;AAAA,MAAA,CAC/B;AAAA,IACH;AAGA,UAAM,gBAAgB,MAAM,KAAK,QAAQ,SAAS,6BAA6B;AAE/E,WAAO;AAAA,MACL,SAAS;AAAA,MACT;AAAA,IAAA;AAAA,EAEJ;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,aAAa,OAAO,YAAY,aAAa,QAAQ;AACzD,UAAM,UAAU,KAAK,KAAK,KAAK,SAAS,KAAK;AAG7C,UAAM,KAAK,gBAAgB,KAAK;AAEhC,UAAM,KAAK;AAAA,MAAQ;AAAA,MACjB,eAAe,KAAK,UAAU,UAAU,CAAC,IAAI,KAAK,UAAU,UAAU,CAAC;AAAA,IAAA;AAAA,EAE3E;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,aAAa,OAAO,YAAY,QAAQ,OAAO;AACnD,UAAM,UAAU,KAAK,KAAK,KAAK,SAAS,KAAK;AAG7C,UAAM,KAAK,gBAAgB,KAAK;AAEhC,UAAM,OAAO,QAAQ,OAAO;AAC5B,UAAM,KAAK,QAAQ,SAAS,UAAU,IAAI,IAAI,KAAK,UAAU,UAAU,CAAC,EAAE;AAAA,EAC5E;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,eAAe,OAAO;AAC1B,UAAM,UAAU,KAAK,KAAK,KAAK,SAAS,KAAK;AAG7C,UAAMJ,SAAG,MAAM,SAAS,EAAE,WAAW,MAAM;AAG3C,UAAM,KAAK,QAAQ,SAAS,MAAM;AAGlC,UAAM,KAAK,QAAQ,SAAS,gCAAgC;AAE5D,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,UAAU,OAAO;AACrB,UAAM,UAAU,KAAK,KAAK,KAAK,SAAS,KAAK;AAC7C,YAAQ,IAAI,wCAAwC,KAAK,aAAa,OAAO,EAAE;AAE/E,QAAI;AACF,YAAM,OAAO,MAAMA,SAAG,KAAK,OAAO;AAClC,UAAI,CAAC,KAAK,eAAe;AACvB,gBAAQ,IAAI,oDAAoD,OAAO,EAAE;AACzE,eAAO;AAAA,MACT;AACA,cAAQ,IAAI,kCAAkC,OAAO,EAAE;AAGvD,UAAI;AACF,cAAM,KAAK,QAAQ,SAAS,qBAAqB;AACjD,gBAAQ,IAAI,0CAA0C,OAAO,EAAE;AAC/D,eAAO;AAAA,MACT,SAAS,UAAU;AACjB,gBAAQ,IAAI,8DAA8D,OAAO,IAAI,SAAS,OAAO;AACrG,eAAO;AAAA,MACT;AAAA,IACF,SAAS,OAAO;AACd,cAAQ,IAAI,qCAAqC,OAAO,IAAI,MAAM,OAAO;AACzE,aAAO;AAAA,IACT;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,gBAAgB,OAAO;AAC3B,QAAI,CAAC,MAAM,KAAK,UAAU,KAAK,GAAG;AAChC,YAAM,IAAI,MAAM,cAAc,KAAK,kBAAkB;AAAA,IACvD;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,WAAW;AACf,QAAI;AACF,YAAM,UAAU,MAAMA,SAAG,QAAQ,KAAK,SAAS,EAAE,eAAe,MAAM;AACtE,YAAM,OAAO,CAAA;AAEb,iBAAW,SAAS,SAAS;AAC3B,YAAI,MAAM,eAAe;AACvB,gBAAM,QAAQ,MAAM;AACpB,cAAI,MAAM,KAAK,UAAU,KAAK,GAAG;AAC/B,iBAAK,KAAK,KAAK;AAAA,UACjB;AAAA,QACF;AAAA,MACF;AAEA,aAAO;AAAA,IACT,SAAS,OAAO;AACd,UAAI,MAAM,SAAS,UAAU;AAC3B,eAAO,CAAA;AAAA,MACT;AACA,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,UAAU,KAAK;AACb,QAAI,CAAC,IAAK,QAAO;AAEjB,WAAO,IAAI,IAAI,QAAQ,MAAM,OAAO,CAAC;AAAA,EACvC;AACF;AC5dA,MAAM,wBAAwB;AAAA,EAC5B,YAAY,kBAAkBK,aAAYC,iBAAgB;AACxD,SAAK,mBAAmB;AACxB,UAAM,gBAAgB,iBAAiB,iBAAA;AACvC,YAAQ,IAAI,6CAA6C,aAAa,EAAE;AACxE,SAAK,aAAaD,eAAc,IAAI,WAAW,aAAa;AAC5D,SAAK,gBAAgB,iBAAiB,iBAAA;AACtC,YAAQ,IAAI,mDAAmD,KAAK,aAAa,EAAE;AACnF,SAAK,iBAAiBC;AAAA,EACxB;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,wBAAwB,aAAa,OAAO,IAAI;AACpD,UAAM,gBAAgB,KAAK,KAAK,KAAK,eAAe,QAAQ,WAAW,EAAE;AAGzE,UAAM,OAAO;AAAA,MACX,MAAM;AAAA,MACN,MAAM,KAAK,KAAK,eAAe,MAAM;AAAA,MACrC,QAAQ,KAAK,KAAK,eAAe,QAAQ;AAAA,MACzC,QAAQ,KAAK,KAAK,eAAe,QAAQ;AAAA,IAAA;AAI3C,eAAW,OAAO,OAAO,OAAO,IAAI,GAAG;AACrC,YAAMN,SAAG,MAAM,KAAK,EAAE,WAAW,MAAM;AAAA,IACzC;AAGA,UAAM,iBAAiB;AAAA,MACrB,MAAM,KAAK,QAAQ,CAAA;AAAA,MACnB,QAAQ,KAAK,UAAU,CAAA;AAAA,MACvB,QAAQ,KAAK,UAAU,CAAA;AAAA,IAAC;AAI1B,UAAM,WAAW;AAAA,MACf;AAAA,MACA,YAAW,oBAAI,KAAA,GAAO,YAAA;AAAA,MACtB,MAAM;AAAA,MACN,OAAO;AAAA,IAAA;AAGT,UAAMA,SAAG;AAAA,MACP,KAAK,KAAK,eAAe,eAAe;AAAA,MACxC,KAAK,UAAU,UAAU,MAAM,CAAC;AAAA,IAAA;AAIlC,QAAI;AACF,YAAM,cAAc;AAAA,QAClB,MAAM,CAAA;AAAA,QACN,QAAQ,CAAA;AAAA,MAAC;AAGX,UAAI,KAAK,QAAQ,KAAK,KAAK,SAAS,GAAG;AACrC,oBAAY,OAAO,MAAM,KAAK,kBAAkB,aAAa,KAAK,IAAI;AAAA,MACxE;AAEA,UAAI,KAAK,UAAU,KAAK,OAAO,SAAS,GAAG;AACzC,cAAM,SAAS,MAAM,KAAK,iBAAiB,aAAa,KAAK,MAAM;AACnE,iBAAS,YAAY,OAAO;AAC5B,oBAAY,SAAS,OAAO;AAAA,MAC9B;AAEA,UAAI,KAAK,UAAU,KAAK,OAAO,SAAS,GAAG;AACzC,cAAM,KAAK,gBAAgB,aAAa,KAAK,MAAM;AAAA,MACrD;AAGA,eAAS,cAAc;AAGvB,YAAMA,SAAG;AAAA,QACP,KAAK,KAAK,eAAe,eAAe;AAAA,QACxC,KAAK,UAAU,UAAU,MAAM,CAAC;AAAA,MAAA;AAGlC,aAAO;AAAA,QACL;AAAA,QACA;AAAA,QACA,OAAO;AAAA,QACP;AAAA,MAAA;AAAA,IAEJ,SAAS,OAAO;AAEd,YAAM,KAAK,0BAA0B,WAAW;AAChD,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,kBAAkB,aAAa,QAAQ;AAC3C,UAAM,gBAAgB,KAAK,KAAK,KAAK,eAAe,QAAQ,WAAW,EAAE;AACzE,UAAM,UAAU,KAAK,KAAK,eAAe,MAAM;AAC/C,UAAM,cAAc,CAAA;AAEpB,eAAW,SAAS,QAAQ;AAE1B,UAAI,CAAC,MAAM,KAAK,WAAW,UAAU,KAAK,GAAG;AAC3C,gBAAQ,MAAM,6CAA6C,KAAK,mBAAmB;AACnF,cAAM,IAAI,MAAM,mBAAmB,KAAK,0EAA0E;AAAA,MACpH;AAEA,YAAM,aAAa,KAAK,KAAK,KAAK,WAAW,SAAS,KAAK;AAC3D,YAAM,WAAW,KAAK,KAAK,SAAS,KAAK;AAGzC,cAAQ,IAAI,6DAA6D,UAAU,OAAO,QAAQ,EAAE;AACpG,YAAMA,SAAG,QAAQ,YAAY,UAAU,KAAK;AAAA,IAC9C;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,iBAAiB,aAAa,QAAQ;AAC1C,UAAM,gBAAgB,KAAK,KAAK,KAAK,eAAe,QAAQ,WAAW,EAAE;AACzE,UAAM,YAAY,KAAK,KAAK,eAAe,QAAQ;AACnD,UAAM,YAAY,CAAA;AAClB,UAAM,cAAc,CAAA;AAEpB,eAAW,SAAS,QAAQ;AAE1B,UAAI,CAAC,MAAM,KAAK,WAAW,UAAU,KAAK,GAAG;AAC3C,gBAAQ,MAAM,+CAA+C,KAAK,mBAAmB;AACrF,cAAM,IAAI,MAAM,qBAAqB,KAAK,0EAA0E;AAAA,MACtH;AAEA,YAAM,eAAe,KAAK,KAAK,WAAW,KAAK;AAE/C,UAAI;AACF,gBAAQ,IAAI,uDAAuD,KAAK,OAAO,YAAY,EAAE;AAC7F,cAAM,SAAS,MAAM,KAAK,WAAW,eAAe,OAAO,aAAa,YAAY;AACpF,gBAAQ,IAAI,4DAA4D,MAAM;AAC9E,kBAAU,KAAK,IAAI;AAGnB,YAAI,CAAC,KAAK,iBAAiB;AACzB,eAAK,kBAAkB,CAAA;AAAA,QACzB;AACA,aAAK,gBAAgB,KAAK;AAAA,UACxB;AAAA,UACA,SAAS;AAAA,UACT;AAAA,QAAA,CACD;AAAA,MACH,SAAS,OAAO;AAEd,mBAAW,CAAC,cAAc,YAAY,KAAK,OAAO,QAAQ,SAAS,GAAG;AACpE,cAAI;AACF,kBAAM,KAAK,WAAW,eAAe,cAAc,aAAa,YAAY;AAE5E,kBAAM,KAAK,WAAW,aAAa,cAAc,aAAa,QAAQ,IAAI;AAAA,UAC5E,SAAS,cAAc;AACrB,oBAAQ,MAAM,mCAAmC,YAAY,KAAK,YAAY;AAAA,UAChF;AAAA,QACF;AACA,cAAM;AAAA,MACR;AAAA,IACF;AAEA,WAAO,EAAE,WAAW,YAAA;AAAA,EACtB;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,gBAAgB,aAAa,QAAQ;AACzC,UAAM,gBAAgB,KAAK,KAAK,KAAK,eAAe,QAAQ,WAAW,EAAE;AACzE,UAAM,YAAY,KAAK,KAAK,eAAe,QAAQ;AAEnD,eAAW,SAAS,QAAQ;AAE1B,UAAI,MAAM,KAAK,WAAW,UAAU,KAAK,GAAG;AAC1C,cAAM,IAAI,MAAM,cAAc,KAAK,kBAAkB;AAAA,MACvD;AAGA,YAAM,SAAS,KAAK,KAAK,WAAW,KAAK;AACzC,YAAMA,SAAG,MAAM,QAAQ,EAAE,WAAW,MAAM;AAC1C,cAAQ,IAAI,kEAAkE,MAAM,EAAE;AAGtF,YAAMA,SAAG;AAAA,QACP,KAAK,KAAK,QAAQ,gBAAgB;AAAA,QAClC,KAAK,UAAU;AAAA,UACb;AAAA,UACA,YAAW,oBAAI,KAAA,GAAO,YAAA;AAAA,UACtB;AAAA,UACA,MAAM;AAAA,QAAA,CACP;AAAA,MAAA;AAIH,UAAI,CAAC,KAAK,iBAAiB;AACzB,aAAK,kBAAkB,CAAA;AAAA,MACzB;AACA,WAAK,gBAAgB,KAAK;AAAA,QACxB;AAAA,QACA,SAAS;AAAA,QACT;AAAA,MAAA,CACD;AAAA,IACH;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,uBAAuB;AAC3B,QAAI,CAAC,KAAK,mBAAmB,KAAK,gBAAgB,WAAW,GAAG;AAC9D;AAAA,IACF;AAEA,eAAW,WAAW,KAAK,iBAAiB;AAC1C,UAAI,KAAK,gBAAgB;AACvB,gBAAQ,IAAI,uDAAuD,QAAQ,KAAK,KAAK;AACrF,YAAI;AACF,gBAAM,gBAAgB,MAAM,KAAK,eAAe,aAAa,QAAQ,aAAa;AAAA,YAChF,SAAS,QAAQ;AAAA,YACjB,OAAO,QAAQ;AAAA,YACf,qBAAqB;AAAA;AAAA,UAAA,CACtB;AACD,kBAAQ,IAAI,2DAA2D,aAAa;AAAA,QACtF,SAAS,OAAO;AACd,kBAAQ,MAAM,8DAA8D,QAAQ,KAAK,KAAK,KAAK;AAAA,QAErG;AAAA,MACF;AAAA,IACF;AAGA,SAAK,kBAAkB,CAAA;AAAA,EACzB;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,qBAAqB,aAAa;AACtC,UAAM,eAAe,KAAK,KAAK,KAAK,eAAe,QAAQ,WAAW,IAAI,eAAe;AAEzF,QAAI;AACF,YAAM,UAAU,MAAMA,SAAG,SAAS,cAAc,MAAM;AACtD,aAAO,KAAK,MAAM,OAAO;AAAA,IAC3B,SAAS,OAAO;AACd,UAAI,MAAM,SAAS,UAAU;AAC3B,eAAO;AAAA,MACT;AACA,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,0BAA0B,aAAa;AAC3C,UAAM,WAAW,MAAM,KAAK,qBAAqB,WAAW;AAG5D,QAAI,YAAY,SAAS,WAAW;AAClC,iBAAW,CAAC,OAAO,YAAY,KAAK,OAAO,QAAQ,SAAS,SAAS,GAAG;AACtE,YAAI;AACF,gBAAM,KAAK,WAAW,eAAe,OAAO,aAAa,YAAY;AAGrE,kBAAQ,IAAI,8BAA8B,aAAa,MAAM,kBAAkB;AAAA,QACjF,SAAS,OAAO;AACd,kBAAQ,MAAM,iCAAiC,KAAK,KAAK,KAAK;AAAA,QAChE;AAAA,MACF;AAAA,IACF;AAGA,UAAM,gBAAgB,KAAK,KAAK,KAAK,eAAe,QAAQ,WAAW,EAAE;AACzE,QAAI;AACF,YAAMA,SAAG,GAAG,eAAe,EAAE,WAAW,MAAM,OAAO,MAAM;AAAA,IAC7D,SAAS,OAAO;AACd,UAAI,MAAM,SAAS,UAAU;AAC3B,cAAM;AAAA,MACR;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,iBAAiB;AACrB,QAAI;AACF,YAAM,UAAU,MAAMA,SAAG,QAAQ,KAAK,eAAe,EAAE,eAAe,MAAM;AAC5E,YAAM,aAAa,CAAA;AAEnB,iBAAW,SAAS,SAAS;AAC3B,YAAI,MAAM,iBAAiB,MAAM,KAAK,WAAW,OAAO,GAAG;AACzD,gBAAM,cAAc,MAAM,KAAK,UAAU,CAAC;AAC1C,gBAAM,WAAW,MAAM,KAAK,qBAAqB,WAAW;AAC5D,cAAI,UAAU;AACZ,uBAAW,KAAK;AAAA,cACd;AAAA,cACA,WAAW,SAAS;AAAA,cACpB,MAAM,SAAS;AAAA,YAAA,CAChB;AAAA,UACH;AAAA,QACF;AAAA,MACF;AAEA,aAAO,WAAW;AAAA,QAAK,CAAC,GAAG,MACzB,IAAI,KAAK,EAAE,SAAS,IAAI,IAAI,KAAK,EAAE,SAAS;AAAA,MAAA;AAAA,IAEhD,SAAS,OAAO;AACd,UAAI,MAAM,SAAS,UAAU;AAC3B,eAAO,CAAA;AAAA,MACT;AACA,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,oBAAoB,aAAa;AACrC,UAAM,WAAW,MAAM,KAAK,qBAAqB,WAAW;AAC5D,QAAI,CAAC,YAAY,CAAC,SAAS,WAAW;AACpC,aAAO,CAAA;AAAA,IACT;AAEA,UAAM,UAAU,CAAA;AAEhB,eAAW,CAAC,OAAO,YAAY,KAAK,OAAO,QAAQ,SAAS,SAAS,GAAG;AACtE,UAAI;AAEF,cAAM,SAAS,MAAM,KAAK,WAAW;AAAA,UACnC,aAAa;AAAA,UACb;AAAA,QAAA;AAGF,cAAM,QAAQ;AAAA,UACZ,OAAO,CAAA;AAAA,UACP,UAAU,CAAA;AAAA,UACV,SAAS,CAAA;AAAA,QAAC;AAGZ,YAAI,QAAQ;AACV,qBAAW,QAAQ,OAAO,MAAM,IAAI,EAAE,OAAO,OAAO,GAAG;AACrD,kBAAM,aAAa,KAAK,UAAU,GAAG,CAAC;AACtC,kBAAM,WAAW,KAAK,UAAU,CAAC,EAAE,KAAA;AAGnC,kBAAM,cAAc,WAAW,CAAC;AAChC,kBAAM,gBAAgB,WAAW,CAAC;AAElC,gBAAI,eAAe,MAAM;AAEvB,oBAAM,MAAM,KAAK,QAAQ;AAAA,YAC3B,WAAW,gBAAgB,OAAO,kBAAkB,KAAK;AAEvD,oBAAM,MAAM,KAAK,QAAQ;AAAA,YAC3B,WAAW,gBAAgB,OAAO,kBAAkB,KAAK;AAEvD,oBAAM,SAAS,KAAK,QAAQ;AAAA,YAC9B,WAAW,gBAAgB,OAAO,kBAAkB,KAAK;AAEvD,oBAAM,QAAQ,KAAK,QAAQ;AAAA,YAC7B,WAAW,gBAAgB,KAAK;AAE9B,oBAAM,cAAc,SAAS,MAAM,MAAM;AACzC,kBAAI,YAAY,WAAW,GAAG;AAC5B,sBAAM,QAAQ,KAAK,YAAY,CAAC,CAAC;AACjC,sBAAM,MAAM,KAAK,YAAY,CAAC,CAAC;AAAA,cACjC;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAEA,gBAAQ,KAAK,IAAI;AAAA,UACf,QAAQ,aAAa;AAAA,UACrB;AAAA,UACA,YAAY,MAAM,MAAM,SAAS,KAAK,MAAM,SAAS,SAAS,KAAK,MAAM,QAAQ,SAAS;AAAA,QAAA;AAAA,MAE9F,SAAS,OAAO;AACd,gBAAQ,MAAM,6BAA6B,KAAK,KAAK,KAAK;AAC1D,gBAAQ,KAAK,IAAI;AAAA,UACf,OAAO,MAAM;AAAA,QAAA;AAAA,MAEjB;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AACF;ACxYkBO,YAAU,IAAI;AAEhC,MAAM,cAAc;AAAA,EAClB,YAAY,kBAAkBF,aAAY,gBAAgB;AACxD,SAAK,mBAAmB;AACxB,SAAK,aAAaA,eAAc,IAAI,WAAW,iBAAiB,kBAAkB;AAClF,SAAK,iBAAiB,kBAAkB,IAAI,wBAAwB,kBAAkB,KAAK,UAAU;AAAA,EACvG;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,cAAc,aAAa,OAAO,SAAS;AAC/C,UAAM,WAAW,MAAM,KAAK,eAAe,qBAAqB,WAAW;AAC3E,QAAI,CAAC,YAAY,CAAC,SAAS,aAAa,CAAC,SAAS,UAAU,KAAK,GAAG;AAClE,YAAM,IAAI,MAAM,oCAAoC,KAAK,mBAAmB,WAAW,GAAG;AAAA,IAC5F;AAEA,UAAM,eAAe,SAAS,UAAU,KAAK,EAAE;AAG/C,UAAM,SAAS,MAAM,KAAK,WAAW,QAAQ,cAAc,oBAAoB;AAC/E,QAAI,CAAC,OAAO,QAAQ;AAClB,aAAO;AAAA,QACL,WAAW;AAAA,QACX,SAAS;AAAA,MAAA;AAAA,IAEb;AAGA,UAAM,KAAK,WAAW,QAAQ,cAAc,QAAQ;AAGpD,UAAM,cAAc,GAAG,OAAO;AAAA;AAAA,aAAkB,WAAW;AAC3D,UAAM,gBAAgB,aAAa,KAAK,WAAW,UAAU,WAAW,CAAC;AAEzE,QAAI;AACF,YAAM,SAAS,MAAM,KAAK,WAAW,QAAQ,cAAc,aAAa;AAGxE,YAAM,aAAa,MAAM,KAAK,WAAW,QAAQ,cAAc,gBAAgB;AAE/E,aAAO;AAAA,QACL,WAAW;AAAA,QACX,MAAM;AAAA,QACN,SAAS;AAAA,QACT;AAAA,MAAA;AAAA,IAEJ,SAAS,OAAO;AAEd,UAAI,MAAM,QAAQ,SAAS,mBAAmB,GAAG;AAC/C,eAAO;AAAA,UACL,WAAW;AAAA,UACX,SAAS;AAAA,QAAA;AAAA,MAEb;AACA,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,oBAAoB,OAAO,iBAAiB;AAChD,UAAM,UAAU,KAAK,KAAK,KAAK,WAAW,SAAS,KAAK;AAExD,QAAI;AAKF,YAAM,WAAW,MAAM,KAAK,WAAW,QAAQ,SAAS,WAAW;AACnE,YAAM,eAAe,SAAS,SAAS,eAAe;AAEtD,UAAI,CAAC,cAAc;AACjB,cAAM,IAAI,MAAM,qBAAqB,eAAe,2BAA2B;AAAA,MACjF;AAGA,YAAM,iBAAiB,MAAM,KAAK,WAAW,QAAQ,SAAS,aAAa,KAAK,WAAW,UAAU,eAAe,CAAC,EAAE;AAGvH,YAAM,iBAAiB,MAAM,KAAK,WAAW,QAAQ,SAAS,gBAAgB;AAG9E,YAAM,KAAK,WAAW,QAAQ,SAAS,eAAe;AAEtD,aAAO;AAAA,QACL,QAAQ;AAAA,QACR,mBAAmB,CAAC,QAAQ,eAAe;AAAA,QAC3C;AAAA,QACA;AAAA,QACA,aAAa;AAAA;AAAA,QACb,SAAS,+BAA+B,eAAe;AAAA,MAAA;AAAA,IAE3D,SAAS,OAAO;AACd,aAAO;AAAA,QACL,QAAQ;AAAA,QACR,OAAO,MAAM;AAAA,QACb,SAAS,oCAAoC,eAAe,MAAM,MAAM,OAAO;AAAA,MAAA;AAAA,IAEnF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,iBAAiB,aAAa,OAAO;AACzC,UAAM,WAAW,MAAM,KAAK,eAAe,qBAAqB,WAAW;AAC3E,QAAI,CAAC,UAAU;AACb,YAAM,IAAI,MAAM,cAAc,WAAW,aAAa;AAAA,IACxD;AAGA,QAAI,CAAC,SAAS,KAAK,UAAU,CAAC,SAAS,KAAK,OAAO,SAAS,KAAK,GAAG;AAClE,YAAM,IAAI,MAAM,cAAc,KAAK,+CAA+C,WAAW,GAAG;AAAA,IAClG;AAGA,QAAI,MAAM,KAAK,WAAW,UAAU,KAAK,GAAG;AAC1C,YAAM,IAAI,MAAM,cAAc,KAAK,kBAAkB;AAAA,IACvD;AAEA,UAAM,aAAa,KAAK,KAAK,SAAS,MAAM,QAAQ,KAAK;AAGzD,UAAM,WAAW,MAAM,KAAK,uBAAuB,UAAU;AAC7D,UAAM,QAAQ,SAAS,OAAO,CAAA,MAAK,MAAM,gBAAgB;AAEzD,QAAI,MAAM,WAAW,GAAG;AACtB,YAAM,IAAI,MAAM,qDAAqD,KAAK,GAAG;AAAA,IAC/E;AAGA,UAAM,UAAU,MAAM,KAAK,WAAW,eAAe,KAAK;AAG1D,eAAW,QAAQ,OAAO;AAExB,YAAM,aAAa,KAAK,KAAK,YAAY,IAAI;AAC7C,YAAM,WAAW,KAAK,KAAK,SAAS,IAAI;AAGxC,YAAM,UAAU,KAAK,QAAQ,QAAQ;AACrC,YAAML,SAAG,MAAM,SAAS,EAAE,WAAW,MAAM;AAG3C,YAAMA,SAAG,SAAS,YAAY,QAAQ;AAAA,IACxC;AAGA,UAAM,KAAK,WAAW,QAAQ,SAAS,QAAQ;AAC/C,UAAM,gBAAgB;AAAA;AAAA,0BAA6C,WAAW;AAC9E,UAAM,KAAK,WAAW,QAAQ,SAAS,aAAa,KAAK,WAAW,UAAU,aAAa,CAAC,EAAE;AAE9F,UAAM,aAAa,MAAM,KAAK,WAAW,QAAQ,SAAS,gBAAgB;AAE1E,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IAAA;AAAA,EAEJ;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,wBAAwB,aAAa,UAAU,IAAI;AACvD,UAAM,WAAW,MAAM,KAAK,eAAe,qBAAqB,WAAW;AAC3E,QAAI,CAAC,UAAU;AACb,YAAM,IAAI,MAAM,cAAc,WAAW,aAAa;AAAA,IACxD;AAEA,UAAM,UAAU;AAAA,MACd,SAAS,CAAA;AAAA,MACT,QAAQ,CAAA;AAAA,MACR,SAAS,CAAA;AAAA,MACT,QAAQ,CAAA;AAAA,IAAC;AAIX,QAAI,SAAS,WAAW;AACtB,iBAAW,CAAC,OAAO,YAAY,KAAK,OAAO,QAAQ,SAAS,SAAS,GAAG;AACtE,YAAI;AACF,gBAAM,eAAe,MAAM,KAAK;AAAA,YAC9B;AAAA,YACA;AAAA,YACA,QAAQ,iBAAiB,0BAA0B,WAAW;AAAA,UAAA;AAEhE,kBAAQ,QAAQ,KAAK,IAAI;AAGzB,cAAI,aAAa,aAAa,QAAQ,UAAU,OAAO;AACrD,kBAAM,aAAa,MAAM,KAAK;AAAA,cAC5B;AAAA,cACA,aAAa;AAAA,YAAA;AAEf,oBAAQ,OAAO,KAAK,IAAI;AAAA,UAC1B;AAAA,QACF,SAAS,OAAO;AACd,kBAAQ,OAAO,KAAK,IAAI;AAAA,YACtB,OAAO,QAAQ,QAAQ,KAAK,IAAI,UAAU;AAAA,YAC1C,OAAO,MAAM;AAAA,UAAA;AAAA,QAEjB;AAAA,MACF;AAAA,IACF;AAGA,QAAI,SAAS,KAAK,UAAU,SAAS,KAAK,OAAO,SAAS,GAAG;AAC3D,iBAAW,SAAS,SAAS,KAAK,QAAQ;AACxC,YAAI;AACF,gBAAM,eAAe,MAAM,KAAK,iBAAiB,aAAa,KAAK;AACnE,kBAAQ,QAAQ,KAAK,IAAI;AAAA,QAC3B,SAAS,OAAO;AACd,kBAAQ,OAAO,KAAK,IAAI;AAAA,YACtB,OAAO;AAAA,YACP,OAAO,MAAM;AAAA,UAAA;AAAA,QAEjB;AAAA,MACF;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,uBAAuB,KAAK,WAAW,IAAI;AAC/C,UAAM,QAAQ,CAAA;AAEd,QAAI;AACF,YAAM,UAAU,MAAMA,SAAG,QAAQ,KAAK,EAAE,eAAe,MAAM;AAE7D,iBAAW,SAAS,SAAS;AAC3B,cAAM,WAAW,KAAK,KAAK,KAAK,MAAM,IAAI;AAC1C,cAAM,eAAe,KAAK,KAAK,UAAU,MAAM,IAAI;AAEnD,YAAI,MAAM,eAAe;AACvB,gBAAM,WAAW,MAAM,KAAK,uBAAuB,UAAU,YAAY;AACzE,gBAAM,KAAK,GAAG,QAAQ;AAAA,QACxB,OAAO;AACL,gBAAM,KAAK,YAAY;AAAA,QACzB;AAAA,MACF;AAAA,IACF,SAAS,OAAO;AACd,UAAI,MAAM,SAAS,UAAU;AAC3B,cAAM;AAAA,MACR;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AACF;AClQA,MAAMD,WAAS,aAAa,oBAAoB;AAEhD,MAAM,mBAAmB;AAAA,EACvB,YAAY,kBAAkBM,aAAY,gBAAgB,eAAe,IAAI;AAC3E,SAAK,mBAAmB;AACxB,SAAK,aAAaA;AAClB,SAAK,iBAAiB,kBAAkB,IAAI,wBAAwB,kBAAkBA,WAAU;AAChG,SAAK,gBAAgB,iBAAiB,IAAI,cAAc,kBAAkBA,aAAY,KAAK,cAAc;AACzG,SAAK,KAAK;AAAA,EACZ;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,0BAA0B,aAAa,UAAU,IAAI;AACzD,QAAI;AACFN,eAAO,KAAK,sCAAsC,WAAW,EAAE;AAG/D,YAAM,WAAW,MAAM,KAAK,eAAe,qBAAqB,WAAW;AAC3E,UAAI,CAAC,UAAU;AACbA,iBAAO,KAAK,mCAAmC,WAAW,EAAE;AAC5D,eAAO,EAAE,SAAS,OAAO,SAAS,8BAAA;AAAA,MACpC;AAGA,YAAM,UAAU,MAAM,KAAK,cAAc,wBAAwB,aAAa;AAAA,QAC5E,eAAe,QAAQ,iBAAiB,0BAA0B,WAAW;AAAA,QAC7E,OAAO,QAAQ,UAAU;AAAA,QACzB,eAAe,QAAQ,iBAAiB;AAAA,MAAA,CACzC;AAGD,YAAM,KAAK,kBAAkB,aAAa,OAAO;AAGjD,YAAM,kBAAkB,OAAO,OAAO,QAAQ,UAAU,EAAE,EAAE,KAAK,CAAA,MAAK,CAAC,EAAE,MAAM;AAC/E,UAAI,iBAAiB;AACnBA,iBAAO,KAAK,aAAa,WAAW,oBAAoB;AACxD,cAAM,KAAK,yBAAyB,aAAa,eAAe;AAGhE,cAAM,iBAAiB,OAAO,QAAQ,QAAQ,UAAU,CAAA,CAAE,EACvD,OAAO,CAAC,CAAC,OAAO,MAAM,MAAM,CAAC,OAAO,MAAM,EAC1C,OAAO,CAAC,KAAK,CAAC,OAAO,MAAM,MAAM;AAChC,cAAI,KAAK,IAAI;AAAA,YACX,OAAO,OAAO,SAAS;AAAA,YACvB,SAAS,OAAO,WAAW;AAAA,YAC3B,QAAQ,QAAQ,WAAW;AAAA,UAAA;AAE7B,iBAAO;AAAA,QACT,GAAG,CAAA,CAAE;AAGP,cAAM,KAAK,GAAG;AAAA,UACZ;AAAA,UACA,CAAC,KAAK,UAAU,cAAc,GAAG,WAAW;AAAA,QAAA;AAAA,MAEhD;AAGA,UAAI,QAAQ,YAAY,SAAS,CAAC,iBAAiB;AACjD,YAAI;AACF,gBAAM,KAAK,eAAe,0BAA0B,WAAW;AAC/DA,mBAAO,KAAK,sCAAsC,WAAW,EAAE;AAAA,QACjE,SAAS,OAAO;AACdA,mBAAO,MAAM,8CAA8C,WAAW,KAAK,KAAK;AAAA,QAElF;AAAA,MACF;AAEAA,eAAO,KAAK,uCAAuC,WAAW,IAAI,OAAO;AACzE,aAAO;AAAA,QACL,SAAS;AAAA,QACT;AAAA,MAAA;AAAA,IAGJ,SAAS,OAAO;AACdA,eAAO,MAAM,oCAAoC,WAAW,KAAK,KAAK;AACtE,aAAO;AAAA,QACL,SAAS;AAAA,QACT,OAAO,MAAM;AAAA,MAAA;AAAA,IAEjB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,kBAAkB,aAAa,SAAS;AAC5C,UAAM,UAAU,CAAA;AAGhB,eAAW,CAAC,OAAO,YAAY,KAAK,OAAO,QAAQ,QAAQ,WAAW,CAAA,CAAE,GAAG;AACzE,UAAI,aAAa,WAAW;AAC1B,gBAAQ,KAAK,KAAK,GAAG;AAAA,UACnB;AAAA;AAAA,UAEA,CAAC,aAAa,OAAO,UAAU,QAAQ,WAAW,IAAI,aAAa,MAAM,aAAa,OAAO;AAAA,QAAA,CAC9F;AAAA,MACH;AAAA,IACF;AAGA,eAAW,CAAC,OAAO,UAAU,KAAK,OAAO,QAAQ,QAAQ,UAAU,CAAA,CAAE,GAAG;AACtE,cAAQ,KAAK,KAAK,GAAG;AAAA,QACnB;AAAA;AAAA,QAEA;AAAA,UAAC;AAAA,UAAa;AAAA,UAAO;AAAA,UAAS,QAAQ,WAAW;AAAA,UAAI,WAAW,kBAAkB;AAAA,UACjF,WAAW,SAAS,YAAY;AAAA,QAAA;AAAA,MAAQ,CAC1C;AAAA,IACH;AAGA,eAAW,CAAC,OAAO,YAAY,KAAK,OAAO,QAAQ,QAAQ,WAAW,CAAA,CAAE,GAAG;AACzE,cAAQ,KAAK,KAAK,GAAG;AAAA,QACnB;AAAA;AAAA,QAEA,CAAC,aAAa,OAAO,UAAU,aAAa,YAAY;AAAA;AAAA,0BAA6C,WAAW,EAAE;AAAA,MAAA,CACnH;AAAA,IACH;AAEA,UAAM,QAAQ,IAAI,OAAO;AAAA,EAC3B;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,yBAAyB,aAAa,QAAQ;AAClD,QAAI;AACF,YAAM,KAAK,GAAG;AAAA,QACZ;AAAA,QACA,CAAC,gBAAgB,QAAQ,WAAW;AAAA,MAAA;AAEtCA,eAAO,KAAK,oBAAoB,WAAW,uBAAuB,MAAM,EAAE;AAAA,IAC5E,SAAS,OAAO;AACdA,eAAO,MAAM,4BAA4B,WAAW,uBAAuB,KAAK;AAChF,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,qBAAqB,aAAa;AACtC,UAAM,UAAU,MAAM,KAAK,GAAG;AAAA,MAC5B;AAAA,MACA,CAAC,WAAW;AAAA,IAAA;AAGd,UAAM,OAAO,MAAM,KAAK,GAAG;AAAA,MACzB;AAAA,MACA,CAAC,WAAW;AAAA,IAAA;AAGd,WAAO;AAAA,MACL;AAAA,MACA,MAAM,KAAK,OAAO,CAAC,KAAK,QAAQ;AAC9B,YAAI,CAAC,IAAI,IAAI,MAAM,GAAG;AACpB,cAAI,IAAI,MAAM,IAAI,EAAE,aAAa,CAAA,EAAC;AAAA,QACpC;AACA,YAAI,IAAI,MAAM,EAAE,YAAY,KAAK,IAAI,UAAU;AAC/C,eAAO;AAAA,MACT,GAAG,CAAA,CAAE;AAAA,MACL,SAAS,QAAQ,OAAO,CAAC,KAAK,WAAW;AACvC,YAAI,CAAC,IAAI,OAAO,MAAM,GAAG;AACvB,cAAI,OAAO,MAAM,IAAI,CAAA;AAAA,QACvB;AACA,YAAI,OAAO,MAAM,EAAE,KAAK;AAAA,UACtB,MAAM,OAAO;AAAA,UACb,QAAQ,OAAO;AAAA,UACf,QAAQ,OAAO;AAAA,UACf,SAAS,OAAO;AAAA,UAChB,aAAa,OAAO;AAAA,UACpB,WAAW,OAAO;AAAA,QAAA,CACnB;AACD,eAAO;AAAA,MACT,GAAG,CAAA,CAAE;AAAA,IAAA;AAAA,EAET;AACF;ACpLA,MAAMA,WAAS,aAAa,iBAAiB;AAE7C,MAAM,gBAAgB;AAAA,EACpB,YAAY,kBAAkB,IAAI,UAAU,CAAA,GAAI;AAC9C,SAAK,mBAAmB;AACxB,SAAK,KAAK;AAGV,SAAK,SAAS;AAAA,MACZ,yBAAyB,QAAQ,2BAA2B;AAAA,MAC5D,gBAAgB,QAAQ,kBAAkB;AAAA;AAAA,MAC1C,yBAAyB,QAAQ,2BAA2B;AAAA,MAC5D,qBAAqB,QAAQ,uBAAuB;AAAA,IAAA;AAItD,SAAK,oBAAoB;AACzB,SAAK,gBAAgB,QAAQ,iBAAiB;AAC9C,SAAK,aAAa;AAAA,EACpB;AAAA;AAAA;AAAA;AAAA,EAKA,QAAQ;AACN,QAAI,KAAK,YAAY;AACnBA,eAAO,KAAK,qCAAqC;AACjD;AAAA,IACF;AAEAA,aAAO,KAAK,6CAA6C,KAAK,MAAM;AACpE,SAAK,aAAa,YAAY,MAAM;AAClC,WAAK,qBAAA,EAAuB,MAAM,CAAA,UAAS;AACzCA,iBAAO,MAAM,0BAA0B,KAAK;AAAA,MAC9C,CAAC;AAAA,IACH,GAAG,KAAK,aAAa;AAAA,EACvB;AAAA;AAAA;AAAA;AAAA,EAKA,OAAO;AACL,QAAI,KAAK,YAAY;AACnB,oBAAc,KAAK,UAAU;AAC7B,WAAK,aAAa;AAClBA,eAAO,KAAK,6BAA6B;AAAA,IAC3C;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,oBAAoB;AACxB,UAAM,SAAS,MAAM,QAAQ,IAAI;AAAA,MAC/B,KAAK,0BAAA;AAAA,MACL,KAAK,eAAA;AAAA,MACL,KAAK,qBAAA;AAAA,IAAqB,CAC3B;AAED,YAAQ,IAAI,oBAAoB,MAAM;AAEtC,WAAO,OAAO,MAAM,CAAA,UAAS,MAAM,OAAO;AAAA,EAC5C;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,4BAA4B;;AAChC,QAAI;AACF,YAAM,oBAAoB,MAAM,KAAK,GAAG;AAAA,QACtC;AAAA,MAAA;AAGF,YAAM,iBAAe,uBAAkB,CAAC,MAAnB,mBAAsB,UAAS;AACpD,YAAM,UAAU,eAAe,KAAK,OAAO;AAE3C,aAAO;AAAA,QACL,MAAM;AAAA,QACN;AAAA,QACA,SAAS;AAAA,QACT,OAAO,KAAK,OAAO;AAAA,QACnB,SAAS,UAAU,OAAO,kCAAkC,KAAK,OAAO,uBAAuB;AAAA,MAAA;AAAA,IAEnG,SAAS,OAAO;AACdA,eAAO,MAAM,0CAA0C,KAAK;AAC5D,aAAO,EAAE,MAAM,yBAAyB,SAAS,OAAO,OAAO,MAAM,QAAA;AAAA,IACvE;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,iBAAiB;AACrB,QAAI;AACF,YAAM,gBAAgB,KAAK,iBAAiB,iBAAA;AAC5C,YAAM,QAAQ,MAAM,KAAK,uBAAuB,aAAa;AAC7D,YAAM,UAAU,SAAS,OAAO;AAChC,YAAM,UAAU,UAAU,KAAK,OAAO;AAEtC,aAAO;AAAA,QACL,MAAM;AAAA,QACN;AAAA,QACA,SAAS;AAAA,QACT,OAAO,KAAK,OAAO;AAAA,QACnB,SAAS,UAAU,OAAO,eAAe,QAAQ,QAAQ,CAAC,CAAC,sBAAsB,KAAK,OAAO,cAAc;AAAA,MAAA;AAAA,IAE/G,SAAS,OAAO;AACdA,eAAO,MAAM,+BAA+B,KAAK;AACjD,aAAO,EAAE,MAAM,cAAc,SAAS,MAAM,OAAO,MAAM,QAAA;AAAA,IAC3D;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,uBAAuB;AAC3B,QAAI;AACF,YAAM,WAAW,QAAQ,YAAA;AACzB,YAAM,aAAa,SAAS,YAAY,OAAO;AAG/C,YAAM,WAAW,aAAa;AAE9B,aAAO;AAAA,QACL,MAAM;AAAA,QACN,SAAS;AAAA,QACT,QAAQ;AAAA,UACN,UAAU;AAAA,UACV,WAAW,SAAS,aAAa,OAAO;AAAA,UACxC,UAAU,SAAS,YAAY,OAAO;AAAA,QAAA;AAAA,QAExC,SAAS,WAAW,OAAO,sBAAsB,WAAW,QAAQ,CAAC,CAAC;AAAA,MAAA;AAAA,IAE1E,SAAS,OAAO;AACdA,eAAO,MAAM,qCAAqC,KAAK;AACvD,aAAO,EAAE,MAAM,oBAAoB,SAAS,MAAM,OAAO,MAAM,QAAA;AAAA,IACjE;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,uBAAuB;AAC3BA,aAAO,MAAM,2BAA2B;AAExC,QAAI;AAEF,YAAM,SAAS,MAAM,QAAQ,IAAI;AAAA,QAC/B,KAAK,0BAAA;AAAA,QACL,KAAK,eAAA;AAAA,QACL,KAAK,qBAAA;AAAA,MAAqB,CAC3B;AAGD,aAAO,QAAQ,CAAA,UAAS;AACtB,YAAI,CAAC,MAAM,WAAW,MAAM,SAAS;AACnCA,mBAAO,KAAK,2BAA2B,MAAM,OAAO,EAAE;AAAA,QACxD;AAAA,MACF,CAAC;AAGD,YAAM,KAAK,2BAAA;AAGX,YAAM,KAAK,qBAAA;AAAA,IAEb,SAAS,OAAO;AACdA,eAAO,MAAM,0BAA0B,KAAK;AAAA,IAC9C;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,6BAA6B;AACjC,QAAI;AACF,YAAM,aAAa,IAAI,KAAK,KAAK,IAAA,IAAS,KAAK,OAAO,0BAA0B,KAAK,GAAK;AAC1F,YAAM,cAAc,MAAM,KAAK,GAAG;AAAA,QAChC;AAAA,QACA,CAAC,WAAW,YAAA,CAAa;AAAA,MAAA;AAG3B,UAAI,YAAY,SAAS,GAAG;AAC1BA,iBAAO,KAAK,SAAS,YAAY,MAAM,0BAA0B;AAEjE,mBAAW,aAAa,aAAa;AACnCA,mBAAO,KAAK,aAAa,UAAU,EAAE,2BAA2B,UAAU,UAAU,EAAE;AAGtF,gBAAM,KAAK,GAAG;AAAA,YACZ;AAAA,YACA,CAAC,4BAA4B,KAAK,OAAO,uBAAuB,aAAa,UAAU,EAAE;AAAA,UAAA;AAAA,QAE7F;AAAA,MACF;AAAA,IACF,SAAS,OAAO;AACdA,eAAO,MAAM,4CAA4C,KAAK;AAAA,IAChE;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,uBAAuB;AAC3B,QAAI;AACF,YAAM,aAAa,IAAI,KAAK,KAAK,IAAA,IAAS,KAAK,OAAO,sBAAsB,KAAK,KAAK,KAAK,GAAK;AAChG,YAAM,gBAAgB,KAAK,KAAK,KAAK,iBAAiB,iBAAA,GAAoB,YAAY;AAEtF,UAAI,CAAC,MAAM,KAAK,OAAO,aAAa,GAAG;AACrC;AAAA,MACF;AAEA,YAAM,UAAU,MAAMC,SAAG,QAAQ,eAAe,EAAE,eAAe,MAAM;AACvE,UAAI,eAAe;AAEnB,iBAAW,SAAS,SAAS;AAC3B,YAAI,MAAM,iBAAiB,MAAM,KAAK,WAAW,OAAO,GAAG;AACzD,gBAAM,gBAAgB,KAAK,KAAK,eAAe,MAAM,IAAI;AACzD,gBAAM,OAAO,MAAMA,SAAG,KAAK,aAAa;AAExC,cAAI,KAAK,QAAQ,YAAY;AAC3B,kBAAM,cAAc,MAAM,KAAK,UAAU,CAAC;AAG1C,kBAAM,YAAY,MAAM,KAAK,GAAG;AAAA,cAC9B;AAAA,cACA,CAAC,WAAW;AAAA,YAAA;AAGd,gBAAI,CAAC,aAAa,CAAC,aAAa,UAAU,aAAa,EAAE,SAAS,UAAU,MAAM,GAAG;AACnFD,uBAAO,KAAK,8BAA8B,MAAM,IAAI,EAAE;AACtD,oBAAMC,SAAG,GAAG,eAAe,EAAE,WAAW,MAAM,OAAO,MAAM;AAC3D;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAEA,UAAI,eAAe,GAAG;AACpBD,iBAAO,KAAK,cAAc,YAAY,4BAA4B;AAAA,MACpE;AAAA,IACF,SAAS,OAAO;AACdA,eAAO,MAAM,qCAAqC,KAAK;AAAA,IACzD;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,uBAAuB,SAAS;AACpC,QAAI,YAAY;AAEhB,QAAI;AACF,YAAM,UAAU,MAAMC,SAAG,QAAQ,SAAS,EAAE,eAAe,MAAM;AAEjE,iBAAW,SAAS,SAAS;AAC3B,cAAM,WAAW,KAAK,KAAK,SAAS,MAAM,IAAI;AAE9C,YAAI,MAAM,eAAe;AACvB,uBAAa,MAAM,KAAK,uBAAuB,QAAQ;AAAA,QACzD,OAAO;AACL,gBAAM,OAAO,MAAMA,SAAG,KAAK,QAAQ;AACnC,uBAAa,KAAK;AAAA,QACpB;AAAA,MACF;AAAA,IACF,SAAS,OAAO;AACdD,eAAO,MAAM,wCAAwC,OAAO,KAAK,MAAM,OAAO;AAAA,IAChF;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,OAAO,UAAU;AACrB,QAAI;AACF,YAAMC,SAAG,OAAO,QAAQ;AACxB,aAAO;AAAA,IACT,QAAQ;AACN,aAAO;AAAA,IACT;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,oBAAoB;AACxB,UAAM,SAAS,MAAM,QAAQ,IAAI;AAAA,MAC/B,KAAK,0BAAA;AAAA,MACL,KAAK,eAAA;AAAA,MACL,KAAK,qBAAA;AAAA,IAAqB,CAC3B;AAED,WAAO;AAAA,MACL,YAAW,oBAAI,KAAA,GAAO,YAAA;AAAA,MACtB,QAAQ,KAAK;AAAA,MACb,OAAO,OAAO,OAAO,CAAC,KAAK,UAAU;AACnC,YAAI,MAAM,IAAI,IAAI;AAClB,eAAO;AAAA,MACT,GAAG,CAAA,CAAE;AAAA,MACL,SAAS,OAAO,MAAM,CAAA,UAAS,MAAM,OAAO;AAAA,IAAA;AAAA,EAEhD;AACF;AClTA,MAAMD,WAAS,aAAa,aAAa;AAEzC,MAAM,YAAY;AAAA,EAChB,YAAY,IAAI;AACd,SAAK,KAAK;AAAA,EACZ;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,gBAAgB,eAAe;AACnC,UAAM;AAAA,MACJ,cAAc;AAAA,MACd;AAAA,MACA;AAAA;AAAA,MACA,SAAS;AAAA,MACT;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,SAAS;AAAA,MACT,QAAQ;AAAA,MACR,WAAW,CAAA;AAAA,IAAC,IACV;AAEJ,QAAI;AACF,YAAM,KAAK,GAAG,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAMf;AAAA,QACD;AAAA,QAAa;AAAA,QAAO;AAAA,QAAW;AAAA,QAAQ;AAAA,QACvC;AAAA,QAAY,UAAU,IAAI;AAAA,QAAG;AAAA,QAAU;AAAA,QAAQ;AAAA,QAC/C,KAAK,UAAU,QAAQ;AAAA,MAAA,CACxB;AAEDA,eAAO,KAAK,yBAAyB,SAAS,OAAO,KAAK,IAAI;AAAA,QAC5D;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA,UAAU,GAAG,QAAQ;AAAA,MAAA,CACtB;AAAA,IAEH,SAAS,SAAS;AAChBA,eAAO,MAAM,gCAAgC,OAAO;AAAA,IACtD;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,kBAAkB,WAAW;AACjC,UAAM;AAAA,MACJ;AAAA,MACA;AAAA;AAAA,MACA,QAAQ;AAAA;AAAA,MACR,UAAU,CAAA;AAAA,MACV,UAAU;AAAA,MACV,WAAW;AAAA,MACX,QAAQ;AAAA,IAAA,IACN;AAEJ,QAAI;AACF,YAAM,KAAK,GAAG,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA,SAKf;AAAA,QACD;AAAA,QAAa;AAAA,QAAO;AAAA,QAAO,KAAK,UAAU,OAAO;AAAA,QACjD,UAAU,IAAI;AAAA,QAAG;AAAA,QAAU;AAAA,MAAA,CAC5B;AAEDA,eAAO,KAAK,2BAA2B,KAAK,IAAI;AAAA,QAC9C;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MAAA,CACD;AAAA,IAEH,SAAS,SAAS;AAChBA,eAAO,MAAM,kCAAkC,OAAO;AAAA,IACxD;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,iBAAiB,WAAW;AAChC,UAAM;AAAA,MACJ;AAAA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,cAAc;AAAA,MACd,UAAU,CAAA;AAAA,IAAC,IACT;AAEJ,QAAI;AACF,YAAM,KAAK,GAAG,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA,SAKf;AAAA,QACD;AAAA,QAAM;AAAA,QAAc;AAAA,QAAY,WAAW,IAAI;AAAA,QAC/C;AAAA,QAAa,KAAK,UAAU,OAAO;AAAA,MAAA,CACpC;AAED,UAAI,UAAU;AACZA,iBAAO,KAAK,4BAA4B,IAAI,IAAI;AAAA,UAC9C;AAAA,UACA,SAAS;AAAA,UACT,OAAO;AAAA,UACP;AAAA,QAAA,CACD;AAAA,MACH,OAAO;AACLA,iBAAO,MAAM,0BAA0B,IAAI,IAAI;AAAA,UAC7C;AAAA,UACA,SAAS;AAAA,UACT,OAAO;AAAA,QAAA,CACR;AAAA,MACH;AAAA,IAEF,SAAS,SAAS;AAChBA,eAAO,MAAM,iCAAiC,OAAO;AAAA,IACvD;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,qBAAqB,YAAY;AACrC,UAAM;AAAA,MACJ,cAAc;AAAA,MACd;AAAA;AAAA,MACA;AAAA,MACA;AAAA,MACA,WAAW,CAAA;AAAA,IAAC,IACV;AAEJ,QAAI;AACF,YAAM,KAAK,GAAG,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA,SAKf;AAAA,QACD;AAAA,QAAa;AAAA,QAAW;AAAA,QAAU,UAAU,IAAI;AAAA,QAChD,KAAK,UAAU,QAAQ;AAAA,MAAA,CACxB;AAGD,UAAI,WAAW,KAAM;AACnBA,iBAAO,KAAK,4BAA4B,SAAS,IAAI;AAAA,UACnD;AAAA,UACA;AAAA,UACA,UAAU,GAAG,QAAQ;AAAA,UACrB;AAAA,QAAA,CACD;AAAA,MACH,OAAO;AACLA,iBAAO,MAAM,8BAA8B,SAAS,IAAI;AAAA,UACtD,UAAU,GAAG,QAAQ;AAAA,UACrB;AAAA,QAAA,CACD;AAAA,MACH;AAAA,IAEF,SAAS,SAAS;AAChBA,eAAO,MAAM,qCAAqC,OAAO;AAAA,IAC3D;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,uBAAuB,aAAa;AACxC,QAAI;AACF,YAAM,CAAC,QAAQ,QAAQ,WAAW,WAAW,IAAI,MAAM,QAAQ,IAAI;AAAA,QACjE,KAAK,GAAG,IAAI;AAAA;AAAA;AAAA;AAAA,WAIT,CAAC,WAAW,CAAC;AAAA,QAEhB,KAAK,GAAG,IAAI;AAAA;AAAA;AAAA;AAAA,WAIT,CAAC,WAAW,CAAC;AAAA,QAEhB,KAAK,GAAG,IAAI;AAAA;AAAA;AAAA;AAAA,WAIT,CAAC,WAAW,CAAC;AAAA,QAEhB,KAAK,GAAG,IAAI;AAAA;AAAA;AAAA;AAAA,WAIT,CAAC,WAAW,CAAC;AAAA,MAAA,CACjB;AAED,aAAO;AAAA,QACL;AAAA,QACA,eAAe,OAAO,IAAI,KAAK,cAAc;AAAA,QAC7C,QAAQ,OAAO,IAAI,KAAK,cAAc;AAAA,QACtC,eAAe,UAAU,IAAI,KAAK,cAAc;AAAA,QAChD,oBAAoB,YAAY,IAAI,KAAK,cAAc;AAAA,MAAA;AAAA,IAG3D,SAAS,OAAO;AACdA,eAAO,MAAM,2CAA2C,WAAW,KAAK,KAAK;AAC7E,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,iBAAiB,aAAa,YAAY;AAC9C,QAAI;AACF,YAAM,CAAC,YAAY,gBAAgB,eAAe,SAAS,IAAI,MAAM,QAAQ,IAAI;AAAA,QAC/E,KAAK,GAAG,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,gDAQ4B,UAAU;AAAA;AAAA,SAEjD;AAAA,QAED,KAAK,GAAG,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,gDAQ4B,UAAU;AAAA;AAAA,SAEjD;AAAA,QAED,KAAK,GAAG,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,gDAO4B,UAAU;AAAA;AAAA,SAEjD;AAAA,QAED,KAAK,GAAG,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,gDAQ4B,UAAU;AAAA;AAAA,SAEjD;AAAA,MAAA,CACF;AAED,aAAO;AAAA,QACL;AAAA,QACA,eAAe;AAAA,QACf,iBAAiB;AAAA,QACjB,eAAe;AAAA,QACf,aAAa;AAAA,QACb,cAAa,oBAAI,KAAA,GAAO,YAAA;AAAA,MAAY;AAAA,IAGxC,SAAS,OAAO;AACdA,eAAO,MAAM,iCAAiC,KAAK;AACnD,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,eAAe,QAAQ;AACrB,UAAM,SAAS,EAAE,GAAG,OAAA;AAGpB,KAAC,YAAY,SAAS,EAAE,QAAQ,CAAA,UAAS;AACvC,UAAI,OAAO,KAAK,GAAG;AACjB,YAAI;AACF,iBAAO,KAAK,IAAI,KAAK,MAAM,OAAO,KAAK,CAAC;AAAA,QAC1C,SAAS,GAAG;AACVA,mBAAO,KAAK,mBAAmB,KAAK,mBAAmB,CAAC;AAAA,QAC1D;AAAA,MACF;AAAA,IACF,CAAC;AAED,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,eAAe,gBAAgB,IAAI;AACvC,UAAM,aAAa,qBAAqB,aAAa;AAErD,QAAI;AACF,YAAM,UAAU,MAAM,QAAQ,IAAI;AAAA,QAChC,KAAK,GAAG,IAAI,oDAAoD,UAAU,EAAE;AAAA,QAC5E,KAAK,GAAG,IAAI,sDAAsD,UAAU,EAAE;AAAA,QAC9E,KAAK,GAAG,IAAI,gDAAgD,UAAU,EAAE;AAAA,QACxE,KAAK,GAAG,IAAI,qDAAqD,UAAU,EAAE;AAAA,MAAA,CAC9E;AAED,YAAM,eAAe,QAAQ,OAAO,CAAC,KAAK,WAAW,OAAO,OAAO,WAAW,IAAI,CAAC;AAEnFA,eAAO,KAAK,cAAc,YAAY,qCAAqC,aAAa,OAAO;AAE/F,aAAO,EAAE,gBAAgB,cAAc,cAAA;AAAA,IAEzC,SAAS,OAAO;AACdA,eAAO,MAAM,qCAAqC,KAAK;AACvD,YAAM;AAAA,IACR;AAAA,EACF;AACF;AC9UA,MAAMA,WAAS,aAAa,oBAAoB;AAEhD,MAAM,mBAAmB;AAAA,EACvB,YAAY,cAAc,MAAM;AAC9B,SAAK,cAAc;AACnB,SAAK,uCAAuB,IAAA;AAC5B,SAAK,UAAU;AAAA,MACb,qCAAqB,IAAA;AAAA,MACrB,sCAAsB,IAAA;AAAA,MACtB,iCAAiB,IAAA;AAAA,IAAI;AAAA,EAEzB;AAAA;AAAA;AAAA;AAAA,EAKA,YAAY,aAAa,WAAW,WAAW,CAAA,GAAI;AACjD,UAAM,YAAY,KAAK,IAAA;AAEvB,SAAK,iBAAiB,IAAI,aAAa;AAAA,MACrC;AAAA,MACA;AAAA,MACA;AAAA,IAAA,CACD;AAEDA,aAAO,MAAM,6BAA6B,SAAS,IAAI;AAAA,MACrD;AAAA,MACA;AAAA,MACA;AAAA,IAAA,CACD;AAED,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,UAAU,aAAa,UAAU,MAAM,QAAQ,MAAM,qBAAqB,IAAI;AAClF,UAAM,gBAAgB,KAAK,iBAAiB,IAAI,WAAW;AAE3D,QAAI,CAAC,eAAe;AAClBA,eAAO,KAAK,aAAa,WAAW,iCAAiC;AACrE,aAAO;AAAA,IACT;AAEA,UAAM,UAAU,KAAK,IAAA;AACrB,UAAM,WAAW,UAAU,cAAc;AAGzC,SAAK,cAAc,cAAc,WAAW,UAAU,OAAO;AAG7D,QAAI,KAAK,aAAa;AACpB,YAAM,cAAc,cAAc,SAAS,eAAe;AAE1D,YAAM,KAAK,YAAY,qBAAqB;AAAA,QAC1C;AAAA,QACA,WAAW,cAAc;AAAA,QACzB;AAAA,QACA;AAAA,QACA,UAAU;AAAA,UACR,GAAG,cAAc;AAAA,UACjB,GAAG;AAAA,UACH,QAAO,+BAAO,YAAW;AAAA,QAAA;AAAA,MAC3B,CACD;AAAA,IACH;AAGA,SAAK,iBAAiB,OAAO,WAAW;AAExCA,aAAO,MAAM,+BAA+B,cAAc,SAAS,IAAI;AAAA,MACrE;AAAA,MACA,WAAW,cAAc;AAAA,MACzB,UAAU,GAAG,QAAQ;AAAA,MACrB;AAAA,IAAA,CACD;AAED,WAAO;AAAA,MACL,WAAW,cAAc;AAAA,MACzB;AAAA,MACA;AAAA,MACA,UAAU,EAAE,GAAG,cAAc,UAAU,GAAG,mBAAA;AAAA,IAAmB;AAAA,EAEjE;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,WAAW,WAAW,IAAI,WAAW,CAAA,GAAI;AAC7C,UAAM,cAAc,KAAK,oBAAA;AAEzB,SAAK,YAAY,aAAa,WAAW,QAAQ;AAEjD,QAAI;AACF,YAAM,SAAS,MAAM,GAAA;AACrB,YAAM,KAAK,UAAU,aAAa,MAAM,MAAM,EAAE,YAAY,OAAO,QAAQ;AAC3E,aAAO;AAAA,IACT,SAAS,OAAO;AACd,YAAM,KAAK,UAAU,aAAa,OAAO,KAAK;AAC9C,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,uBAAuB,kBAAkB,IAAI;AACjD,UAAM;AAAA,MACJ;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IAAA,IACE;AAEJ,UAAM,cAAc,KAAK,oBAAA;AACzB,UAAM,YAAY,KAAK,IAAA;AAEvB,SAAK,YAAY,aAAa,OAAO,SAAS,IAAI;AAAA,MAChD;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IAAA,CACD;AAED,QAAI,SAAS;AACb,QAAI,QAAQ;AACZ,QAAI,UAAU;AAEd,QAAI;AACF,eAAS,MAAM,GAAA;AACf,gBAAU;AACV,aAAO;AAAA,IACT,SAAS,KAAK;AACZ,cAAQ;AACR,gBAAU;AACV,YAAM;AAAA,IACR,UAAA;AACE,YAAM,WAAW,KAAK,IAAA,IAAQ;AAG9B,UAAI,KAAK,aAAa;AACpB,cAAM,KAAK,YAAY,gBAAgB;AAAA,UACrC,GAAG;AAAA,UACH;AAAA,UACA;AAAA,UACA,QAAQ,OAAO,WAAW,WAAW,SAAS;AAAA,UAC9C,QAAO,+BAAO,YAAW;AAAA,UACzB,UAAU;AAAA,YACR,eAAe,QAAQ;AAAA,YACvB,WAAW,CAAC,CAAC;AAAA,UAAA;AAAA,QACf,CACD;AAAA,MACH;AAEA,YAAM,KAAK,UAAU,aAAa,SAAS,KAAK;AAAA,IAClD;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,cAAc,WAAW,UAAU,SAAS;AAE1C,UAAM,eAAe,KAAK,QAAQ,gBAAgB,IAAI,SAAS,KAAK;AACpE,SAAK,QAAQ,gBAAgB,IAAI,WAAW,eAAe,CAAC;AAG5D,UAAM,aAAa,KAAK,QAAQ,iBAAiB,IAAI,SAAS,KAAK,EAAE,OAAO,GAAG,OAAO,EAAA;AACtF,eAAW,SAAS;AACpB,eAAW,SAAS;AACpB,SAAK,QAAQ,iBAAiB,IAAI,WAAW,UAAU;AAGvD,QAAI,CAAC,SAAS;AACZ,YAAM,gBAAgB,KAAK,QAAQ,YAAY,IAAI,SAAS,KAAK;AACjE,WAAK,QAAQ,YAAY,IAAI,WAAW,gBAAgB,CAAC;AAAA,IAC3D;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,aAAa;AACX,UAAM,UAAU,CAAA;AAEhB,eAAW,CAAC,WAAW,KAAK,KAAK,KAAK,QAAQ,iBAAiB;AAC7D,YAAM,UAAU,KAAK,QAAQ,iBAAiB,IAAI,SAAS,KAAK,EAAE,OAAO,GAAG,OAAO,EAAA;AACnF,YAAM,aAAa,KAAK,QAAQ,YAAY,IAAI,SAAS,KAAK;AAE9D,cAAQ,SAAS,IAAI;AAAA,QACnB,iBAAiB;AAAA,QACjB,iBAAiB,QAAQ,QAAQ,IAAI,KAAK,MAAM,QAAQ,QAAQ,QAAQ,KAAK,IAAI;AAAA,QACjF,eAAe,QAAQ;AAAA,QACvB;AAAA,QACA,aAAa,QAAQ,MAAM,QAAQ,cAAc,QAAQ,KAAK,QAAQ,CAAC,IAAI,MAAM;AAAA,MAAA;AAAA,IAErF;AAEA,WAAO;AAAA,MACL;AAAA,MACA,kBAAkB,KAAK,iBAAiB;AAAA,MACxC,cAAa,oBAAI,KAAA,GAAO,YAAA;AAAA,IAAY;AAAA,EAExC;AAAA;AAAA;AAAA;AAAA,EAKA,kBAAkB,cAAc,KAAM;AACpC,UAAM,UAAU,CAAA;AAEhB,eAAW,CAAC,WAAW,OAAO,KAAK,KAAK,QAAQ,kBAAkB;AAChE,YAAM,cAAc,QAAQ,QAAQ,IAAI,QAAQ,QAAQ,QAAQ,QAAQ;AAExE,UAAI,cAAc,aAAa;AAC7B,gBAAQ,KAAK;AAAA,UACX;AAAA,UACA,iBAAiB,KAAK,MAAM,WAAW;AAAA,UACvC,iBAAiB,QAAQ;AAAA,UACzB,eAAe,QAAQ;AAAA,QAAA,CACxB;AAAA,MACH;AAAA,IACF;AAEA,WAAO,QAAQ,KAAK,CAAC,GAAG,MAAM,EAAE,kBAAkB,EAAE,eAAe;AAAA,EACrE;AAAA;AAAA;AAAA;AAAA,EAKA,eAAe;AACb,SAAK,UAAU;AAAA,MACb,qCAAqB,IAAA;AAAA,MACrB,sCAAsB,IAAA;AAAA,MACtB,iCAAiB,IAAA;AAAA,IAAI;AAGvBA,aAAO,KAAK,2BAA2B;AAAA,EACzC;AAAA;AAAA;AAAA;AAAA,EAKA,sBAAsB;AACpB,WAAO,MAAM,KAAK,IAAA,CAAK,IAAI,KAAK,OAAA,EAAS,SAAS,EAAE,EAAE,OAAO,GAAG,CAAC,CAAC;AAAA,EACpE;AAAA;AAAA;AAAA;AAAA,EAKA,sBAAsB;AACpB,UAAM,aAAa,CAAA;AACnB,UAAM,MAAM,KAAK,IAAA;AAEjB,eAAW,CAAC,aAAa,IAAI,KAAK,KAAK,kBAAkB;AACvD,iBAAW,KAAK;AAAA,QACd;AAAA,QACA,WAAW,KAAK;AAAA,QAChB,UAAU,MAAM,KAAK;AAAA,QACrB,UAAU,KAAK;AAAA,MAAA,CAChB;AAAA,IACH;AAEA,WAAO,WAAW,KAAK,CAAC,GAAG,MAAM,EAAE,WAAW,EAAE,QAAQ;AAAA,EAC1D;AAAA;AAAA;AAAA;AAAA,EAKA,mBAAmB,cAAc,KAAQ;AACvC,UAAM,MAAM,KAAK,IAAA;AACjB,UAAM,WAAW,CAAA;AAEjB,eAAW,CAAC,aAAa,IAAI,KAAK,KAAK,kBAAkB;AACvD,YAAM,WAAW,MAAM,KAAK;AAC5B,UAAI,WAAW,aAAa;AAC1B,iBAAS,KAAK;AAAA,UACZ;AAAA,UACA,WAAW,KAAK;AAAA,UAChB;AAAA,UACA,WAAW,IAAI,KAAK,KAAK,SAAS,EAAE,YAAA;AAAA,UACpC,UAAU,KAAK;AAAA,QAAA,CAChB;AAAA,MACH;AAAA,IACF;AAEA,QAAI,SAAS,SAAS,GAAG;AACvBA,eAAO,KAAK,SAAS,SAAS,MAAM,iCAAiC,EAAE,UAAU;AAAA,IACnF;AAEA,WAAO;AAAA,EACT;AACF;AChSA,IAAI;AAEJ,MAAMA,WAAS,aAAa,kBAAkB;AAE9C,MAAM,iBAAiB;AAAA,EACrB,YAAY,IAAIG,SAAQ,cAAc,kBAAkB;AACtD,SAAK,KAAK;AACV,SAAK,SAASA;AACd,SAAK,eAAe;AACpB,SAAK,mBAAmB;AACxB,SAAK,qCAAqB,IAAA;AAC1B,SAAK,sCAAsB,IAAA;AAC3B,SAAK,YAAY;AACjB,SAAK,QAAA;AAAA,EACP;AAAA,EAEA,MAAM,UAAU;AACd,QAAI;AACF,YAAM,YAAY,MAAM,OAAO,2BAA2B;AAC1D,cAAQ,UAAU;AAClB,WAAK,YAAY;AACjBH,eAAO,KAAK,gCAAgC;AAAA,IAC9C,SAAS,OAAO;AACdA,eAAO,MAAM,6BAA6B,EAAE,MAAA,CAAO;AACnD,YAAM,IAAI,MAAM,0BAA0B;AAAA,IAC5C;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,gBAAgB,aAAa,OAAO,SAAS;AACjD,UAAM,eAAe;AAAA,MACnB,MAAM;AAAA,MACN,SAAS;AAAA,MACT;AAAA,MACA;AAAA,MACA,YAAW,oBAAI,KAAA,GAAO,YAAA;AAAA,IAAY;AAIpC,UAAM,KAAK,GAAG;AAAA,MACZ;AAAA,MACA,CAAC,aAAa,QAAQ,QAAQ,KAAK,UAAU,YAAY,CAAC;AAAA,IAAA;AAI5D,SAAK,aAAa,KAAK,OAAO,WAAW;AAAA,MACvC;AAAA,MACA,WAAW,aAAa;AAAA,MACxB,MAAM,QAAQ;AAAA,MACd,SAAS,KAAK,UAAU,YAAY;AAAA,IAAA,CACrC;AAEDA,aAAO,KAAK,wBAAwB,EAAE,aAAa,OAAO,SAAS;AAAA,EACrE;AAAA,EAEA,MAAM,gBAAgB,aAAa;AACjC,UAAM,KAAK,GAAG;AAAA,MACZ;AAAA,MACA,CAAC,WAAW;AAAA,IAAA;AAAA,EAEhB;AAAA,EAEA,MAAM,eAAe,aAAa,QAAQ,YAAY,UAAU,CAAA,GAAI;AAElE,QAAI,CAAC,KAAK,WAAW;AACnB,YAAM,KAAK,QAAA;AAAA,IACb;AAGA,QAAI,KAAK,eAAe,IAAI,WAAW,GAAG;AACxC,UAAI,QAAQ,UAAU;AACpBA,iBAAO,KAAK,2CAA2C,EAAE,YAAA,CAAa;AAAA,MACxE,OAAO;AACLA,iBAAO,KAAK,+EAA+E,EAAE,YAAA,CAAa;AAAA,MAC5G;AACA,YAAM,KAAK,cAAc,WAAW;AAAA,IACtC;AAEA,QAAI;AAEF,YAAM,gBAAgB,KAAK,mBAAmB,KAAK,iBAAiB,iBAAA,IAAqB,QAAQ,IAAA;AACjG,YAAM,eAAe,KAAK,KAAK,eAAe,cAAc,QAAQ,WAAW,EAAE;AAGjF,SAAG,UAAU,cAAc,EAAE,WAAW,MAAM;AAE9C,UAAI,QAAQ,UAAU;AACpBA,iBAAO,KAAK,iCAAiC;AAAA,UAC3C;AAAA,UACA;AAAA,UACA,WAAW,QAAQ;AAAA,UACnB,QAAQ;AAAA,QAAA,CACT;AAAA,MACH,OAAO;AACLA,iBAAO,KAAK,iCAAiC;AAAA,UAC3C;AAAA,UACA;AAAA,UACA,oBAAoB;AAAA,UACpB,QAAQ;AAAA,QAAA,CACT;AAAA,MACH;AAGA,YAAM,kBAAkB,IAAI,gBAAA;AAG5B,YAAM,eAAe;AAAA,QACnB;AAAA,QACA;AAAA,QACA,SAAS;AAAA,UACP,SAAS;AAAA,UACT,OAAO;AAAA,UACP,cAAc;AAAA,UACd,gBAAgB;AAAA,UAChB,KAAK;AAAA,UACL,GAAG;AAAA,QAAA;AAAA,MACL;AAGFA,eAAO,KAAK,4BAA4B;AAAA,QACtC;AAAA,QACA,KAAK;AAAA,QACL;AAAA,MAAA,CACD;AAGD,UAAI,QAAQ,WAAW;AACrB,qBAAa,QAAQ,SAAS,QAAQ;AACtCA,iBAAO,KAAK,6BAA6B,EAAE,aAAa,WAAW,QAAQ,WAAW;AAAA,MACxF;AAGA,WAAK,eAAe,IAAI,aAAa;AAAA,QACnC,WAAW;AAAA,QACX;AAAA,QACA,cAAc;AAAA,QACd,WAAW,KAAK,IAAA;AAAA,MAAI,CACrB;AAGD,YAAM,KAAK,sBAAsB,aAAa,gBAAgB,OAAO;AAGrE,WAAK,iBAAiB,aAAa,YAAY,EAAE,MAAM,CAAA,UAAS;AAC9DA,iBAAO,MAAM,8BAA8B,EAAE,aAAa,OAAO;AACjE,aAAK,qBAAqB,aAAa,KAAK;AAAA,MAC9C,CAAC;AAED,aAAO;AAAA,IACT,SAAS,OAAO;AACdA,eAAO,MAAM,6BAA6B,EAAE,aAAa,OAAO;AAChE,YAAM,KAAK,sBAAsB,aAAa,gBAAgB,MAAM;AACpE,YAAM;AAAA,IACR;AAAA,EACF;AAAA,EAEA,MAAM,iBAAiB,aAAa,cAAc;AAChD,UAAM,UAAU,KAAK,eAAe,IAAI,WAAW;AACnD,QAAI,CAAC,SAAS;AACZ,YAAM,IAAI,MAAM,mBAAmB;AAAA,IACrC;AAEA,QAAI;AACF,UAAI,mBAAmB;AAEvB,uBAAiB,WAAW,MAAM,YAAY,GAAG;AAE/C,gBAAQ;AAGR;AACA,YAAI,mBAAmB,OAAO,GAAG;AAC/B,gBAAM,KAAK,gBAAgB,WAAW;AAAA,QACxC;AAGA,cAAM,KAAK,cAAc,aAAa,OAAO;AAG7C,YAAI,QAAQ,SAAS,YAAY,QAAQ,YAAY,UAAU,QAAQ,YAAY;AACjF,kBAAQ,YAAY,QAAQ;AAG5B,gBAAM,KAAK,GAAG;AAAA,YACZ;AAAA,YACA,CAAC,QAAQ,YAAY,WAAW;AAAA,UAAA;AAAA,QAEpC;AAGA,YAAI,QAAQ,SAAS,UAAU;AAC7B,gBAAM,KAAK,wBAAwB,aAAa,OAAO;AAAA,QACzD;AAAA,MACF;AAAA,IACF,SAAS,OAAO;AACd,UAAI,MAAM,SAAS,cAAc;AAC/BA,iBAAO,KAAK,qBAAqB,EAAE,YAAA,CAAa;AAChD,cAAM,KAAK,sBAAsB,aAAa,gBAAgB,SAAS;AAAA,MAEzE,OAAO;AACL,cAAM;AAAA,MACR;AAAA,IACF;AAAA,EACF;AAAA,EAEA,MAAM,cAAc,aAAa,SAAS;AACxC,UAAM,aAAY,oBAAI,KAAA,GAAO,YAAA;AAG7BA,aAAO,MAAM,oBAAoB;AAAA,MAC/B;AAAA,MACA,MAAM,QAAQ;AAAA,MACd,SAAS,QAAQ;AAAA,MACjB;AAAA,IAAA,CACD;AAGD,UAAM,aAAa,KAAK,UAAU,OAAO,EAAE,YAAA;AAC3C,QAAI,WAAW,SAAS,oBAAoB,GAAG;AAC7CA,eAAO,KAAK,gDAAgD;AAAA,QAC1D;AAAA,QACA,aAAa,QAAQ;AAAA,QACrB,gBAAgB,QAAQ;AAAA,QACxB,gBAAgB,KAAK,UAAU,SAAS,MAAM,CAAC;AAAA,MAAA,CAChD;AAAA,IACH;AAGA,QAAI,UAAU,QAAQ;AAEtB,YAAQ,QAAQ,MAAA;AAAA,MACd,KAAK;AAAA,MACL,KAAK;AACH,kBAAU,QAAQ;AAClB;AAAA,MACF,KAAK;AACH,kBAAU,QAAQ;AAClB;AAAA,MACF;AACE,kBAAU,QAAQ;AAClB;AAAA,IAAA;AAIJ,UAAM,KAAK,GAAG;AAAA,MACZ;AAAA,MACA,CAAC,aAAa,SAAS,KAAK,UAAU,OAAO,CAAC;AAAA,IAAA;AAIhD,SAAK,aAAa,KAAK,OAAO,WAAW;AAAA,MACvC;AAAA,MACA;AAAA,MACA,MAAM;AAAA,MACN,SAAS,KAAK,UAAU,OAAO;AAAA,IAAA,CAChC;AAAA,EACH;AAAA,EAEA,MAAM,YAAY,aAAa,SAAS;AAEtC,YAAQ,IAAI,gCAAgC,EAAE,aAAa,SAAS;AAEpE,UAAM,YAAY,MAAM,KAAK,GAAG;AAAA,MAC9B;AAAA,MACA,CAAC,WAAW;AAAA,IAAA;AAGd,YAAQ,IAAI,mBAAmB,EAAE,UAAA,CAAW;AAE5C,QAAI,CAAC,WAAW;AACd,YAAM,IAAI,MAAM,WAAW,mBAAmB;AAAA,IAChD;AAGA,QAAI,CAAC,UAAU,YAAY;AACzB,YAAM,IAAI,MAAM,mCAAmC;AAAA,IACrD;AAGA,SAAK,gBAAgB,IAAI,aAAa,OAAO;AAI7C,UAAM,KAAK,eAAe,aAAa,SAAS,MAAM;AAAA,MACpD,WAAW,UAAU;AAAA,IAAA,CACtB;AAED,WAAO;AAAA,EACT;AAAA,EAEA,MAAM,cAAc,aAAa;AAC/B,UAAM,UAAU,KAAK,eAAe,IAAI,WAAW;AAEnD,QAAI,CAAC,SAAS;AACZ,aAAO;AAAA,IACT;AAEAA,aAAO,KAAK,sBAAsB,EAAE,YAAA,CAAa;AAGjD,QAAI,QAAQ,iBAAiB;AAC3B,cAAQ,gBAAgB,MAAA;AAAA,IAC1B;AAGA,SAAK,eAAe,OAAO,WAAW;AAEtC,WAAO;AAAA,EACT;AAAA,EAEA,MAAM,QAAQ,aAAa;AACzB,UAAM,KAAK,cAAc,WAAW;AACpC,SAAK,gBAAgB,OAAO,WAAW;AACvC,SAAK,aAAa,KAAK,OAAO,cAAc,EAAE,aAAa;AAAA,EAC7D;AAAA,EAEA,mBAAmB,aAAa;AAC9B,WAAO,KAAK,eAAe,IAAI,WAAW;AAAA,EAC5C;AAAA;AAAA;AAAA;AAAA,EAKA,kBAAkB,aAAa;AAC7B,WAAO,KAAK,eAAe,IAAI,WAAW;AAAA,EAC5C;AAAA;AAAA;AAAA;AAAA,EAKA,qBAAqB,OAAO;AAC1B,QAAI,CAAC,MAAO,QAAO;AAGnB,UAAM,eAAe,MAAM,WAAW,MAAM,cAAc;AAC1D,WAAO,aAAa,cAAc,SAAS,oBAAoB;AAAA,EACjE;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,yBAAyB,aAAa;AAC1C,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,YAAM,UAAU,WAAW,MAAM;AAC/BA,iBAAO,MAAM,+BAA+B,EAAE,YAAA,CAAa;AAC3D,eAAO,IAAI,MAAM,6BAA6B,CAAC;AAAA,MACjD,GAAG,IAAM;AAETA,eAAO,KAAK,0CAA0C,EAAE,YAAA,CAAa;AAGrE,YAAM,oBAAoB,CAAC,EAAE,aAAa,aAAa,MAAM,aAAa;AACxEA,iBAAO,KAAK,+BAA+B;AAAA,UACzC;AAAA,UACA,mBAAmB;AAAA,UACnB;AAAA,UACA,WAAW,CAAC,CAAC;AAAA,QAAA,CACd;AAED,YAAI,gBAAgB,aAAa;AAC/B,uBAAa,OAAO;AACpB,eAAK,aAAa,IAAI,OAAO,cAAc,iBAAiB;AAE5D,cAAI,SAAS,KAAM,UAAU,CAAC,OAAO,UAAW;AAC9CA,qBAAO,KAAK,4CAA4C,EAAE,YAAA,CAAa;AACvE,oBAAA;AAAA,UACF,OAAO;AACLA,qBAAO,MAAM,4BAA4B,EAAE,aAAa,MAAM,QAAQ;AACtE,mBAAO,IAAI,MAAM,0BAA0B,CAAC;AAAA,UAC9C;AAAA,QACF;AAAA,MACF;AAGA,YAAM,kBAAkB,YAAY,MAAM;AACxC,YAAI,CAAC,KAAK,eAAe,IAAI,WAAW,GAAG;AACzCA,mBAAO,KAAK,yDAAyD,EAAE,YAAA,CAAa;AACpF,uBAAa,OAAO;AACpB,wBAAc,eAAe;AAC7B,eAAK,aAAa,IAAI,OAAO,cAAc,iBAAiB;AAC5D,kBAAA;AAAA,QACF;AAAA,MACF,GAAG,GAAI;AAEP,WAAK,aAAa,GAAG,OAAO,cAAc,iBAAiB;AAAA,IAC7D,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,gBAAgB,aAAa,iBAAiB,WAAW;AAC7D,UAAM,aAAY,oBAAI,KAAA,GAAO,YAAA;AAE7B,QAAI;AAEF,YAAM,sBAAsB;AAAA,QAC1B,MAAM;AAAA,QACN,SAAS;AAAA,UACP,IAAI,qBAAqB,KAAK,IAAA,CAAK;AAAA,UACnC,MAAM;AAAA,UACN,MAAM;AAAA,UACN,OAAO;AAAA,UACP,SAAS,CAAC;AAAA,YACR,MAAM;AAAA,YACN,MAAM;AAAA,UAAA,CACP;AAAA,UACD,aAAa;AAAA,UACb,eAAe;AAAA,UACf,OAAO;AAAA,QAAA;AAAA,QAET,oBAAoB;AAAA,QACpB,YAAY;AAAA,MAAA;AAGd,YAAM,KAAK,GAAG;AAAA,QACZ;AAAA,QACA,CAAC,aAAa,QAAQ,QAAQ,KAAK,UAAU,mBAAmB,CAAC;AAAA,MAAA;AAInE,WAAK,aAAa,KAAK,OAAO,WAAW;AAAA,QACvC;AAAA,QACA;AAAA,QACA,MAAM,QAAQ;AAAA,QACd,SAAS,KAAK,UAAU,mBAAmB;AAAA,MAAA,CAC5C;AAEDA,eAAO,KAAK,iCAAiC,EAAE,aAAa,QAAQ,iBAAiB;AAGrFA,eAAO,KAAK,4BAA4B,EAAE,aAAa,WAAW;AAClE,YAAM,KAAK,eAAe,aAAa,YAAY,MAAM;AAAA,QACvD;AAAA,QACA,WAAW;AAAA,MAAA,CACZ;AAEDA,eAAO,KAAK,mDAAmD,EAAE,YAAA,CAAa;AAG9E,YAAM,KAAK,yBAAyB,WAAW;AAE/CA,eAAO,KAAK,0BAA0B,EAAE,YAAA,CAAa;AAGrD,YAAM,yBAAyB;AAAA,QAC7B,MAAM;AAAA,QACN,SAAS;AAAA,UACP,IAAI,wBAAwB,KAAK,IAAA,CAAK;AAAA,UACtC,MAAM;AAAA,UACN,MAAM;AAAA,UACN,OAAO;AAAA,UACP,SAAS,CAAC;AAAA,YACR,MAAM;AAAA,YACN,MAAM;AAAA,UAAA,CACP;AAAA,UACD,aAAa;AAAA,UACb,eAAe;AAAA,UACf,OAAO;AAAA,QAAA;AAAA,QAET,oBAAoB;AAAA,QACpB,YAAY;AAAA,MAAA;AAGd,YAAM,KAAK,GAAG;AAAA,QACZ;AAAA,QACA,CAAC,aAAa,QAAQ,QAAQ,KAAK,UAAU,sBAAsB,CAAC;AAAA,MAAA;AAGtE,WAAK,aAAa,KAAK,OAAO,WAAW;AAAA,QACvC;AAAA,QACA,YAAW,oBAAI,KAAA,GAAO,YAAA;AAAA,QACtB,MAAM,QAAQ;AAAA,QACd,SAAS,KAAK,UAAU,sBAAsB;AAAA,MAAA,CAC/C;AAEDA,eAAO,KAAK,+CAA+C,EAAE,aAAa,QAAQ,oBAAoB;AAGtG,YAAM,KAAK,eAAe,aAAa,iBAAiB,MAAM,EAAE,WAAsB;AAAA,IAExF,SAAS,OAAO;AACdA,eAAO,MAAM,4BAA4B,EAAE,aAAa,OAAO;AAG/D,YAAM,eAAe;AAAA,QACnB,MAAM;AAAA,QACN,SAAS;AAAA,UACP,IAAI,qBAAqB,KAAK,IAAA,CAAK;AAAA,UACnC,MAAM;AAAA,UACN,MAAM;AAAA,UACN,OAAO;AAAA,UACP,SAAS,CAAC;AAAA,YACR,MAAM;AAAA,YACN,MAAM,qBAAqB,MAAM,OAAO;AAAA,UAAA,CACzC;AAAA,UACD,aAAa;AAAA,UACb,eAAe;AAAA,UACf,OAAO;AAAA,QAAA;AAAA,QAET,oBAAoB;AAAA,QACpB,YAAY;AAAA,MAAA;AAGd,YAAM,KAAK,GAAG;AAAA,QACZ;AAAA,QACA,CAAC,aAAa,QAAQ,QAAQ,KAAK,UAAU,YAAY,CAAC;AAAA,MAAA;AAG5D,WAAK,aAAa,KAAK,OAAO,WAAW;AAAA,QACvC;AAAA,QACA,YAAW,oBAAI,KAAA,GAAO,YAAA;AAAA,QACtB,MAAM,QAAQ;AAAA,QACd,SAAS,KAAK,UAAU,YAAY;AAAA,MAAA,CACrC;AAED,YAAM;AAAA,IACR;AAAA,EACF;AAAA,EAEA,MAAM,sBAAsB,aAAa,QAAQ;AAC/C,UAAM,UAAU,CAAC,YAAY;AAC7B,UAAM,SAAS,CAAC,MAAM;AAEtB,QAAI,WAAW,gBAAgB,aAAa,WAAW,gBAAgB,QAAQ;AAC7E,cAAQ,KAAK,kCAAkC;AAAA,IACjD;AAEA,WAAO,KAAK,WAAW;AAEvB,UAAM,KAAK,GAAG;AAAA,MACZ,yBAAyB,QAAQ,KAAK,IAAI,CAAC;AAAA,MAC3C;AAAA,IAAA;AAAA,EAEJ;AAAA,EAEA,MAAM,wBAAwB,aAAa,QAAQ;AACjDA,aAAO,KAAK,uBAAuB;AAAA,MACjC;AAAA,MACA,OAAO,OAAO;AAAA,MACd,UAAU,OAAO;AAAA,MACjB,MAAM,OAAO;AAAA,IAAA,CACd;AAGDA,aAAO,KAAK,2CAA2C;AAAA,MACrD;AAAA,MACA,YAAY,OAAO,KAAK,MAAM;AAAA,MAC9B,YAAY,OAAO;AAAA,MACnB,SAAS,OAAO;AAAA,MAChB,WAAW,CAAC,CAAC,OAAO;AAAA,MACpB,iBAAiB,OAAO,OAAO;AAAA,MAC/B,eAAe,OAAO,SAAS,OAAO,OAAO,WAAW,UAAU,GAAG,GAAG,IAAI;AAAA,MAC5E,gBAAgB,OAAO,SAAS,OAAO,OAAO,cAAc,SAAS,oBAAoB,IAAI;AAAA,MAC7F,YAAY,KAAK,UAAU,QAAQ,MAAM,CAAC;AAAA,IAAA,CAC3C;AAGD,UAAM,kBAAkB,OAAO,YACR,OAAO,UACP,OAAO,OAAO,cAAc,SAAS,oBAAoB;AAEhFA,aAAO,KAAK,gCAAgC;AAAA,MAC1C;AAAA,MACA;AAAA,MACA,SAAS,OAAO;AAAA,MAChB,WAAW,CAAC,CAAC,OAAO;AAAA,MACpB,iBAAiB,OAAO,SAAS,OAAO,OAAO,gBAAgB;AAAA,IAAA,CAChE;AAED,QAAI,iBAAiB;AACnBA,eAAO,KAAK,gEAAgE,EAAE,YAAA,CAAa;AAG3F,YAAM,kBAAkB,KAAK,gBAAgB,IAAI,WAAW;AAE5D,UAAI,iBAAiB;AACnB,YAAI;AAEF,gBAAM,YAAY,MAAM,KAAK,GAAG;AAAA,YAC9B;AAAA,YACA,CAAC,WAAW;AAAA,UAAA;AAGd,cAAI,aAAa,UAAU,YAAY;AAErC,iBAAK,eAAe,OAAO,WAAW;AACtC,iBAAK,gBAAgB,OAAO,WAAW;AAGvC,kBAAM,KAAK,gBAAgB,aAAa,iBAAiB,UAAU,UAAU;AAC7E;AAAA,UACF;AAAA,QACF,SAAS,OAAO;AACdA,mBAAO,MAAM,+BAA+B,EAAE,aAAa,OAAO;AAAA,QAEpE;AAAA,MACF;AAAA,IACF;AAGA,SAAK,gBAAgB,OAAO,WAAW;AAGvC,UAAM,KAAK,GAAG;AAAA,MACZ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAMA,CAAC,gBAAgB,WAAW,OAAO,WAAW,OAAO,gBAAgB,WAAW;AAAA,IAAA;AAMlF,SAAK,aAAa,KAAK,OAAO,cAAc;AAAA,MAC1C;AAAA,MACA,MAAM;AAAA,MACN,QAAQ;AAAA,MACR;AAAA,IAAA,CACD;AAGD,SAAK,eAAe,OAAO,WAAW;AAAA,EACxC;AAAA,EAEA,MAAM,qBAAqB,aAAa,OAAO;AAC7CA,aAAO,MAAM,mBAAmB,EAAE,aAAa,OAAO;AAEtD,UAAM,KAAK,sBAAsB,aAAa,gBAAgB,MAAM;AAEpE,UAAM,KAAK,GAAG;AAAA,MACZ;AAAA,MACA,CAAC,aAAa,QAAQ,QAAQ,oBAAoB,MAAM,OAAO,EAAE;AAAA,IAAA;AAKnE,SAAK,aAAa,KAAK,OAAO,eAAe,EAAE,aAAa,OAAO;AAGnE,SAAK,eAAe,OAAO,WAAW;AACtC,SAAK,gBAAgB,OAAO,WAAW;AAAA,EACzC;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,cAAc,aAAa,WAAW;AAC1CA,aAAO,KAAK,+BAA+B,EAAE,aAAa,WAAW;AAErE,QAAI;AAEF,YAAM,YAAY,MAAM,KAAK,GAAG;AAAA,QAC9B;AAAA,QACA,CAAC,WAAW;AAAA,MAAA;AAGd,UAAI,CAAC,WAAW;AACd,cAAM,IAAI,MAAM,aAAa,WAAW,YAAY;AAAA,MACtD;AAGA,YAAM,gBAAgB,KAAK,mBAAmB,KAAK,iBAAiB,iBAAA,IAAqB,QAAQ,IAAA;AACjG,YAAM,eAAe,KAAK,KAAK,eAAe,cAAc,QAAQ,WAAW,EAAE;AAGjF,YAAM,eAAe;AAGrB,YAAM,KAAK,eAAe,aAAa,cAAc,cAAc;AAAA,QACjE;AAAA,QACA,UAAU;AAAA;AAAA,QACV,UAAU;AAAA;AAAA,MAAA,CACX;AAEDA,eAAO,KAAK,gCAAgC,EAAE,aAAa,WAAW;AACtE,aAAO;AAAA,IACT,SAAS,OAAO;AACdA,eAAO,MAAM,4BAA4B,EAAE,aAAa,WAAW,OAAO;AAG1E,YAAM,KAAK,sBAAsB,aAAa,gBAAgB,MAAM;AAEpE,YAAM;AAAA,IACR;AAAA,EACF;AACF;AC3rBA,MAAMA,WAAS,aAAa,eAAe;AAE3C,MAAM,cAAc;AAAA,EAClB,YAAY,IAAI;AACd,SAAK,KAAK;AACV,SAAK,WAAW;AAChB,SAAK,UAAU;AAAA,EACjB;AAAA,EAEA,MAAM,aAAa,gBAAgB,MAAM;AACvC,QAAI;AACF,UAAI,eAAe;AACjBA,iBAAO,KAAK,8BAA8B,aAAa,eAAe;AACtE,cAAM,cAAc,MAAM,KAAK,gBAAgB,aAAa;AAC5DA,iBAAO,KAAK,QAAQ,aAAa,eAAe,WAAW,EAAE;AAE7D,YAAI,aAAa;AACf,gBAAM,KAAK,kBAAkB,aAAa;AAC1C,iBAAO;AAAA,QACT;AAAA,MACF;AAEAA,eAAO,KAAK,8CAA8C,KAAK,QAAQ,EAAE;AACzE,eAAS,OAAO,KAAK,UAAU,QAAQ,KAAK,SAAS,QAAQ;AAC3D,cAAM,cAAc,MAAM,KAAK,gBAAgB,IAAI;AACnD,YAAI,aAAa;AACfA,mBAAO,KAAK,yBAAyB,IAAI,EAAE;AAC3C,gBAAM,KAAK,kBAAkB,IAAI;AACjC,iBAAO;AAAA,QACT;AAAA,MACF;AAEA,YAAM,IAAI,MAAM,4CAA4C;AAAA,IAC9D,SAAS,OAAO;AACdA,eAAO,MAAM,0BAA0B,KAAK;AAC5C,YAAM;AAAA,IACR;AAAA,EACF;AAAA,EAEA,MAAM,YAAY,MAAM;AACtB,QAAI;AACF,YAAM,KAAK,GAAG,IAAI,+CAA+C,CAAC,IAAI,CAAC;AACvEA,eAAO,KAAK,iBAAiB,IAAI,EAAE;AAAA,IACrC,SAAS,OAAO;AACdA,eAAO,MAAM,wBAAwB,IAAI,KAAK,KAAK;AACnD,YAAM;AAAA,IACR;AAAA,EACF;AAAA,EAEA,MAAM,wBAAwB,WAAW;AACvC,QAAI;AACF,YAAM,KAAK,GAAG,IAAI,qDAAqD,CAAC,SAAS,CAAC;AAClFA,eAAO,KAAK,kCAAkC,SAAS,EAAE;AAAA,IAC3D,SAAS,OAAO;AACdA,eAAO,MAAM,qCAAqC,SAAS,KAAK,KAAK;AACrE,YAAM;AAAA,IACR;AAAA,EACF;AAAA,EAEA,MAAM,gBAAgB,MAAM;AAC1B,UAAM,cAAc,MAAM,KAAK,oBAAoB,IAAI;AACvD,QAAI,aAAa;AACf,aAAO;AAAA,IACT;AAGA,UAAM,mBAAmB,CAAC,aAAa,SAAS;AAEhD,eAAW,QAAQ,kBAAkB;AACnC,YAAM,YAAY,MAAM,KAAK,qBAAqB,MAAM,IAAI;AAC5D,UAAI,CAAC,WAAW;AACdA,iBAAO,KAAK,QAAQ,IAAI,wBAAwB,IAAI,EAAE;AACtD,eAAO;AAAA,MACT;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,MAAM,qBAAqB,MAAM,MAAM;AACrC,WAAO,IAAI,QAAQ,CAAC,YAAY;AAC9B,YAAM,SAAS,IAAI,aAAA;AAEnB,aAAO,KAAK,SAAS,CAAC,QAAQ;AAC5B,YAAI,IAAI,SAAS,cAAc;AAC7B,kBAAQ,KAAK;AAAA,QACf,OAAO;AAEL,kBAAQ,KAAK;AAAA,QACf;AAAA,MACF,CAAC;AAED,aAAO,KAAK,aAAa,MAAM;AAC7B,eAAO,MAAM,MAAM;AACjB,kBAAQ,IAAI;AAAA,QACd,CAAC;AAAA,MACH,CAAC;AAED,UAAI;AACF,eAAO,OAAO,MAAM,IAAI;AAAA,MAC1B,SAAS,OAAO;AACd,gBAAQ,KAAK;AAAA,MACf;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EAEA,MAAM,oBAAoB,MAAM;AAC9B,UAAM,SAAS,MAAM,KAAK,GAAG;AAAA,MAC3B;AAAA,MACA,CAAC,IAAI;AAAA,IAAA;AAEP,WAAO,CAAC,CAAC;AAAA,EACX;AAAA,EAEA,MAAM,kBAAkB,MAAM,WAAW;AACvC,UAAM,KAAK,GAAG;AAAA,MACZ;AAAA,MACA,CAAC,MAAM,aAAa,SAAS;AAAA,IAAA;AAAA,EAEjC;AAAA,EAEA,MAAM,qBAAqB,MAAM,WAAW;AAC1C,UAAM,KAAK,GAAG;AAAA,MACZ;AAAA,MACA,CAAC,WAAW,IAAI;AAAA,IAAA;AAAA,EAEpB;AAAA,EAEA,MAAM,oBAAoB;AACxB,UAAM,OAAO,MAAM,KAAK,GAAG;AAAA,MACzB;AAAA,IAAA;AAEF,WAAO;AAAA,EACT;AAAA,EAEA,MAAM,0BAA0B;AAC9B,QAAI;AACF,YAAM,mBAAmB,MAAM,KAAK,GAAG,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA,OAK1C;AAED,iBAAW,cAAc,kBAAkB;AACzC,cAAM,KAAK,YAAY,WAAW,IAAI;AAAA,MACxC;AAEAA,eAAO,KAAK,cAAc,iBAAiB,MAAM,yBAAyB;AAC1E,aAAO,iBAAiB;AAAA,IAC1B,SAAS,OAAO;AACdA,eAAO,MAAM,wCAAwC,KAAK;AAC1D,YAAM;AAAA,IACR;AAAA,EACF;AACF;AC1JA,MAAMA,WAAS,aAAa,iBAAiB;AAE7C,MAAM,gBAAgB;AAAA,EACpB,cAAc;AACZ,SAAK,qBAAqB;AAAA,MACxB,MAAM;AAAA,QACJ,OAAO,CAAC,SAAS,aAAa,eAAe;AAAA,QAC7C,KAAK,CAAC,OAAO,kBAAkB;AAAA,QAC/B,SAAS,CAAC,iBAAiB,cAAc;AAAA,QACzC,QAAQ,CAAC,QAAQ,SAAS,WAAW;AAAA,QACrC,SAAS,CAAC,SAAS;AAAA,QACnB,QAAQ,CAAC,gBAAgB,gBAAgB;AAAA,QACzC,QAAQ,CAAC,QAAQ;AAAA,QACjB,MAAM,CAAC,MAAM;AAAA,QACb,QAAQ,CAAC,UAAU,eAAe;AAAA,QAClC,MAAM,CAAC,MAAM;AAAA,MAAA;AAAA,IACf;AAGF,SAAK,eAAe;AAAA,MAClB,OAAO;AAAA,MACP,KAAK;AAAA,MACL,SAAS;AAAA,MACT,QAAQ;AAAA,MACR,SAAS;AAAA,MACT,QAAQ;AAAA,MACR,QAAQ;AAAA,MACR,MAAM;AAAA,MACN,QAAQ;AAAA,MACR,MAAM;AAAA,MACN,QAAQ;AAAA,MACR,OAAO;AAAA,MACP,SAAS;AAAA,IAAA;AAGX,SAAK,iBAAiB,CAAC,OAAO,WAAW,SAAS,SAAS,SAAS;AAAA,EACtE;AAAA,EAEA,MAAM,kBAAkB,YAAY;AAClC,QAAI;AACF,YAAM,WAAW;AAAA,QACf,aAAa;AAAA,QACb,WAAW;AAAA,QACX,aAAa;AAAA,UACX,aAAa;AAAA,UACb,aAAa;AAAA,UACb,UAAU;AAAA,UACV,UAAU;AAAA,UACV,cAAc;AAAA,UACd,SAAS;AAAA,UACT,eAAe;AAAA,UACf,YAAY;AAAA,UACZ,WAAW;AAAA,QAAA;AAAA,QAEb,cAAc,CAAA;AAAA,QACd,iBAAiB,CAAA;AAAA,MAAC;AAGpB,YAAM,QAAQ,MAAMC,SAAG,QAAQ,UAAU;AAEzC,iBAAW,QAAQ,OAAO;AACxB,gBAAQ,MAAA;AAAA,UACN,KAAK;AACH,qBAAS,YAAY,cAAc;AACnC,kBAAM,cAAc,MAAM,KAAK,gBAAgB,UAAU;AACzD,gBAAI,aAAa;AACf,uBAAS,eAAe,YAAY,gBAAgB,CAAA;AACpD,uBAAS,kBAAkB,YAAY,mBAAmB,CAAA;AAC1D,uBAAS,cAAc;AACvB,uBAAS,YAAY,KAAK,oBAAoB,WAAW;AAAA,YAC3D;AACA;AAAA,UACF,KAAK;AACH,qBAAS,YAAY,cAAc;AACnC;AAAA,UACF,KAAK;AACH,qBAAS,YAAY,WAAW;AAChC;AAAA,UACF,KAAK;AACH,qBAAS,YAAY,WAAW;AAChC;AAAA,UACF,KAAK;AACH,qBAAS,YAAY,eAAe;AACpC,gBAAI,SAAS,gBAAgB,WAAW;AACtC,uBAAS,cAAc;AACvB,uBAAS,YAAY,MAAM,KAAK,sBAAsB,UAAU;AAAA,YAClE;AACA;AAAA,UACF,KAAK;AACH,qBAAS,YAAY,UAAU;AAC/B,gBAAI,SAAS,gBAAgB,WAAW;AACtC,uBAAS,cAAc;AAAA,YACzB;AACA;AAAA,UACF,KAAK;AACH,qBAAS,YAAY,gBAAgB;AACrC,gBAAI,SAAS,gBAAgB,WAAW;AACtC,uBAAS,cAAc;AAAA,YACzB;AACA;AAAA,UACF,KAAK;AACH,qBAAS,YAAY,aAAa;AAClC;AAAA,UACF,KAAK;AACH,qBAAS,YAAY,YAAY;AACjC,gBAAI,SAAS,gBAAgB,WAAW;AACtC,uBAAS,cAAc;AAAA,YACzB;AACA;AAAA,QAAA;AAAA,MAEN;AAEA,aAAO;AAAA,IACT,SAAS,OAAO;AACdD,eAAO,MAAM,iCAAiC,KAAK;AACnD,aAAO;AAAA,QACL,aAAa;AAAA,QACb,WAAW;AAAA,QACX,aAAa,CAAA;AAAA,QACb,cAAc,CAAA;AAAA,QACd,iBAAiB,CAAA;AAAA,MAAC;AAAA,IAEtB;AAAA,EACF;AAAA,EAEA,MAAM,gBAAgB,YAAY;AAChC,QAAI;AACF,YAAM,kBAAkB,KAAK,KAAK,YAAY,cAAc;AAC5D,YAAM,UAAU,MAAMC,SAAG,SAAS,iBAAiB,MAAM;AACzD,aAAO,KAAK,MAAM,OAAO;AAAA,IAC3B,SAAS,OAAO;AACdD,eAAO,MAAM,+BAA+B,KAAK;AACjD,aAAO;AAAA,IACT;AAAA,EACF;AAAA,EAEA,oBAAoB,aAAa;AAC/B,UAAM,UAAU;AAAA,MACd,GAAG,YAAY;AAAA,MACf,GAAG,YAAY;AAAA,IAAA;AAGjB,eAAW,CAAC,WAAW,UAAU,KAAK,OAAO,QAAQ,KAAK,mBAAmB,IAAI,GAAG;AAClF,UAAI,WAAW,KAAK,CAAA,QAAO,OAAO,OAAO,GAAG;AAC1C,eAAO;AAAA,MACT;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,MAAM,sBAAsB,YAAY;AACtC,QAAI;AACF,YAAM,mBAAmB,KAAK,KAAK,YAAY,kBAAkB;AACjE,YAAM,UAAU,MAAMC,SAAG,SAAS,kBAAkB,MAAM;AAC1D,YAAM,QAAQ,QAAQ,YAAA,EAAc,MAAM,IAAI;AAE9C,UAAI,MAAM,KAAK,CAAA,SAAQ,KAAK,SAAS,QAAQ,CAAC,GAAG;AAC/C,eAAO;AAAA,MACT;AACA,UAAI,MAAM,KAAK,CAAA,SAAQ,KAAK,SAAS,OAAO,CAAC,GAAG;AAC9C,eAAO;AAAA,MACT;AACA,UAAI,MAAM,KAAK,CAAA,SAAQ,KAAK,SAAS,SAAS,CAAC,GAAG;AAChD,eAAO;AAAA,MACT;AAAA,IACF,SAAS,OAAO;AACdD,eAAO,MAAM,sCAAsC,MAAM,OAAO;AAAA,IAClE;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,MAAM,oBAAoB,YAAY,aAAa;AACjD,UAAM,UAAU,CAAA;AAEhB,QAAI,gBAAgB,QAAQ;AAC1B,YAAM,cAAc,MAAM,KAAK,gBAAgB,UAAU;AACzD,UAAI,eAAe,YAAY,SAAS;AACtC,eAAO,OAAO,SAAS,YAAY,OAAO;AAAA,MAC5C;AAAA,IACF,WAAW,gBAAgB,UAAU;AACnC,YAAM,YAAY,MAAM,KAAK,sBAAsB,UAAU;AAC7D,UAAI,cAAc,UAAU;AAC1B,gBAAQ,YAAY;AAAA,MACtB,WAAW,cAAc,SAAS;AAChC,gBAAQ,MAAM;AAAA,MAChB,WAAW,cAAc,WAAW;AAClC,gBAAQ,MAAM;AAAA,MAChB;AAAA,IACF,WAAW,gBAAgB,UAAU;AACnC,cAAQ,QAAQ;AAAA,IAClB;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,oBAAoB,SAAS;AAC3B,eAAW,YAAY,KAAK,gBAAgB;AAC1C,UAAI,QAAQ,QAAQ,GAAG;AACrB,eAAO;AAAA,MACT;AAAA,IACF;AAEA,UAAM,cAAc,OAAO,KAAK,OAAO;AACvC,QAAI,YAAY,SAAS,GAAG;AAC1B,aAAO,YAAY,CAAC;AAAA,IACtB;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,MAAM,WAAW,YAAY,QAAQ,WAAW;;AAC9C,QAAI,eAAe;AAEnB,QAAI,aAAa,KAAK,aAAa,SAAS,GAAG;AAC7C,qBAAe,KAAK,aAAa,SAAS;AAAA,IAC5C;AAEA,QAAI;AACF,YAAM,cAAc,MAAM,KAAK,gBAAgB,UAAU;AACzD,UAAI,aAAa;AACf,YAAI,YAAY,UAAU,YAAY,OAAO,MAAM;AACjD,yBAAe,YAAY,OAAO;AAAA,QACpC;AAEA,cAAM,iBAAgB,iBAAY,YAAZ,mBAAsB;AAC5C,YAAI,eAAe;AACjB,gBAAM,YAAY,cAAc,MAAM,6BAA6B;AACnE,cAAI,WAAW;AACb,2BAAe,SAAS,UAAU,CAAC,KAAK,UAAU,CAAC,CAAC;AAAA,UACtD;AAEA,gBAAM,eAAe,cAAc,MAAM,YAAY;AACrD,cAAI,cAAc;AAChB,2BAAe,SAAS,aAAa,CAAC,CAAC;AAAA,UACzC;AAAA,QACF;AAAA,MACF;AAEA,YAAM,WAAW,CAAC,QAAQ,cAAc,kBAAkB;AAC1D,iBAAW,WAAW,UAAU;AAC9B,YAAI;AACF,gBAAM,UAAU,KAAK,KAAK,YAAY,OAAO;AAC7C,gBAAM,aAAa,MAAMC,SAAG,SAAS,SAAS,MAAM;AACpD,gBAAM,YAAY,WAAW,MAAM,cAAc;AACjD,cAAI,WAAW;AACb,2BAAe,SAAS,UAAU,CAAC,CAAC;AACpC;AAAA,UACF;AAAA,QACF,SAAS,OAAO;AACd;AAAA,QACF;AAAA,MACF;AAAA,IACF,SAAS,OAAO;AACdD,eAAO,MAAM,yBAAyB,MAAM,OAAO;AAAA,IACrD;AAEA,WAAO,gBAAgB,KAAK,aAAa,SAAS,KAAK;AAAA,EACzD;AAAA,EAEA,MAAM,2BAA2B,YAAY,aAAa;AACxD,QAAI,gBAAgB,QAAQ;AAC1B,UAAI;AACF,cAAMC,SAAG,OAAO,KAAK,KAAK,YAAY,cAAc,CAAC;AACrD,eAAO;AAAA,MACT,QAAQ;AACN,eAAO;AAAA,MACT;AAAA,IACF,WAAW,gBAAgB,UAAU;AACnC,UAAI;AACF,cAAMA,SAAG,OAAO,KAAK,KAAK,YAAY,MAAM,CAAC;AAC7C,eAAO;AAAA,MACT,QAAQ;AACN,YAAI;AACF,gBAAMA,SAAG,OAAO,KAAK,KAAK,YAAY,OAAO,CAAC;AAC9C,iBAAO;AAAA,QACT,QAAQ;AACN,iBAAO;AAAA,QACT;AAAA,MACF;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,qBAAqB,aAAa;AAChC,QAAI,YAAY,SAAU,QAAO;AACjC,QAAI,YAAY,SAAU,QAAO;AACjC,QAAI,YAAY,YAAa,QAAO;AACpC,QAAI,YAAY,YAAa,QAAO;AACpC,QAAI,YAAY,QAAS,QAAO;AAChC,QAAI,YAAY,aAAc,QAAO;AACrC,WAAO;AAAA,EACT;AACF;ACtSA,MAAMD,WAAS,aAAa,eAAe;AAE3C,MAAM,cAAc;AAAA,EAClB,cAAc;AACZ,SAAK,iBAAiB;AACtB,SAAK,cAAc;AACnB,SAAK,eAAe;AACpB,SAAK,WAAW;AAAA,EAClB;AAAA,EAEA,MAAM,YAAY,KAAK,UAAU,KAAK,gBAAgB;AACpD,WAAO,IAAI,QAAQ,CAAC,YAAY;AAC9B,YAAM,YAAY,KAAK,IAAA;AACvB,YAAM,YAAY,IAAI,IAAI,GAAG;AAC7B,YAAM,SAAS,UAAU,aAAa,WAAW,QAAQ;AAEzD,YAAM,UAAU;AAAA,QACd,UAAU,UAAU;AAAA,QACpB,MAAM,UAAU;AAAA,QAChB,MAAM,UAAU;AAAA,QAChB,QAAQ;AAAA,QACR;AAAA,QACA,SAAS;AAAA,UACP,cAAc;AAAA,QAAA;AAAA,MAChB;AAGF,YAAM,MAAM,OAAO,QAAQ,SAAS,CAAC,QAAQ;AAC3C,cAAM,eAAe,KAAK,IAAA,IAAQ;AAElC,YAAI,GAAG,QAAQ,MAAM;AAAA,QAAC,CAAC;AACvB,YAAI,GAAG,OAAO,MAAM;AAClB,kBAAQ;AAAA,YACN,YAAY;AAAA,YACZ,YAAY,IAAI;AAAA,YAChB;AAAA,YACA,SAAS,IAAI;AAAA,UAAA,CACd;AAAA,QACH,CAAC;AAAA,MACH,CAAC;AAED,UAAI,GAAG,SAAS,CAAC,UAAU;AACzBA,iBAAO,MAAM,2BAA2B,GAAG,KAAK,MAAM,OAAO;AAC7D,gBAAQ;AAAA,UACN,YAAY;AAAA,UACZ,OAAO,MAAM;AAAA,UACb,cAAc,KAAK,QAAQ;AAAA,QAAA,CAC5B;AAAA,MACH,CAAC;AAED,UAAI,GAAG,WAAW,MAAM;AACtB,YAAI,QAAA;AACJ,gBAAQ;AAAA,UACN,YAAY;AAAA,UACZ,OAAO;AAAA,UACP,cAAc;AAAA,QAAA,CACf;AAAA,MACH,CAAC;AAED,UAAI,IAAA;AAAA,IACN,CAAC;AAAA,EACH;AAAA,EAEA,MAAM,cAAc,KAAK,UAAU,IAAI;AACrC,UAAM,cAAc,QAAQ,eAAe,KAAK;AAChD,UAAM,eAAe,QAAQ,gBAAgB,KAAK;AAClD,UAAM,WAAW,QAAQ,YAAY,KAAK;AAC1C,UAAM,UAAU,QAAQ,WAAW,KAAK;AACxC,UAAM,sBAAsB,QAAQ,uBAAuB,CAAC,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,GAAG;AAE5GA,aAAO,KAAK,yBAAyB,GAAG,0BAA0B;AAElE,QAAI,UAAU;AACd,QAAI,QAAQ;AAEZ,WAAO,UAAU,aAAa;AAC5B;AAEA,YAAM,SAAS,MAAM,KAAK,YAAY,KAAK,OAAO;AAElD,UAAI,OAAO,YAAY;AACrB,YAAI,oBAAoB,SAAS,OAAO,UAAU,GAAG;AACnDA,mBAAO,KAAK,aAAa,GAAG,2BAA2B,OAAO,IAAI,WAAW,GAAG;AAChF,iBAAO;AAAA,YACL,SAAS;AAAA,YACT,UAAU;AAAA,YACV;AAAA,UAAA;AAAA,QAEJ,OAAO;AACLA,mBAAO,MAAM,2CAA2C,OAAO,UAAU,EAAE;AAAA,QAC7E;AAAA,MACF;AAEA,UAAI,UAAU,aAAa;AACzBA,iBAAO,MAAM,6BAA6B,KAAK,4BAA4B,OAAO,IAAI,WAAW,GAAG;AACpG,cAAM,KAAK,MAAM,KAAK;AACtB,gBAAQ,KAAK,IAAI,QAAQ,KAAK,QAAQ;AAAA,MACxC;AAAA,IACF;AAEAA,aAAO,MAAM,aAAa,GAAG,sCAAsC,WAAW,WAAW;AACzF,WAAO;AAAA,MACL,SAAS;AAAA,MACT,UAAU;AAAA,MACV,OAAO;AAAA,IAAA;AAAA,EAEX;AAAA,EAEA,MAAM,kBAAkB,MAAM,UAAU,KAAK,gBAAgB;AAC3D,UAAM,SAAS,KAAK;AAAA,MAAI,SACtB,KAAK,YAAY,KAAK,OAAO,EAAE,KAAK,CAAA,YAAW;AAAA,QAC7C;AAAA,QACA,GAAG;AAAA,MAAA,EACH;AAAA,IAAA;AAGJ,WAAO,QAAQ,IAAI,MAAM;AAAA,EAC3B;AAAA,EAEA,MAAM,kBAAkB,MAAM,UAAU,IAAI;AAC1C,eAAW,OAAO,MAAM;AACtB,YAAM,SAAS,MAAM,KAAK,cAAc,KAAK,EAAE,GAAG,SAAS,aAAa,GAAG;AAC3E,UAAI,OAAO,SAAS;AAClB,eAAO;AAAA,UACL;AAAA,UACA,GAAG;AAAA,QAAA;AAAA,MAEP;AAAA,IACF;AAEA,WAAO;AAAA,MACL,SAAS;AAAA,MACT,OAAO;AAAA,IAAA;AAAA,EAEX;AAAA,EAEA,MAAM,IAAI;AACR,WAAO,IAAI,QAAQ,CAAA,YAAW,WAAW,SAAS,EAAE,CAAC;AAAA,EACvD;AAAA,EAEA,kBAAkB,QAAQ;AACxB,QAAI,CAAC,OAAO,YAAY;AACtB,aAAO;AAAA,QACL,QAAQ;AAAA,QACR,SAAS,OAAO,SAAS;AAAA,QACzB,cAAc,OAAO;AAAA,MAAA;AAAA,IAEzB;AAEA,QAAI,OAAO,cAAc,OAAO,OAAO,aAAa,KAAK;AACvD,aAAO;AAAA,QACL,QAAQ;AAAA,QACR,SAAS;AAAA,QACT,YAAY,OAAO;AAAA,QACnB,cAAc,OAAO;AAAA,MAAA;AAAA,IAEzB;AAEA,QAAI,OAAO,cAAc,OAAO,OAAO,aAAa,KAAK;AACvD,aAAO;AAAA,QACL,QAAQ;AAAA,QACR,SAAS;AAAA,QACT,YAAY,OAAO;AAAA,QACnB,cAAc,OAAO;AAAA,QACrB,UAAU,OAAO,QAAQ;AAAA,MAAA;AAAA,IAE7B;AAEA,QAAI,OAAO,cAAc,OAAO,OAAO,aAAa,KAAK;AACvD,aAAO;AAAA,QACL,QAAQ;AAAA,QACR,SAAS;AAAA,QACT,YAAY,OAAO;AAAA,QACnB,cAAc,OAAO;AAAA,MAAA;AAAA,IAEzB;AAEA,QAAI,OAAO,cAAc,KAAK;AAC5B,aAAO;AAAA,QACL,QAAQ;AAAA,QACR,SAAS;AAAA,QACT,YAAY,OAAO;AAAA,QACnB,cAAc,OAAO;AAAA,MAAA;AAAA,IAEzB;AAEA,WAAO;AAAA,MACL,QAAQ;AAAA,MACR,SAAS;AAAA,MACT,YAAY,OAAO;AAAA,MACnB,cAAc,OAAO;AAAA,IAAA;AAAA,EAEzB;AACF;AC5LA,MAAMA,WAAS,aAAa,gBAAgB;AAE5C,MAAM,eAAe;AAAA,EACnB,YAAY,IAAI,gBAAgB,cAAc;AAC5C,SAAK,KAAK;AACV,SAAK,iBAAiB;AACtB,SAAK,eAAe;AACpB,SAAK,gBAAgB,IAAI,cAAc,EAAE;AACzC,SAAK,kBAAkB,IAAI,gBAAA;AAC3B,SAAK,gBAAgB,IAAI,cAAA;AACzB,SAAK,uCAAuB,IAAA;AAC5B,SAAK,qCAAqB,IAAA;AAG1B,SAAK,sBAAsB;AAC3B,SAAK,qBAAqB;AAC1B,SAAK,eAAe;AAGpB,SAAK,gBAAgB;AAAA;AAAA,MAEnB;AAAA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA;AAAA,MAGA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA;AAAA,MAGA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA;AAAA,MAGA;AAAA,MACA;AAAA,MACA;AAAA,IAAA;AAIF,SAAK,mCAAmB,IAAA;AAGxB,SAAK,sCAAsB,IAAA;AAC3B,SAAK,mBAAmB;AAGxB,SAAK,sBAAA;AAAA,EACP;AAAA,EAEA,MAAM,eAAe,aAAa,UAAU,IAAI;AAC9C,QAAI;AACF,YAAM,YAAY,MAAM,KAAK,GAAG;AAAA,QAC9B;AAAA,QACA,CAAC,WAAW;AAAA,MAAA;AAGd,UAAI,CAAC,WAAW;AACd,cAAM,IAAI,MAAM,qBAAqB;AAAA,MACvC;AAGA,UAAI,aAAa,UAAU;AAC3B,UAAI,QAAQ,WAAW,QAAQ,OAAO;AAEpC,cAAM,gBAAgB,UAAU,kBAAkB,UAAU;AAC5D,qBAAa,KAAK,KAAK,eAAe,QAAQ,SAAS,QAAQ,KAAK;AACpEA,iBAAO,KAAK,uCAAuC,UAAU,EAAE;AAAA,MACjE;AACA,YAAM,cAAc,MAAM,KAAK,gBAAgB,kBAAkB,UAAU;AAC3E,YAAM,UAAU,MAAM,KAAK,gBAAgB,oBAAoB,YAAY,YAAY,WAAW;AAClG,YAAM,mBAAmB,KAAK,gBAAgB,oBAAoB,OAAO;AACzE,YAAM,eAAe;AAAA,QACnB,WAAW,MAAM,KAAK,gBAAgB,2BAA2B,YAAY,YAAY,WAAW;AAAA,QACpG,SAAS,KAAK,gBAAgB,qBAAqB,YAAY,WAAW;AAAA,MAAA;AAG5E,UAAI,eAAe;AACnB,UAAI,kBAAkB;AACpB,uBAAe,MAAM,KAAK,gBAAgB,WAAW,YAAY,kBAAkB,YAAY,SAAS;AAAA,MAC1G;AAEA,YAAM,OAAO;AAAA,QACX,UAAU;AAAA,QACV,WAAW,eAAe,MAAM,KAAK,cAAc,gBAAgB,YAAY,IAAI;AAAA,MAAA;AAGrF,aAAO;AAAA,QACL;AAAA,QACA,SAAS,QAAQ;AAAA,QACjB,OAAO,QAAQ;AAAA,QACf;AAAA,QACA,aAAa,YAAY;AAAA,QACzB,WAAW,YAAY;AAAA,QACvB,aAAa,YAAY;AAAA,QACzB,kBAAkB;AAAA,QAClB;AAAA,QACA;AAAA,QACA;AAAA,MAAA;AAAA,IAEJ,SAAS,OAAO;AACdA,eAAO,MAAM,yCAAyC,WAAW,KAAK,KAAK;AAC3E,YAAM;AAAA,IACR;AAAA,EACF;AAAA,EAEA,MAAM,aAAa,aAAa,UAAU,IAAI;AAC5C,QAAI;AACF,YAAM,YAAY,MAAM,KAAK,GAAG;AAAA,QAC9B;AAAA,QACA,CAAC,WAAW;AAAA,MAAA;AAGd,UAAI,CAAC,WAAW;AACd,cAAM,IAAI,MAAM,qBAAqB;AAAA,MACvC;AAGA,UAAI,QAAQ,WAAW,QAAQ,OAAO;AACpC,cAAM,kBAAkB,MAAM,KAAK,GAAG;AAAA,UACpC;AAAA,UACA,CAAC,aAAa,QAAQ,SAAS,QAAQ,KAAK;AAAA,QAAA;AAG9C,YAAI,iBAAiB;AACnBA,mBAAO,KAAK,8BAA8B,QAAQ,OAAO,IAAI,QAAQ,KAAK,KAAK;AAAA,YAC7E,IAAI,gBAAgB;AAAA,YACpB,QAAQ,gBAAgB;AAAA,YACxB,KAAK,gBAAgB;AAAA,YACrB,MAAM,gBAAgB;AAAA,YACtB,YAAY,gBAAgB;AAAA,YAC5B,eAAe,gBAAgB;AAAA,UAAA,CAChC;AAGD,cAAI,CAAC,cAAc,YAAY,SAAS,EAAE,SAAS,gBAAgB,MAAM,GAAG;AAC1EA,qBAAO,KAAK,wBAAwB,gBAAgB,MAAM,6BAA6B;AAGvF,gBAAI,oBAAoB;AAGxB,gBAAI,gBAAgB,KAAK;AACvB,kBAAI;AAEF,wBAAQ,KAAK,gBAAgB,KAAK,CAAC;AACnC,oCAAoB;AACpBA,yBAAO,KAAK,WAAW,gBAAgB,GAAG,mBAAmB;AAAA,cAC/D,SAAS,OAAO;AACdA,yBAAO,KAAK,WAAW,gBAAgB,GAAG,oBAAoB,MAAM,OAAO,EAAE;AAAA,cAC/E;AAAA,YACF;AAGA,gBAAI,CAAC,qBAAqB,gBAAgB,MAAM;AAC9C,oBAAM,YAAY,CAAE,MAAM,KAAK,cAAc,gBAAgB,gBAAgB,IAAI;AACjF,kBAAI,WAAW;AACbA,yBAAO,KAAK,QAAQ,gBAAgB,IAAI,0CAA0C;AAAA,cAEpF,OAAO;AACLA,yBAAO,KAAK,QAAQ,gBAAgB,IAAI,eAAe;AAAA,cACzD;AAAA,YACF;AAEA,gBAAI,mBAAmB;AAErBA,uBAAO,KAAK,yDAAyD;AACrE,oBAAM,OAAO,gBAAgB,OAAO,KAAK,MAAM,gBAAgB,IAAI,IAAI,CAAA;AACvE,qBAAO;AAAA,gBACL,SAAS;AAAA,gBACT,WAAW,gBAAgB;AAAA,gBAC3B;AAAA,gBACA,SAAS,QAAQ;AAAA,gBACjB,OAAO,QAAQ;AAAA,gBACf,YAAY,gBAAgB;AAAA,gBAC5B,QAAQ,gBAAgB;AAAA,gBACxB,SAAS,gBAAgB;AAAA,gBACzB,KAAK,gBAAgB;AAAA,gBACrB,MAAM,gBAAgB;AAAA,gBACtB;AAAA,gBACA,WAAW,gBAAgB;AAAA,gBAC3B,UAAU;AAAA,cAAA;AAAA,YAEd,OAAO;AAELA,uBAAO,KAAK,4DAA4D;AACxE,oBAAM,KAAK,GAAG;AAAA,gBACZ;AAAA,gBACA,CAAC,WAAW,gBAAgB,EAAE;AAAA,cAAA;AAEhC,8BAAgB,SAAS;AAAA,YAE3B;AAAA,UACF;AAGA,cAAI,CAAC,WAAW,QAAQ,EAAE,SAAS,gBAAgB,MAAM,GAAG;AAC1DA,qBAAO,KAAK,iBAAiB,gBAAgB,MAAM,oCAAoC;AAGvF,gBAAI;AACF,oBAAM,KAAK,YAAY,aAAa,gBAAgB,EAAE;AAEtD,oBAAM,IAAI,QAAQ,CAAA,YAAW,WAAW,SAAS,GAAI,CAAC;AAAA,YACxD,SAAS,OAAO;AACdA,uBAAO,KAAK,0BAA0B,gBAAgB,EAAE,KAAK,KAAK;AAAA,YACpE;AAIAA,qBAAO,KAAK,4BAA4B,QAAQ,OAAO,IAAI,QAAQ,KAAK,6BAA6B;AAAA,UAEvG,OAAO;AAELA,qBAAO,KAAK,kCAAkC,gBAAgB,MAAM,EAAE;AACtE,mBAAO;AAAA,cACL,SAAS;AAAA,cACT,OAAO,kCAAkC,gBAAgB,MAAM;AAAA,cAC/D,WAAW,gBAAgB;AAAA,YAAA;AAAA,UAE/B;AAAA,QACF;AAAA,MACF;AAGA,UAAI,aAAa,UAAU;AAC3B,UAAI,QAAQ,WAAW,QAAQ,OAAO;AACpC,cAAM,gBAAgB,UAAU,kBAAkB,UAAU;AAC5D,qBAAa,KAAK,KAAK,eAAe,QAAQ,SAAS,QAAQ,KAAK;AACpEA,iBAAO,KAAK,gDAAgD,UAAU,IAAI;AAAA,UACxE,SAAS,QAAQ;AAAA,UACjB,OAAO,QAAQ;AAAA,UACf;AAAA,UACA,4BAA4B,UAAU;AAAA,UACtC,yBAAyB,UAAU;AAAA,UACnC,aAAa;AAAA,UACb;AAAA,QAAA,CACD;AAAA,MACH;AAEA,YAAM,YAAYS,GAAA;AAGlB,YAAM,KAAK,GAAG;AAAA,QACZ;AAAA;AAAA,QAEA;AAAA,UAAC;AAAA,UAAW;AAAA,UAAa;AAAA,UAAW;AAAA,UAAM;AAAA,UAAc,KAAK,UAAU,EAAE;AAAA,UAAG;AAAA,UAC3E,QAAQ,WAAW;AAAA,UAAM,QAAQ,SAAS;AAAA,UAAM;AAAA,QAAA;AAAA,MAAU;AAI7D,WAAK,kBAAkB,WAAW,aAAa,YAAY,OAAO,EAC/D,MAAM,CAAA,UAAS;AACdT,iBAAO,MAAM,kCAAkC,SAAS,KAAK,KAAK;AAClE,aAAK,GAAG;AAAA,UACN;AAAA,UACA,CAAC,UAAU,MAAM,SAAS,SAAS;AAAA,QAAA,EACnC,MAAM,CAAA,YAAW;AACjBA,mBAAO,MAAM,8CAA8C,OAAO;AAAA,QACpE,CAAC;AAAA,MACH,CAAC;AAGH,aAAO;AAAA,QACL,SAAS;AAAA,QACT;AAAA,QACA;AAAA,QACA,SAAS,QAAQ;AAAA,QACjB,OAAO,QAAQ;AAAA,QACf;AAAA,QACA,QAAQ;AAAA,QACR,SAAS;AAAA,QACT,KAAK;AAAA,QACL,MAAM;AAAA,QACN,MAAM,CAAA;AAAA,QACN,YAAW,oBAAI,KAAA,GAAO,YAAA;AAAA,MAAY;AAAA,IAGtC,SAAS,OAAO;AACdA,eAAO,MAAM,2BAA2B,KAAK;AAC7C,YAAM;AAAA,IACR;AAAA,EACF;AAAA,EAEA,MAAM,kBAAkB,WAAW,aAAa,YAAY,SAAS;AACnE,QAAI;AACFA,eAAO,KAAK,sBAAsB,SAAS,OAAO,UAAU,EAAE;AAG9D,YAAM,WAAW,MAAM,KAAK,eAAe,aAAa,EAAE,SAAS,QAAQ,SAAS,OAAO,QAAQ,MAAA,CAAO;AAG1G,UAAI,QAAQ,wBAAwB,OAAO;AACzCA,iBAAO,KAAK,8BAA8B,UAAU,EAAE;AAGtD,YAAI,KAAK,cAAc;AACrB,eAAK,aAAa,KAAK,iBAAiB;AAAA,YACtC;AAAA,YACA,KAAK;AAAA,cACH,YAAW,oBAAI,KAAA,GAAO,YAAA;AAAA,cACtB,MAAM;AAAA,cACN,SAAS,KAAK,UAAU;AAAA,gBACtB,MAAM;AAAA,gBACN,SAAS;AAAA,gBACT,OAAO;AAAA,gBACP,SAAS;AAAA,cAAA,CACV;AAAA,YAAA;AAAA,UACH,CACD;AAAA,QACH;AAEA,YAAI;AACF,gBAAM,gBAAgB,MAAM,KAAK,oBAAoB,aAAa;AAAA,YAChE,SAAS;AAAA,YACT;AAAA,YACA,SAAS,QAAQ;AAAA,YACjB,OAAO,QAAQ;AAAA,UAAA,CAChB;AACDA,mBAAO,KAAK,uCAAuC,aAAa;AAGhE,cAAI,KAAK,cAAc;AACrB,iBAAK,aAAa,KAAK,iBAAiB;AAAA,cACtC;AAAA,cACA,KAAK;AAAA,gBACH,YAAW,oBAAI,KAAA,GAAO,YAAA;AAAA,gBACtB,MAAM;AAAA,gBACN,SAAS,KAAK,UAAU;AAAA,kBACtB,MAAM;AAAA,kBACN,SAAS;AAAA,kBACT,OAAO;AAAA,kBACP,SAAS;AAAA,gBAAA,CACV;AAAA,cAAA;AAAA,YACH,CACD;AAAA,UACH;AAAA,QACF,SAAS,cAAc;AACrBA,mBAAO,MAAM,mCAAmC,aAAa,OAAO,EAAE;AACtE,gBAAM,IAAI,MAAM,mCAAmC,aAAa,OAAO,EAAE;AAAA,QAC3E;AAAA,MACF;AAGA,UAAI,UAAU,QAAQ,iBACnB,QAAQ,WAAW,SAAS,iBAAiB,QAAQ,OAAO,KAC7D,SAAS,iBAAiB,SAAS,gBAAgB;AAErD,UAAI,CAAC,SAAS;AACZ,cAAM,IAAI,MAAM,mCAAmC;AAAA,MACrD;AAGA,UAAI,SAAS,gBAAgB,UAAU,CAAC,QAAQ,WAAW,KAAK,KAAK,CAAC,QAAQ,WAAW,KAAK,KAAK,CAAC,QAAQ,WAAW,MAAM,GAAG;AAC9H,kBAAU,OAAO,OAAO;AACxBA,iBAAO,KAAK,gCAAgC,OAAO,EAAE;AAAA,MACvD;AAGA,YAAM,KAAK,GAAG;AAAA,QACZ;AAAA,QACA,CAAC,YAAY,SAAS,SAAS;AAAA,MAAA;AAGjCA,eAAO,KAAK,8BAA8B,OAAO,kBAAkB,UAAU,EAAE;AAG/E,YAAM,MAAM;AAAA,QACV,GAAG,QAAA;AAAA,QACH,UAAU;AAAA,QACV,GAAG,QAAQ;AAAA,MAAA;AAIb,aAAO,IAAI;AAEX,YAAM,CAAC,KAAK,GAAG,IAAI,IAAI,QAAQ,MAAM,GAAG;AACxC,YAAM,eAAe,MAAM,KAAK,MAAM;AAAA,QACpC,KAAK;AAAA,QACL;AAAA,QACA,OAAO;AAAA,QACP,OAAO,CAAC,QAAQ,QAAQ,MAAM;AAAA,MAAA,CAC/B;AAED,UAAI,CAAC,aAAa,KAAK;AACrB,cAAM,IAAI,MAAM,yBAAyB;AAAA,MAC3C;AAGA,WAAK,iBAAiB,IAAI,WAAW,YAAY;AAEjDA,eAAO,KAAK,6BAA6B,aAAa,GAAG,EAAE;AAE3D,YAAM,KAAK,GAAG;AAAA,QACZ;AAAA,QACA,CAAC,aAAa,KAAK,SAAS;AAAA,MAAA;AAG9B,UAAI,eAAe;AAEnB,mBAAa,OAAO,GAAG,QAAQ,CAAC,SAAS;AACvC,cAAM,SAAS,KAAK,SAAA;AACpB,aAAK,oBAAoB,WAAW,UAAU,MAAM;AACpD,aAAK,eAAe,WAAW,QAAQ,WAAW;AAElD,YAAI,CAAC,cAAc;AACjB,yBAAe,KAAK,oBAAoB,QAAQ,SAAS,SAAS;AAClE,cAAI,cAAc;AAChBA,qBAAO,KAAK,iBAAiB,YAAY,gBAAgB,SAAS,EAAE;AACpE,iBAAK,kBAAkB,WAAW,YAAY;AAAA,UAChD;AAAA,QACF;AAAA,MACF,CAAC;AAED,mBAAa,OAAO,GAAG,QAAQ,CAAC,SAAS;AACvC,cAAM,SAAS,KAAK,SAAA;AACpB,aAAK,oBAAoB,WAAW,UAAU,MAAM;AACpD,aAAK,eAAe,WAAW,QAAQ,WAAW;AAElD,YAAI,CAAC,cAAc;AACjB,yBAAe,KAAK,oBAAoB,QAAQ,SAAS,SAAS;AAClE,cAAI,cAAc;AAChBA,qBAAO,KAAK,iBAAiB,YAAY,gBAAgB,SAAS,gBAAgB;AAClF,iBAAK,kBAAkB,WAAW,YAAY;AAAA,UAChD;AAAA,QACF;AAAA,MACF,CAAC;AAED,mBAAa,GAAG,SAAS,CAAC,UAAU;AAClCA,iBAAO,MAAM,6BAA6B,SAAS,KAAK,KAAK;AAC7D,aAAK,mBAAmB,WAAW,KAAK;AAAA,MAC1C,CAAC;AAED,mBAAa,GAAG,QAAQ,CAAC,MAAM,WAAW;AACxCA,iBAAO,KAAK,8BAA8B,SAAS,cAAc,IAAI,YAAY,MAAM,EAAE;AACzF,aAAK,kBAAkB,WAAW,MAAM,MAAM;AAAA,MAChD,CAAC;AAAA,IAEH,SAAS,OAAO;AACdA,eAAO,MAAM,4BAA4B,SAAS,KAAK,KAAK;AAC5D,YAAM,KAAK,GAAG;AAAA,QACZ;AAAA,QACA,CAAC,UAAU,MAAM,SAAS,SAAS;AAAA,MAAA;AAErC,YAAM;AAAA,IACR;AAAA,EACF;AAAA,EAEA,MAAM,YAAY,aAAa,YAAY,MAAM,UAAU,CAAA,GAAI;AAC7D,QAAI;AACF,UAAI,iBAAiB,CAAA;AAErB,UAAI,WAAW;AACb,cAAM,UAAU,MAAM,KAAK,GAAG;AAAA,UAC5B;AAAA,UACA,CAAC,WAAW,WAAW;AAAA,QAAA;AAEzB,YAAI,SAAS;AACX,yBAAe,KAAK,OAAO;AAAA,QAC7B;AAAA,MACF,WAAW,QAAQ,WAAW,QAAQ,OAAO;AAE3C,yBAAiB,MAAM,KAAK,GAAG;AAAA,UAC7B;AAAA,UACA,CAAC,aAAa,QAAQ,SAAS,QAAQ,OAAO,cAAc,YAAY,SAAS;AAAA,QAAA;AAAA,MAErF,OAAO;AAEL,yBAAiB,MAAM,KAAK,GAAG;AAAA,UAC7B;AAAA,UACA,CAAC,aAAa,cAAc,YAAY,SAAS;AAAA,QAAA;AAAA,MAErD;AAEA,YAAM,aAAa,CAAA;AAEnB,iBAAW,WAAW,gBAAgB;AACpC,cAAMI,WAAU,KAAK,iBAAiB,IAAI,QAAQ,EAAE;AACpD,YAAIA,UAAS;AACXA,mBAAQ,KAAK,SAAS;AAEtB,qBAAW,MAAM;AACf,gBAAI,CAACA,SAAQ,QAAQ;AACnBA,uBAAQ,KAAK,SAAS;AAAA,YACxB;AAAA,UACF,GAAG,GAAI;AAAA,QACT;AAEA,cAAM,KAAK,cAAc,wBAAwB,QAAQ,EAAE;AAE3D,cAAM,KAAK,GAAG;AAAA,UACZ;AAAA,UACA,CAAC,WAAW,QAAQ,EAAE;AAAA,QAAA;AAGxB,aAAK,iBAAiB,OAAO,QAAQ,EAAE;AACvC,mBAAW,KAAK,QAAQ,EAAE;AAAA,MAC5B;AAEA,aAAO;AAAA,QACL,SAAS;AAAA,QACT,SAAS;AAAA,QACT,YAAW,oBAAI,KAAA,GAAO,YAAA;AAAA,MAAY;AAAA,IAEtC,SAAS,OAAO;AACdJ,eAAO,MAAM,2BAA2B,KAAK;AAC7C,YAAM;AAAA,IACR;AAAA,EACF;AAAA,EAEA,MAAM,iBAAiB,aAAa,UAAU,IAAI;AAChD,QAAI;AACF,UAAIU,SAAQ;AACZ,YAAM,SAAS,CAAC,WAAW;AAE3B,UAAI,QAAQ,WAAW,QAAQ,OAAO;AACpC,QAAAA,UAAS;AACT,eAAO,KAAK,QAAQ,SAAS,QAAQ,KAAK;AAAA,MAC5C;AAEA,MAAAA,UAAS;AAET,YAAM,WAAW,MAAM,KAAK,GAAG,IAAIA,QAAO,MAAM;AAEhD,YAAM,UAAU,CAAA;AAEhB,iBAAW,WAAW,UAAU;AAC9B,cAAM,OAAO,KAAK,MAAM,QAAQ,QAAQ,IAAI;AAC5C,YAAI,SAAS;AAEb,YAAI,QAAQ,WAAW,aAAa,KAAK,OAAO;AAC9C,gBAAM,cAAc,MAAM,KAAK,cAAc,YAAY,KAAK,OAAO,GAAI;AACzE,mBAAS;AAAA,YACP,YAAY,YAAY;AAAA,YACxB,YAAW,oBAAI,KAAA,GAAO,YAAA;AAAA,YACtB,cAAc,YAAY;AAAA,UAAA;AAAA,QAE9B;AAEA,cAAM,aAAa,MAAM,KAAK,GAAG;AAAA,UAC/B;AAAA,UACA,CAAC,QAAQ,EAAE;AAAA,QAAA;AAGb,gBAAQ,KAAK;AAAA,UACX,WAAW,QAAQ;AAAA,UACnB,SAAS,QAAQ;AAAA,UACjB,OAAO,QAAQ;AAAA,UACf,YAAY,QAAQ;AAAA,UACpB,QAAQ,QAAQ;AAAA,UAChB,SAAS,QAAQ;AAAA,UACjB,KAAK,QAAQ;AAAA,UACb,MAAM,QAAQ;AAAA,UACd;AAAA,UACA,WAAW,QAAQ;AAAA,UACnB,WAAW,QAAQ;AAAA,UACnB,cAAc,QAAQ;AAAA,UACtB;AAAA,UACA,MAAM;AAAA,YACJ,QAAQ,WAAW,IAAI,SAAO,IAAI,OAAO,EAAE,QAAA;AAAA,UAAQ;AAAA,QACrD,CACD;AAAA,MACH;AAEA,aAAO;AAAA,QACL;AAAA,QACA,SAAS,QAAQ;AAAA,QACjB,OAAO,QAAQ;AAAA,QACf,UAAU;AAAA,MAAA;AAAA,IAEd,SAAS,OAAO;AACdV,eAAO,MAAM,8CAA8C,WAAW,KAAK,KAAK;AAChF,YAAM;AAAA,IACR;AAAA,EACF;AAAA,EAEA,MAAM,oBAAoB,aAAa,UAAU,IAAI;AACnD,QAAI;AACF,YAAM,YAAY,MAAM,KAAK,GAAG;AAAA,QAC9B;AAAA,QACA,CAAC,WAAW;AAAA,MAAA;AAGd,UAAI,CAAC,WAAW;AACd,cAAM,IAAI,MAAM,qBAAqB;AAAA,MACvC;AAGA,UAAI,aAAa,QAAQ,cAAc,UAAU;AACjD,UAAI,QAAQ,WAAW,QAAQ,OAAO;AACpC,cAAM,gBAAgB,UAAU,kBAAkB,UAAU;AAC5D,qBAAa,KAAK,KAAK,eAAe,QAAQ,SAAS,QAAQ,KAAK;AACpEA,iBAAO,KAAK,mDAAmD,UAAU,EAAE;AAAA,MAC7E;AAEA,YAAM,WAAW,MAAM,KAAK,eAAe,aAAa,EAAE,SAAS,QAAQ,SAAS,OAAO,QAAQ,MAAA,CAAO;AAE1G,UAAI,UAAU,QAAQ;AACtB,UAAI,YAAY,QAAQ;AACtB,kBAAU,SAAS,aAAa;AAAA,MAClC;AAEA,UAAI,CAAC,SAAS;AACZ,cAAM,IAAI,MAAM,6BAA6B;AAAA,MAC/C;AAEA,YAAM,WAAW;AAAA,QACf,KAAK,QAAQ,aAAa,wBAAwB;AAAA,QAClD,MAAM,QAAQ,aAAa,8BAA8B;AAAA,QACzD,MAAM,QAAQ,aAAa,wBAAwB;AAAA,QACnD,KAAK;AAAA,QACL,QAAQ;AAAA,MAAA;AAGV,YAAM,UAAU,SAAS,OAAO;AAChC,UAAI,CAAC,SAAS;AACZ,cAAM,IAAI,MAAM,gCAAgC,OAAO,EAAE;AAAA,MAC3D;AAEA,YAAM,YAAY,KAAK,IAAA;AAEvB,aAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,cAAM,CAAC,KAAK,GAAG,IAAI,IAAI,QAAQ,MAAM,GAAG;AACxC,cAAM,eAAe,MAAM,KAAK,MAAM;AAAA,UACpC,KAAK;AAAA,UACL,OAAO;AAAA,UACP,KAAK,EAAE,GAAG,QAAA,KAAa,UAAU,cAAA;AAAA,QAAc,CAChD;AAED,YAAI,SAAS;AAEb,qBAAa,OAAO,GAAG,QAAQ,CAAC,SAAS;AACvC,oBAAU,KAAK,SAAA;AACfA,mBAAO,KAAK,mBAAmB,KAAK,WAAW,KAAA,CAAM,EAAE;AAAA,QACzD,CAAC;AAED,qBAAa,OAAO,GAAG,QAAQ,CAAC,SAAS;AACvC,oBAAU,KAAK,SAAA;AACfA,mBAAO,KAAK,mBAAmB,KAAK,WAAW,KAAA,CAAM,EAAE;AAAA,QACzD,CAAC;AAED,qBAAa,GAAG,SAAS,CAAC,UAAU;AAClCA,mBAAO,MAAM,0BAA0B,KAAK;AAC5C,iBAAO,KAAK;AAAA,QACd,CAAC;AAED,qBAAa,GAAG,QAAQ,CAAC,SAAS;AAChC,gBAAM,WAAW,KAAK,IAAA,IAAQ;AAC9BA,mBAAO,KAAK,oCAAoC,IAAI,UAAU,QAAQ,IAAI;AAE1E,cAAI,SAAS,GAAG;AACd,oBAAQ;AAAA,cACN,SAAS;AAAA,cACT;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,cACA,SAAS,QAAQ;AAAA,cACjB,OAAO,QAAQ;AAAA,cACf,cAAa,oBAAI,KAAA,GAAO,YAAA;AAAA,YAAY,CACrC;AAAA,UACH,OAAO;AACL,mBAAO,IAAI,MAAM,iCAAiC,IAAI,KAAK,MAAM,EAAE,CAAC;AAAA,UACtE;AAAA,QACF,CAAC;AAAA,MACH,CAAC;AAAA,IACH,SAAS,OAAO;AACdA,eAAO,MAAM,+CAA+C,WAAW,KAAK,KAAK;AACjF,YAAM;AAAA,IACR;AAAA,EACF;AAAA,EAEA,MAAM,oBAAoB,WAAW,MAAM,SAAS;AAClD,QAAI;AACF,YAAM,KAAK,GAAG;AAAA,QACZ;AAAA,QACA,CAAC,WAAW,MAAM,OAAO;AAAA,MAAA;AAG3B,WAAK,aAAa,WAAW,MAAM,OAAO;AAAA,IAC5C,SAAS,OAAO;AACdA,eAAO,MAAM,6CAA6C,SAAS,KAAK,KAAK;AAAA,IAC/E;AAAA,EACF;AAAA,EAEA,MAAM,mBAAmB,WAAW,OAAO;AACzC,QAAI;AACF,YAAM,KAAK,GAAG;AAAA,QACZ;AAAA,QACA,CAAC,UAAU,MAAM,SAAS,SAAS;AAAA,MAAA;AAGrC,YAAM,KAAK,oBAAoB,WAAW,UAAU,kBAAkB,MAAM,OAAO,EAAE;AAAA,IACvF,SAAS,SAAS;AAChBA,eAAO,MAAM,4CAA4C,SAAS,KAAK,OAAO;AAAA,IAChF;AAAA,EACF;AAAA,EAEA,MAAM,kBAAkB,WAAW,MAAM,QAAQ;AAC/C,QAAI;AACF,YAAM,SAAS,SAAS,IAAI,YAAY;AACxC,YAAM,UAAU,SAAS,4BAA4B,MAAM,KAAK,4BAA4B,IAAI;AAEhG,YAAM,KAAK,GAAG;AAAA,QACZ;AAAA,QACA,CAAC,QAAQ,SAAS,IAAI,UAAU,MAAM,SAAS;AAAA,MAAA;AAGjD,YAAM,KAAK,oBAAoB,WAAW,UAAU,OAAO;AAC3D,YAAM,KAAK,cAAc,wBAAwB,SAAS;AAE1D,WAAK,iBAAiB,OAAO,SAAS;AAGtC,YAAM,mBAAmB,SAAS,KAAK,EAAC,iCAAQ,SAAS,eAAc,EAAC,iCAAQ,SAAS;AAEzF,UAAI,kBAAkB;AAEpB,cAAM,UAAU,MAAM,KAAK,GAAG;AAAA,UAC5B;AAAA,UACA,CAAC,SAAS;AAAA,QAAA;AAGZ,YAAI,WAAW,QAAQ,cAAc;AACnCA,mBAAO,KAAK,WAAW,SAAS,+BAA+B,IAAI,aAAa,MAAM,GAAG;AAGzF,gBAAM,eAAe;AAAA;AAAA,cACJ,QAAQ,QAAQ,IAAI,QAAQ,MAAM;AAAA;AAAA,aACnC,IAAI;AAAA,UACP,UAAU,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQ7B,cAAI;AACF,kBAAM,MAAM,KAAK,iCAAiC,QAAQ,YAAY,IAAI;AAAA,cACxE,SAAS;AAAA,YAAA,CACV;AACDA,qBAAO,KAAK,gDAAgD,SAAS,EAAE;AAAA,UACzE,SAAS,OAAO;AACdA,qBAAO,MAAM,+CAA+C,KAAK;AAAA,UACnE;AAAA,QACF;AAAA,MACF;AAAA,IACF,SAAS,OAAO;AACdA,eAAO,MAAM,2CAA2C,SAAS,KAAK,KAAK;AAAA,IAC7E;AAAA,EACF;AAAA,EAEA,iBAAiB,WAAW,KAAK;AAC/B,QAAI,CAAC,KAAK,eAAe,IAAI,SAAS,GAAG;AACvC,WAAK,eAAe,IAAI,WAAW,oBAAI,KAAK;AAAA,IAC9C;AACA,SAAK,eAAe,IAAI,SAAS,EAAE,IAAI,GAAG;AAAA,EAC5C;AAAA,EAEA,oBAAoB,WAAW,KAAK;AAClC,UAAM,cAAc,KAAK,eAAe,IAAI,SAAS;AACrD,QAAI,aAAa;AACf,kBAAY,OAAO,GAAG;AACtB,UAAI,YAAY,SAAS,GAAG;AAC1B,aAAK,eAAe,OAAO,SAAS;AAAA,MACtC;AAAA,IACF;AAAA,EACF;AAAA,EAEA,aAAa,WAAW,MAAM,SAAS;AACrC,UAAM,cAAc,KAAK,eAAe,IAAI,SAAS;AACrD,QAAI,aAAa;AACf,YAAM,OAAO,KAAK,UAAU;AAAA,QAC1B,YAAW,oBAAI,KAAA,GAAO,YAAA;AAAA,QACtB;AAAA,QACA;AAAA,MAAA,CACD;AAED,kBAAY,QAAQ,CAAA,QAAO;AACzB,YAAI,MAAM;AAAA,QAAqB,IAAI;AAAA;AAAA,CAAM;AAAA,MAC3C,CAAC;AAAA,IACH;AAAA,EACF;AAAA,EAEA,gBAAgB,WAAW,QAAQ,MAAM,KAAK;AAC5C,UAAM,cAAc,KAAK,eAAe,IAAI,SAAS;AACrD,QAAI,aAAa;AACf,YAAM,OAAO,KAAK,UAAU;AAAA,QAC1B;AAAA,QACA;AAAA,QACA;AAAA,MAAA,CACD;AAED,kBAAY,QAAQ,CAAA,QAAO;AACzB,YAAI,MAAM;AAAA,QAAwB,IAAI;AAAA;AAAA,CAAM;AAAA,MAC9C,CAAC;AAAA,IACH;AAAA,EACF;AAAA,EAEA,eAAe;AACb,UAAM,aAAa,GAAG,kBAAA;AACtB,eAAW,QAAQ,OAAO,KAAK,UAAU,GAAG;AAC1C,iBAAW,SAAS,WAAW,IAAI,GAAG;AACpC,YAAI,MAAM,WAAW,UAAU,CAAC,MAAM,UAAU;AAC9C,iBAAO,MAAM;AAAA,QACf;AAAA,MACF;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA,EAEA,oBAAoB,QAAQ,WAAW;AAErC,UAAM,WAAW;AAAA,MACf,QAAQ;AAAA,QACN;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MAAA;AAAA,MAEF,OAAO;AAAA,QACL;AAAA,QACA;AAAA,QACA;AAAA,MAAA;AAAA,MAEF,KAAK;AAAA,QACH;AAAA,QACA;AAAA,MAAA;AAAA,MAEF,MAAM;AAAA,QACJ;AAAA,QACA;AAAA,MAAA;AAAA,IACF;AAIF,UAAM,oBAAoB,SAAS,SAAS,KAAK,CAAA;AACjD,eAAW,WAAW,mBAAmB;AACvC,YAAM,QAAQ,OAAO,MAAM,OAAO;AAClC,UAAI,OAAO;AACT,cAAM,OAAO,SAAS,MAAM,CAAC,GAAG,EAAE;AAClCA,iBAAO,KAAK,iBAAiB,IAAI,QAAQ,SAAS,cAAc;AAChE,eAAO;AAAA,MACT;AAAA,IACF;AAGA,UAAM,kBAAkB;AAAA,MACtB;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IAAA;AAGF,eAAW,WAAW,iBAAiB;AACrC,YAAM,UAAU,MAAM,KAAK,OAAO,SAAS,OAAO,CAAC;AACnD,UAAI,QAAQ,SAAS,GAAG;AACtB,cAAM,OAAO,SAAS,QAAQ,CAAC,EAAE,CAAC,GAAG,EAAE;AAEvC,YAAI,QAAQ,OAAQ,QAAQ,KAAM;AAChCA,mBAAO,KAAK,iBAAiB,IAAI,uBAAuB;AACxD,iBAAO;AAAA,QACT;AAAA,MACF;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,MAAM,kBAAkB,WAAW,MAAM;AACvC,QAAI;AACF,YAAM,OAAO;AAAA,QACX,OAAO,oBAAoB,IAAI;AAAA,QAC/B,SAAS,UAAU,KAAK,aAAA,CAAc,IAAI,IAAI;AAAA,QAC9C,QAAQ;AAAA,MAAA;AAGV,YAAM,KAAK,GAAG;AAAA,QACZ;AAAA,QACA,CAAC,MAAM,KAAK,UAAU,IAAI,GAAG,SAAS;AAAA,MAAA;AAIxC,YAAM,KAAK,cAAc,qBAAqB,MAAM,SAAS;AAE7DA,eAAO,KAAK,mBAAmB,SAAS,uBAAuB,IAAI,EAAE;AAGrE,WAAK,gBAAgB,WAAW,iBAAiB,MAAM,KAAK,KAAK;AAGjE,WAAK,iBAAiB,WAAW,IAAI;AAAA,IACvC,SAAS,OAAO;AACdA,eAAO,MAAM,mCAAmC,SAAS,KAAK,KAAK;AAAA,IACrE;AAAA,EACF;AAAA,EAEA,MAAM,iBAAiB,WAAW,MAAM;AACtC,UAAM,MAAM,oBAAoB,IAAI;AAEpC,eAAW,YAAY;AACrB,UAAI;AACF,cAAM,aAAa,MAAM,KAAK,cAAc,cAAc,KAAK;AAAA,UAC7D,aAAa;AAAA,UACb,cAAc;AAAA,QAAA,CACf;AAED,YAAI,WAAW,SAAS;AACtB,gBAAM,KAAK,GAAG;AAAA,YACZ;AAAA,YACA,CAAC,WAAW,SAAS;AAAA,UAAA;AAEvB,eAAK,gBAAgB,WAAW,WAAW,MAAM,GAAG;AAAA,QACtD,OAAO;AACL,gBAAM,KAAK,GAAG;AAAA,YACZ;AAAA,YACA,CAAC,UAAU,0BAA0B,SAAS;AAAA,UAAA;AAEhD,eAAK,gBAAgB,WAAW,UAAU,MAAM,IAAI;AAAA,QACtD;AAAA,MACF,SAAS,OAAO;AACdA,iBAAO,MAAM,mCAAmC,SAAS,KAAK,KAAK;AAAA,MACrE;AAAA,IACF,GAAG,GAAI;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,iBAAiB,WAAW;AAChCA,aAAO,KAAK,0BAA0B,SAAS,EAAE;AAEjD,QAAI;AAEF,YAAM,cAAc,KAAK,iBAAiB,IAAI,SAAS;AACvD,UAAI,eAAe,YAAY,SAAS;AACtC,cAAMI,WAAU,YAAY;AAE5B,YAAI,CAACA,SAAQ,QAAQ;AAEnBA,mBAAQ,KAAK,SAAS;AAGtB,gBAAM,IAAI,QAAQ,CAAA,YAAW,WAAW,SAAS,GAAI,CAAC;AAEtD,cAAI,CAACA,SAAQ,QAAQ;AACnBJ,qBAAO,KAAK,WAAW,SAAS,2CAA2C;AAC3EI,qBAAQ,KAAK,SAAS;AAAA,UACxB;AAAA,QACF;AAGA,aAAK,iBAAiB,OAAO,SAAS;AAAA,MACxC;AAGA,YAAM,UAAU,MAAM,KAAK,GAAG,IAAI,mDAAmD,CAAC,SAAS,CAAC;AAChG,UAAI,WAAW,QAAQ,MAAM;AAC3B,cAAM,KAAK,kBAAkB,QAAQ,IAAI;AAAA,MAC3C;AAGA,YAAM,KAAK,cAAc,wBAAwB,SAAS;AAAA,IAE5D,SAAS,OAAO;AACdJ,eAAO,MAAM,sCAAsC,SAAS,KAAK,KAAK;AAAA,IAExE;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,kBAAkB,MAAM;AAE5B,QAAI;AAEF,YAAM,cAAc,MAAM,QAAQ,CAAC,OAAO,IAAI,IAAI,EAAE,CAAC;AAErD,UAAI,OAAO;AACX,kBAAY,OAAO,GAAG,QAAQ,CAAC,SAAS;AACtC,gBAAQ,KAAK,SAAA;AAAA,MACf,CAAC;AAED,YAAM,IAAI,QAAQ,CAAC,SAAS,WAAW;AACrC,oBAAY,GAAG,SAAS,CAAC,SAAS;AAChC,kBAAA;AAAA,QACF,CAAC;AACD,oBAAY,GAAG,SAAS,MAAM;AAAA,MAChC,CAAC;AAGD,YAAM,UAAU,KAAK,OAAO,MAAM,IAAI,EAAE,OAAO,CAAA,QAAO,GAAG;AACzD,iBAAW,OAAO,SAAS;AACzB,YAAI;AACF,kBAAQ,KAAK,SAAS,GAAG,GAAG,SAAS;AACrCA,mBAAO,KAAK,kBAAkB,GAAG,eAAe,IAAI,EAAE;AAAA,QACxD,SAAS,GAAG;AAAA,QAEZ;AAAA,MACF;AAAA,IACF,SAAS,OAAO;AACdA,eAAO,KAAK,oCAAoC,IAAI,KAAK,MAAM,OAAO;AAAA,IAExE;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,eAAe,aAAa;AAChCA,aAAO,KAAK,iCAAiC,YAAY,EAAE,EAAE;AAE7D,QAAI;AAEF,YAAM,KAAK,iBAAiB,YAAY,EAAE;AAE1C,YAAM,OAAO,YAAY,OAAO,KAAK,MAAM,YAAY,IAAI,IAAI,CAAA;AAC/D,YAAM,OAAO,YAAY;AAEzB,UAAI,CAAC,MAAM;AACT,cAAM,IAAI,MAAM,2BAA2B;AAAA,MAC7C;AAGA,YAAM,cAAc,MAAM,KAAK,cAAc,gBAAgB,IAAI;AACjE,UAAI,CAAC,aAAa;AAChBA,iBAAO,KAAK,QAAQ,IAAI,uCAAuC,YAAY,EAAE,EAAE;AAE/E,cAAM,UAAU,MAAM,KAAK,cAAc,aAAA;AACzCA,iBAAO,KAAK,sBAAsB,OAAO,gBAAgB,YAAY,EAAE,EAAE;AAGzE,cAAM,KAAK,cAAc,qBAAqB,SAAS,YAAY,EAAE;AACrE,oBAAY,OAAO;AAAA,MACrB;AAGA,YAAM,KAAK,GAAG;AAAA,QACZ;AAAA,QACA,CAAC,YAAY,YAAY,EAAE;AAAA,MAAA;AAI7B,YAAM,UAAU,KAAK,MAAM,YAAY,OAAO;AAG9C,YAAM,MAAM,EAAE,GAAG,QAAA,IAAA;AACjB,aAAO,IAAI;AAGX,YAAM,eAAe,MAAM,QAAQ,KAAK,QAAQ,MAAM;AAAA,QACpD,KAAK,YAAY;AAAA,QACjB;AAAA,QACA,OAAO;AAAA,MAAA,CACR;AAGD,WAAK,iBAAiB,IAAI,YAAY,IAAI;AAAA,QACxC,SAAS;AAAA,QACT,MAAM,YAAY;AAAA,QAClB,aAAa,YAAY;AAAA,QACzB,SAAS,YAAY;AAAA,QACrB,OAAO,YAAY;AAAA,MAAA,CACpB;AAGD,mBAAa,OAAO,GAAG,QAAQ,CAAC,SAAS;AACvC,cAAM,UAAU,KAAK,SAAA;AACrB,aAAK,oBAAoB,YAAY,IAAI,UAAU,OAAO;AAC1D,aAAK,eAAe,YAAY,IAAI,SAAS,YAAY,YAAY;AAAA,MACvE,CAAC;AAED,mBAAa,OAAO,GAAG,QAAQ,CAAC,SAAS;AACvC,cAAM,UAAU,KAAK,SAAA;AACrB,aAAK,oBAAoB,YAAY,IAAI,UAAU,OAAO;AAC1D,aAAK,eAAe,YAAY,IAAI,SAAS,YAAY,YAAY;AAAA,MACvE,CAAC;AAED,mBAAa,GAAG,SAAS,CAAC,UAAU;AAClCA,iBAAO,MAAM,6BAA6B,YAAY,EAAE,KAAK,KAAK;AAClE,aAAK,mBAAmB,YAAY,IAAI,MAAM,OAAO;AAAA,MACvD,CAAC;AAED,mBAAa,GAAG,QAAQ,CAAC,MAAM,WAAW;AACxCA,iBAAO,KAAK,8BAA8B,YAAY,EAAE,UAAU,IAAI,YAAY,MAAM,EAAE;AAC1F,aAAK,kBAAkB,YAAY,IAAI,MAAM,MAAM;AAAA,MACrD,CAAC;AAGD,YAAM,UAAU;AAAA,QACd,OAAO,oBAAoB,YAAY,IAAI;AAAA,QAC3C,QAAQ;AAAA,MAAA;AAGV,YAAM,KAAK,GAAG;AAAA,QACZ;AAAA,QACA,CAAC,KAAK,UAAU,OAAO,GAAG,aAAa,KAAK,YAAY,EAAE;AAAA,MAAA;AAI5D,YAAM,MAAM,QAAQ;AACpB,iBAAW,YAAY;AACrB,YAAI;AACF,gBAAM,aAAa,MAAM,KAAK,cAAc,cAAc,KAAK;AAAA,YAC7D,aAAa;AAAA,YACb,cAAc;AAAA,UAAA,CACf;AAED,cAAI,WAAW,SAAS;AACtB,kBAAM,KAAK,GAAG;AAAA,cACZ;AAAA,cACA,CAAC,WAAW,YAAY,EAAE;AAAA,YAAA;AAE5BA,qBAAO,KAAK,kCAAkC,YAAY,EAAE,EAAE;AAAA,UAChE,OAAO;AACL,kBAAM,KAAK,GAAG;AAAA,cACZ;AAAA,cACA,CAAC,UAAU,4BAA4B,YAAY,EAAE;AAAA,YAAA;AAAA,UAEzD;AAAA,QACF,SAAS,OAAO;AACdA,mBAAO,MAAM,6CAA6C,YAAY,EAAE,KAAK,KAAK;AAAA,QACpF;AAAA,MACF,GAAG,GAAI;AAEP,aAAO;AAAA,QACL,SAAS;AAAA,QACT,WAAW,YAAY;AAAA,QACvB,MAAM,YAAY;AAAA,QAClB,KAAK,QAAQ;AAAA,MAAA;AAAA,IAEjB,SAAS,OAAO;AACdA,eAAO,MAAM,6BAA6B,YAAY,EAAE,KAAK,KAAK;AAGlE,YAAM,KAAK,GAAG;AAAA,QACZ;AAAA,QACA,CAAC,UAAU,MAAM,SAAS,YAAY,EAAE;AAAA,MAAA;AAG1C,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,wBAAwB;AACtB,gBAAY,YAAY;AACtB,UAAI;AACF,cAAM,KAAK,8BAAA;AAAA,MACb,SAAS,OAAO;AACdA,iBAAO,MAAM,mCAAmC,KAAK;AAAA,MACvD;AAAA,IACF,GAAG,KAAK,mBAAmB;AAE3BA,aAAO,KAAK,gDAAgD,KAAK,mBAAmB,KAAK;AAAA,EAC3F;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,gCAAgC;AACpC,UAAM,kBAAkB,MAAM,KAAK,GAAG;AAAA,MACpC;AAAA,MACA,CAAC,SAAS;AAAA,IAAA;AAGZ,eAAW,WAAW,iBAAiB;AACrC,UAAI;AACF,cAAM,KAAK,mBAAmB,OAAO;AAAA,MACvC,SAAS,OAAO;AACdA,iBAAO,MAAM,mCAAmC,QAAQ,EAAE,KAAK,KAAK;AAAA,MACtE;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,mBAAmB,SAAS;AAChC,UAAM,OAAO,QAAQ,OAAO,KAAK,MAAM,QAAQ,IAAI,IAAI,CAAA;AACvD,UAAM,MAAM,KAAK;AAEjB,QAAI,CAAC,KAAK;AACRA,eAAO,KAAK,WAAW,QAAQ,EAAE,oCAAoC;AACrE;AAAA,IACF;AAGA,UAAM,cAAc,KAAK,iBAAiB,IAAI,QAAQ,EAAE;AACxD,QAAI,eAAe,YAAY,WAAW,YAAY,QAAQ,QAAQ;AACpEA,eAAO,KAAK,WAAW,QAAQ,EAAE,oCAAoC;AACrE,YAAM,KAAK,qBAAqB,SAAS,oBAAoB;AAC7D;AAAA,IACF;AAGA,QAAI;AACF,YAAM,eAAe,MAAM,KAAK,cAAc,YAAY,KAAK,GAAK;AAEpE,UAAI,CAAC,aAAa,SAAS;AACzBA,iBAAO,KAAK,WAAW,QAAQ,EAAE,yBAAyB,aAAa,KAAK,EAAE;AAK9E,cAAM,KAAK,GAAG;AAAA,UACZ;AAAA,UACA,CAAC,wBAAwB,aAAa,KAAK,IAAI,QAAQ,EAAE;AAAA,QAAA;AAAA,MAE7D,OAAO;AAEL,cAAM,KAAK,GAAG;AAAA,UACZ;AAAA,UACA,CAAC,QAAQ,EAAE;AAAA,QAAA;AAAA,MAEf;AAAA,IACF,SAAS,OAAO;AACdA,eAAO,KAAK,WAAW,QAAQ,EAAE,wBAAwB,KAAK;AAAA,IAGhE;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,qBAAqB,SAAS,QAAQ;AAE1C,UAAM,kBAAkB,QAAQ,oBAAoB;AACpD,QAAI,mBAAmB,KAAK,oBAAoB;AAC9CA,eAAO,MAAM,WAAW,QAAQ,EAAE,mCAAmC,KAAK,kBAAkB,sBAAsB;AAClH,YAAM,KAAK,GAAG;AAAA,QACZ;AAAA,QACA,CAAC,UAAU,kCAAkC,MAAM,IAAI,QAAQ,EAAE;AAAA,MAAA;AAEnE;AAAA,IACF;AAEAA,aAAO,KAAK,sBAAsB,QAAQ,EAAE,aAAa,kBAAkB,CAAC,IAAI,KAAK,kBAAkB,MAAM,MAAM,EAAE;AAErH,QAAI;AAEF,YAAM,cAAc,KAAK,iBAAiB,IAAI,QAAQ,EAAE;AACxD,UAAI,eAAe,YAAY,SAAS;AACtC,YAAI;AACF,sBAAY,QAAQ,KAAK,SAAS;AAAA,QACpC,SAAS,GAAG;AAAA,QAEZ;AAAA,MACF;AAGA,YAAM,KAAK,GAAG;AAAA,QACZ;AAAA,QACA,CAAC,YAAY,kBAAkB,GAAG,eAAe,MAAM,IAAI,QAAQ,EAAE;AAAA,MAAA;AAIvE,YAAM,IAAI,QAAQ,CAAA,YAAW,WAAW,SAAS,KAAK,YAAY,CAAC;AAGnE,YAAM,KAAK,eAAe,OAAO;AAEjCA,eAAO,KAAK,kCAAkC,QAAQ,EAAE,EAAE;AAAA,IAC5D,SAAS,OAAO;AACdA,eAAO,MAAM,6BAA6B,QAAQ,EAAE,KAAK,KAAK;AAC9D,YAAM,KAAK,GAAG;AAAA,QACZ;AAAA,QACA,CAAC,UAAU,mBAAmB,MAAM,OAAO,IAAI,QAAQ,EAAE;AAAA,MAAA;AAAA,IAE7D;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,eAAe,WAAW,SAAS,aAAa;AAEpD,QAAI,aAAa;AACjB,eAAW,WAAW,KAAK,eAAe;AACxC,UAAI,QAAQ,KAAK,OAAO,GAAG;AACzB,qBAAa,QAAQ,KAAA;AACrB;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,WAAY;AAGjB,QAAI,YAAY,KAAK,gBAAgB,IAAI,WAAW;AACpD,QAAI,CAAC,WAAW;AACd,kBAAY;AAAA,QACV,iCAAiB,IAAA;AAAA,QACjB,WAAW;AAAA,QACX,UAAU;AAAA,QACV,YAAY;AAAA,MAAA;AAEd,WAAK,gBAAgB,IAAI,aAAa,SAAS;AAAA,IACjD;AAGA,QAAI,UAAU,YAAY;AACxBA,eAAO,MAAM,wCAAwC,WAAW,YAAY;AAC5E;AAAA,IACF;AAGA,UAAM,MAAM,KAAK,IAAA;AACjB,QAAI,UAAU,YAAa,MAAM,UAAU,WAAY,KAAO;AAC5DA,eAAO,MAAM,qCAAqC,WAAW,YAAY;AACzE;AAAA,IACF;AAGA,cAAU,YAAY,IAAI,UAAU;AAGpC,QAAI,UAAU,WAAW;AACvB,mBAAa,UAAU,SAAS;AAAA,IAClC;AAGA,cAAU,YAAY,WAAW,YAAY;AAC3C,YAAM,KAAK,mBAAmB,aAAa,SAAS;AAAA,IACtD,GAAG,KAAK,gBAAgB;AAAA,EAC1B;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,mBAAmB,aAAa,WAAW;AAC/C,UAAM,YAAY,KAAK,gBAAgB,IAAI,WAAW;AACtD,QAAI,CAAC,aAAa,UAAU,YAAY,SAAS,EAAG;AAGpD,cAAU,aAAa;AAEvB,QAAI;AAGF,YAAM,YAAY,MAAM,KAAK,GAAG;AAAA,QAC9B;AAAA,QACA,CAAC,WAAW;AAAA,MAAA;AAGd,UAAI,aAAa,UAAU,eAAe,UAAU;AAGlDA,iBAAO,KAAK,gDAAgD,WAAW,EAAE;AAAA,MAC3E;AAEAA,eAAO,KAAK,mDAAmD,WAAW,EAAE;AAG5E,YAAM,UAAU,MAAM,KAAK,GAAG;AAAA,QAC5B;AAAA,QACA,CAAC,SAAS;AAAA,MAAA;AAGZ,UAAI,CAAC,SAAS;AACZ,kBAAU,YAAY,MAAA;AACtB,kBAAU,aAAa;AACvB;AAAA,MACF;AAGA,YAAM,YAAY,MAAM,KAAK,UAAU,WAAW,EAAE,KAAK,aAAa;AAEtE,YAAM,eAAe;AAAA;AAAA,cACJ,QAAQ,QAAQ,IAAI,QAAQ,MAAM;AAAA;AAAA;AAAA,EACtC,SAAS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAYtB,YAAM,MAAM,KAAK,iCAAiC,WAAW,IAAI;AAAA,QAC/D,SAAS;AAAA,MAAA,CACV;AAGD,gBAAU,WAAW,KAAK,IAAA;AAC1B,gBAAU,YAAY,MAAA;AAEtBA,eAAO,KAAK,2DAA2D,WAAW,EAAE;AAAA,IACtF,SAAS,OAAO;AACdA,eAAO,MAAM,mCAAmC,KAAK;AAAA,IACvD,UAAA;AACE,gBAAU,aAAa;AAAA,IACzB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,mBAAmB,WAAW,cAAc;AAChD,QAAI;AACF,YAAM,KAAK,GAAG;AAAA,QACZ;AAAA,QACA,CAAC,UAAU,cAAc,SAAS;AAAA,MAAA;AAGpCA,eAAO,MAAM,WAAW,SAAS,YAAY,YAAY,EAAE;AAAA,IAC7D,SAAS,OAAO;AACdA,eAAO,MAAM,0CAA0C,KAAK;AAAA,IAC9D;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,kBAAkB,WAAW,MAAM,QAAQ;AAC/C,QAAI;AACF,YAAM,SAAS,SAAS,IAAI,YAAY;AACxC,YAAM,UAAU,SAAS,4BAA4B,MAAM,KAC5C,SAAS,IAAI,4BAA4B,IAAI,KAAK;AAEjE,YAAM,KAAK,GAAG;AAAA,QACZ;AAAA,QACA,CAAC,QAAQ,SAAS,SAAS;AAAA,MAAA;AAI7B,WAAK,iBAAiB,OAAO,SAAS;AAGtC,YAAM,UAAU,MAAM,KAAK,GAAG;AAAA,QAC5B;AAAA,QACA,CAAC,SAAS;AAAA,MAAA;AAGZ,UAAI,SAAS;AAEX,cAAM,gBAAgB,MAAM,KAAK,GAAG;AAAA,UAClC;AAAA,UACA,CAAC,QAAQ,cAAc,SAAS;AAAA,QAAA;AAIlC,YAAI,cAAc,UAAU,GAAG;AAC7B,gBAAM,YAAY,KAAK,gBAAgB,IAAI,QAAQ,YAAY;AAC/D,cAAI,WAAW;AACb,gBAAI,UAAU,WAAW;AACvB,2BAAa,UAAU,SAAS;AAAA,YAClC;AACA,iBAAK,gBAAgB,OAAO,QAAQ,YAAY;AAChDA,qBAAO,MAAM,2CAA2C,QAAQ,YAAY,EAAE;AAAA,UAChF;AAAA,QACF;AAAA,MACF;AAEAA,eAAO,KAAK,WAAW,SAAS,wBAAwB,MAAM,EAAE;AAAA,IAClE,SAAS,OAAO;AACdA,eAAO,MAAM,kCAAkC,KAAK;AAAA,IACtD;AAAA,EACF;AACF;AC78CO,MAAM,wBAAwB,MAAM;AAAA,EAKzC,YAAY,SAAiB,UAA+B,IAAI;AAC9D,UAAM,OAAO;AALf,gCAAO;AACP;AACA;AAIE,SAAK,OAAO,WAAW;AACvB,SAAK,UAAU;AAAA,EACjB;AACF;AAEO,MAAM,sBAAsB,MAAM;AAAA,EAIvC,YAAY,SAAiB;AAC3B,UAAM,OAAO;AAJf,gCAAO;AACP;AAIE,SAAK,OAAO,WAAW;AAAA,EACzB;AACF;AAEO,MAAM,qBAAqB,MAAM;AAAA,EAItC,YAAY,MAAiB,SAAiB;AAC5C,UAAM,OAAO;AAJf,gCAAO;AACP;AAIE,SAAK,OAAO;AAAA,EACd;AACF;AA2GO,SAAS,oBAAoB,OAA2B;AAC7D,QAAM,WAA0B;AAAA,IAC9B,OAAO;AAAA,MACL,MAAM,MAAM,QAAQ,WAAW;AAAA,MAC/B,SAAS,MAAM;AAAA,IAAA;AAAA,EACjB;AAGF,MAAI,MAAM,SAAS;AACjB,aAAS,MAAM,UAAU,MAAM;AAAA,EACjC;AAEA,SAAO;AACT;ACpJO,SAAS,cAAc,OAAoB;AAChD,MAAI,CAAC,OAAO;AACV,UAAM,IAAI,gBAAgB,0BAA0B,EAAE,OAAO,SAAS;AAAA,EACxE;AAEA,MAAI,CAAC,CAAC,UAAU,QAAQ,EAAE,SAAS,KAAK,GAAG;AACzC,UAAM,IAAI;AAAA,MACR;AAAA,MACA,EAAE,OAAO,SAAS,OAAO,MAAA;AAAA,IAAM;AAAA,EAEnC;AAEA,SAAO;AACT;AAEO,SAAS,eAAe,QAAqB;AAClD,MAAI,CAAC,UAAU,OAAO,WAAW,UAAU;AACzC,UAAM,IAAI,gBAAgB,2CAA2C,EAAE,OAAO,UAAU;AAAA,EAC1F;AAEA,MAAI,OAAO,OAAO,WAAW,GAAG;AAC9B,UAAM,IAAI,gBAAgB,0BAA0B,EAAE,OAAO,UAAU;AAAA,EACzE;AAEA,SAAO,OAAO,KAAA;AAChB;AAEO,SAAS,mBAAmB,YAAgC;AACjE,MAAI,CAAC,YAAY;AACf,WAAO;AAAA,EACT;AAEA,MAAI,OAAO,eAAe,UAAU;AAClC,UAAM,IAAI,gBAAgB,sCAAsC,EAAE,OAAO,cAAc;AAAA,EACzF;AAEA,QAAM,UAAU,KAAK,QAAQ,UAAU;AAEvC,MAAI,CAAC,GAAG,WAAW,OAAO,GAAG;AAC3B,UAAM,IAAI,gBAAgB,qCAAqC,OAAO,IAAI;AAAA,MACxE,OAAO;AAAA,MACP,MAAM;AAAA,IAAA,CACP;AAAA,EACH;AAEA,MAAI,CAAC,GAAG,SAAS,OAAO,EAAE,eAAe;AACvC,UAAM,IAAI,gBAAgB,4BAA4B,OAAO,IAAI;AAAA,MAC/D,OAAO;AAAA,MACP,MAAM;AAAA,IAAA,CACP;AAAA,EACH;AAEA,SAAO;AACT;AAEO,SAAS,oBAAoB,aAA0B;AAC5D,MAAI,CAAC,eAAe,OAAO,gBAAgB,UAAU;AACnD,UAAM,IAAI,gBAAgB,4BAA4B,EAAE,OAAO,eAAe;AAAA,EAChF;AAGA,QAAM,YAAY;AAClB,MAAI,CAAC,UAAU,KAAK,WAAW,GAAG;AAChC,UAAM,IAAI,gBAAgB,+BAA+B;AAAA,MACvD,OAAO;AAAA,MACP,OAAO;AAAA,IAAA,CACR;AAAA,EACH;AAEA,SAAO;AACT;AAEO,SAAS,gBAAgB,SAAsB;AACpD,MAAI,CAAC,WAAW,OAAO,YAAY,UAAU;AAC3C,UAAM,IAAI,gBAAgB,4CAA4C,EAAE,OAAO,WAAW;AAAA,EAC5F;AAEA,MAAI,QAAQ,OAAO,WAAW,GAAG;AAC/B,UAAM,IAAI,gBAAgB,2BAA2B,EAAE,OAAO,WAAW;AAAA,EAC3E;AAEA,MAAI,QAAQ,SAAS,KAAQ;AAC3B,UAAM,IAAI,gBAAgB,+CAA+C;AAAA,MACvE,OAAO;AAAA,MACP,QAAQ,QAAQ;AAAA,IAAA,CACjB;AAAA,EACH;AAEA,SAAO,QAAQ,KAAA;AACjB;AC/EA,MAAMA,WAAS,aAAa,gBAAgB;AAE5C,MAAMW,WAAS,QAAQ,OAAA;AAEvBA,SAAO,KAAK,YAAY,OAAO,KAAK,KAAK,SAAS;;AAChD,MAAI;AAEF,UAAM,QAAQC,cAAyB,IAAI,KAAK,KAAK;AACrD,UAAM,SAASC,eAA0B,IAAI,KAAK,MAAM;AAGxD,UAAM,qBAAqB,IAAI,KAAK;AACpC,QAAI,aAAa;AACjB,QAAI,oBAAoB;AACtB,mBAAaC,mBAA8B,kBAAkB;AAAA,IAC/D;AAGA,UAAM,OAAO,IAAI,KAAK,QAAQ,CAAA;AAC9B,QAAI,KAAK,QAAQ,CAAC,MAAM,QAAQ,KAAK,IAAI,GAAG;AAC1C,YAAM,IAAIC,gBAA2B,4BAA4B;AAAA,IACnE;AACA,QAAI,KAAK,UAAU,CAAC,MAAM,QAAQ,KAAK,MAAM,GAAG;AAC9C,YAAM,IAAIA,gBAA2B,8BAA8B;AAAA,IACrE;AACA,QAAI,KAAK,UAAU,CAAC,MAAM,QAAQ,KAAK,MAAM,GAAG;AAC9C,YAAM,IAAIA,gBAA2B,8BAA8B;AAAA,IACrE;AAGA,UAAM,cAAcN,GAAA;AAGpB,UAAM,EAAE,IAAI,cAAc,kBAAkB,iBAAiB,aAAa,mBAAA,IAAuB,IAAI,IAAI;AAGzG,UAAM,YAAY,OAAO,OAAO,YAAY;AAC1C,YAAM,aAAY,oBAAI,KAAA,GAAO,YAAA;AAG7B,YAAM,GAAG;AAAA,QACP;AAAA,QACA,CAAC,OAAO,WAAW;AAAA,MAAA;AAIrB,mBAAa,KAAK,OAAO,WAAW;AAAA,QAClC;AAAA,QACA;AAAA,QACA,MAAM;AAAA,QACN,SAAS,KAAK,UAAU;AAAA,UACtB,MAAM;AAAA,UACN,SAAS;AAAA,UACT;AAAA,UACA;AAAA,QAAA,CACD;AAAA,MAAA,CACF;AAAA,IACH;AAGA,UAAM,UAAU,YAAY,mBAAmB;AAG/C,QAAI,iBAAiB;AACnB,YAAM,aAAa,MAAM,gBAAgB,kBAAA;AACzC,UAAI,CAAC,YAAY;AACf,cAAM,SAAS,MAAM,QAAQ,IAAI;AAAA,UAC/B,gBAAgB,0BAAA;AAAA,UAChB,gBAAgB,eAAA;AAAA,UAChB,gBAAgB,qBAAA;AAAA,QAAqB,CACtC;AAED,cAAM,YAAY,OAAO,OAAO,CAAA,UAAS,CAAC,MAAM,OAAO;AACvD,cAAM,UAAU,UAAU,IAAI,CAAA,UAAS,MAAM,OAAO,EAAE,OAAO,OAAO;AAEpE,eAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,UAC1B,OAAO;AAAA,YACL,MAAM;AAAA,YACN,SAAS;AAAA,YACT,SAAS;AAAA,cACP,WAAW,UAAU,IAAI,CAAA,UAAS,MAAM,IAAI;AAAA,cAC5C;AAAA,YAAA;AAAA,UACF;AAAA,QACF,CACD;AAAA,MACH;AAAA,IACF;AAGA,UAAM,GAAG;AAAA,MACP;AAAA;AAAA,MAEA;AAAA,QAAC;AAAA,QAAa;AAAA,QAAO,gBAAgB;AAAA,QAAU,cAAc,QAAQ,IAAA;AAAA,QACpE;AAAA,QAAM;AAAA,MAAA;AAAA;AAAA,IAAU;AAInB,QAAI,qBAAqB;AACzB,QAAI,mBAAmB,cAAc,QAAQ,IAAA;AAE7C,UAAI,UAAK,SAAL,mBAAW,UAAS,OAAK,UAAK,WAAL,mBAAa,UAAS,OAAK,UAAK,WAAL,mBAAa,UAAS,GAAG;AAE/E,YAAM,gBAAgB,iBAAiB,iBAAA;AACvC,YAAMH,cAAa,IAAI,WAAW,eAAe,kBAAkB;AACnE,YAAMC,kBAAiB,IAAI,eAAe,IAAI,IAAI,IAAI,OAAO,gBAAgB,YAAY;AACzF,YAAM,iBAAiB,IAAI,wBAAwB,kBAAkBD,aAAYC,eAAc;AAE/F,UAAI;AACF,cAAM,UAAU,iBAAiB,yCAAyC;AAG1E,6BAAqB,MAAM,eAAe,wBAAwB,aAAa,IAAI;AAGnF,2BAAmB,mBAAmB;AAGtC,cAAM,GAAG;AAAA,UACP;AAAA,UACA,CAAC,mBAAmB,eAAe,kBAAkB,WAAW;AAAA,QAAA;AAIlE,cAAM,eAAe,qBAAA;AAErBP,iBAAO,KAAK,+BAA+B;AAAA,UACzC;AAAA,UACA,WAAW,mBAAmB;AAAA,UAC9B,MAAM,mBAAmB,SAAS;AAAA,QAAA,CACnC;AAAA,MACH,SAAS,OAAO;AACdA,iBAAO,MAAM,wCAAwC,EAAE,aAAa,OAAO;AAC3E,cAAM,IAAIe,gBAA2B,gCAAgC,MAAM,OAAO,EAAE;AAAA,MACtF;AAAA,IACF;AAGA,QAAI,aAAa;AACf,YAAM,YAAY,kBAAkB;AAAA,QAClC;AAAA,QACA,OAAO;AAAA,QACP,OAAO;AAAA,QACP,SAAS;AAAA,UACP;AAAA,UACA,QAAQ,OAAO,UAAU,GAAG,GAAG;AAAA;AAAA,UAC/B,YAAY;AAAA,UACZ,eAAe,CAAC,IAAE,UAAK,SAAL,mBAAW,aAAU,UAAK,WAAL,mBAAa,aAAU,UAAK,WAAL,mBAAa;AAAA,UAC3E,iBAAiB;AAAA,YACf,QAAM,UAAK,SAAL,mBAAW,WAAU;AAAA,YAC3B,UAAQ,UAAK,WAAL,mBAAa,WAAU;AAAA,YAC/B,UAAQ,UAAK,WAAL,mBAAa,WAAU;AAAA,UAAA;AAAA,QACjC;AAAA,MACF,CACD;AAAA,IACH;AAKA,QAAI,oBAAoB;AACtB,YAAM,aAAa,CAAA;AAEnB,iBAAW,SAAS,KAAK,QAAQ,CAAA,GAAI;AACnC,mBAAW,KAAK,GAAG;AAAA,UACjB;AAAA,UACA,CAAC,aAAa,OAAO,MAAM;AAAA,QAAA,CAC5B;AAAA,MACH;AAEA,iBAAW,SAAS,KAAK,UAAU,CAAA,GAAI;AACrC,mBAAW,KAAK,GAAG;AAAA,UACjB;AAAA,UACA,CAAC,aAAa,OAAO,QAAQ;AAAA,QAAA,CAC9B;AAAA,MACH;AAEA,iBAAW,SAAS,KAAK,UAAU,CAAA,GAAI;AACrC,mBAAW,KAAK,GAAG;AAAA,UACjB;AAAA,UACA,CAAC,aAAa,OAAO,QAAQ;AAAA,QAAA,CAC9B;AAAA,MACH;AAEA,YAAM,QAAQ,IAAI,UAAU;AAAA,IAC9B;AAGA,QAAI,UAAU,UAAU;AAEtB,UAAI,CAAC,IAAI,IAAI,OAAO,kBAAkB;AACpC,YAAI,IAAI,OAAO,mBAAmB,IAAI;AAAA,UACpC;AAAA,UACA,IAAI,IAAI,OAAO,UAAU;AAAA,UACzB;AAAA,UACA;AAAA,QAAA;AAAA,MAEJ;AAEA,YAAM,gBAAgB,IAAI,IAAI,OAAO;AAGrC,YAAM,cAAc,eAAe,aAAa,QAAQ,gBAAgB;AAAA,IAE1E,OAAO;AAEL,UAAI,CAAC,IAAI,IAAI,OAAO,gBAAgB;AAClC,YAAI,IAAI,OAAO,iBAAiB,IAAI,eAAe,IAAI,IAAI,IAAI,OAAO,UAAU,QAAQ,YAAY;AAAA,MACtG;AACA,UAAI,CAAC,IAAI,IAAI,OAAO,eAAe;AACjC,YAAI,IAAI,OAAO,gBAAgB,IAAI,cAAc,IAAI,YAAY;AAAA,MACnE;AAEA,YAAM,iBAAiB,IAAI,IAAI,OAAO;AACtC,YAAM,gBAAgB,IAAI,IAAI,OAAO;AAGrC,YAAM,eAAe,MAAM,eAAe,MAAM,aAAa,OAAO,QAAQ,kBAAkB,KAAK;AAGnG,mBAAa,OAAO,GAAG,QAAQ,CAAC,SAAS;AACvCf,iBAAO,KAAK,kBAAkB,EAAE,aAAa,QAAQ,KAAK,QAAQ,SAAS,KAAK,WAAW,UAAU,GAAG,GAAG,GAAG;AAC9G,sBAAc,aAAa,aAAa,UAAU,IAAI;AAAA,MACxD,CAAC;AAED,mBAAa,OAAO,GAAG,QAAQ,CAAC,SAAS;AACvCA,iBAAO,KAAK,kBAAkB,EAAE,aAAa,QAAQ,KAAK,QAAQ,SAAS,KAAK,WAAW,UAAU,GAAG,GAAG,GAAG;AAC9G,sBAAc,aAAa,aAAa,UAAU,IAAI;AAAA,MACxD,CAAC;AAAA,IACH;AAGA,UAAM,WAAW;AAAA,MACf;AAAA,MACA,QAAQ,gBAAgB;AAAA,MACxB,YAAW,oBAAI,KAAA,GAAO,YAAA;AAAA,MACtB,YAAY;AAAA,IAAA;AAId,QAAI,oBAAoB;AACtB,eAAS,OAAO,mBAAmB,SAAS;AAC5C,eAAS,YAAY;AAAA,QACnB,MAAM,mBAAmB;AAAA,QACzB,aAAa,mBAAmB;AAAA,MAAA;AAIlC,UAAI,mBAAmB,aAAa;AAClC,cAAM,aAAa,mBAAmB,YAAY,KAAK,SAAS,KAC9C,mBAAmB,YAAY,OAAO,SAAS;AACjE,YAAI,YAAY;AACd,mBAAS,cAAc,mBAAmB;AAC1C,mBAAS,WAAW,CAAC,WAAW,mBAAmB,YAAY,KAAK,SAAS,mBAAmB,YAAY,OAAO,MAAM,0BAA0B;AAAA,QACrJ;AAAA,MACF;AAAA,IACF;AAEAA,aAAO,KAAK,qBAAqB,EAAE,aAAa,OAAO,YAAY,kBAAkB,MAAM;AAC3F,QAAI,OAAO,GAAG,EAAE,KAAK,QAAQ;AAAA,EAE/B,SAAS,OAAO;AACd,QAAI,MAAM,SAAS,mBAAmB;AACpCA,eAAO,KAAK,oBAAoB,KAAK;AACrC,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK,oBAAoB,KAAK,CAAC;AAAA,IACxD;AACAA,aAAO,MAAM,mBAAmB,KAAK;AACrC,SAAK,KAAK;AAAA,EACZ;AACF,CAAC;ACtRD,MAAMW,WAAS,QAAQ,OAAA;AAEvBA,SAAO,IAAI,wBAAwB,OAAO,KAAK,KAAK,SAAS;AAC3D,MAAI;AAEF,UAAM,cAAcK,oBAA+B,IAAI,OAAO,WAAW;AAEzE,UAAM,EAAE,GAAA,IAAO,IAAI,IAAI;AAGvB,UAAM,YAAY,MAAM,GAAG;AAAA,MACzB;AAAA,MACA,CAAC,WAAW;AAAA,IAAA;AAGd,QAAI,CAAC,WAAW;AACd,YAAM,IAAI,cAAc,wBAAwB,WAAW,EAAE;AAAA,IAC/D;AAGA,UAAM,WAAW,MAAM,GAAG;AAAA,MACxB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAaA,CAAC,aAAa,WAAW;AAAA,IAAA;AAI3B,UAAM,iBAAiB;AAAA,MACrB,QAAQ,CAAA;AAAA,MACR,QAAQ,CAAA;AAAA,IAAC;AAGX,eAAW,WAAW,UAAU;AAC9B,UAAI,QAAQ,YAAY,QAAQ,QAAQ;AACtC,YAAI,CAAC,eAAe,QAAQ,QAAQ,GAAG;AACrC,yBAAe,QAAQ,QAAQ,IAAI,CAAA;AAAA,QACrC;AAEA,cAAM,OAAO,QAAQ,OAAO,KAAK,MAAM,QAAQ,IAAI,IAAI,CAAA;AACvD,uBAAe,QAAQ,QAAQ,EAAE,QAAQ,MAAM,IAAI;AAAA,UACjD,WAAW,QAAQ;AAAA,UACnB,QAAQ,QAAQ;AAAA,UAChB,MAAM,QAAQ;AAAA,UACd,KAAK,KAAK,SAAS;AAAA,UACnB,WAAW,QAAQ;AAAA,UACnB,WAAW,QAAQ,cAAc;AAAA,UACjC,cAAc,QAAQ,iBAAiB;AAAA,QAAA;AAAA,MAE3C;AAAA,IACF;AAGA,UAAM,WAAW,MAAM,GAAG;AAAA,MACxB;AAAA,MACA,CAAC,WAAW;AAAA,IAAA;AAGd,UAAM,UAAU,MAAM,GAAG;AAAA,MACvB;AAAA,MACA,CAAC,WAAW;AAAA,IAAA;AAId,UAAM,WAAW;AAAA,MACf,aAAa,UAAU;AAAA,MACvB,QAAQ,UAAU;AAAA,MAClB,OAAO,UAAU,SAAS;AAAA,MAC1B,WAAW,UAAU;AAAA,MACrB,aAAa,UAAU,gBAAgB;AAAA,MACvC,cAAc,UAAU,mBAAkB,mCAAS,cAAa,UAAU;AAAA,MAC1E,WAAW,UAAU,cAAc;AAAA;AAAA,MAGnC,UAAU;AAAA;AAAA,MAGV,YAAY;AAAA,QACV,YAAW,qCAAU,UAAS;AAAA,QAC9B,cAAa,mCAAS,cAAa;AAAA,MAAA;AAAA,IACrC;AAGF,QAAI,KAAK,QAAQ;AAAA,EAEnB,SAAS,OAAO;AACd,QAAI,MAAM,SAAS,mBAAmB;AACpC,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK,oBAAoB,KAAK,CAAC;AAAA,IACxD;AACA,QAAI,MAAM,SAAS,iBAAiB;AAClC,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK,oBAAoB,KAAK,CAAC;AAAA,IACxD;AACA,SAAK,KAAK;AAAA,EACZ;AACF,CAAC;AClGD,MAAMhB,WAAS,aAAa,gBAAgB;AAC5C,MAAMW,WAAS,QAAQ,OAAA;AAEvBA,SAAO,KAAK,yBAAyB,OAAO,KAAK,KAAK,SAAS;AAC7D,MAAI;AAEF,UAAM,cAAcK,oBAA+B,IAAI,OAAO,WAAW;AACzE,UAAM,UAAUC,gBAA2B,IAAI,KAAK,OAAO;AAE3D,UAAM,EAAE,IAAI,eAAA,IAAmB,IAAI,IAAI;AAGvC,UAAM,YAAY,MAAM,GAAG;AAAA,MACzB;AAAA,MACA,CAAC,WAAW;AAAA,IAAA;AAGd,QAAI,CAAC,WAAW;AACd,YAAM,IAAI,cAAc,wBAAwB,WAAW,EAAE;AAAA,IAC/D;AAGA,QAAI,UAAU,eAAe,UAAU;AAErC,UAAI,CAAC,IAAI,IAAI,OAAO,kBAAkB;AACpC,cAAM,EAAE,cAAAC,eAAc,kBAAAC,sBAAqB,IAAI,IAAI;AACnD,YAAI,IAAI,OAAO,mBAAmB,IAAI;AAAA,UACpC;AAAA,UACA,IAAI,IAAI,OAAO,UAAU;AAAA,UACzBD;AAAAA,UACAC;AAAAA,QAAA;AAAA,MAEJ;AAEA,YAAM,gBAAgB,IAAI,IAAI,OAAO;AAErC,UAAI;AAEF,cAAM,cAAc,YAAY,aAAa,OAAO;AAGpD,YAAI,KAAK;AAAA,UACP,SAAS;AAAA,UACT,WAAW;AAAA,UACX,YAAW,oBAAI,KAAA,GAAO,YAAA;AAAA,QAAY,CACnC;AACD;AAAA,MAEF,SAAS,OAAO;AACd,YAAI,MAAM,YAAY,WAAW,qBAAqB;AACpD,gBAAM,IAAI,cAAc,wBAAwB,WAAW,EAAE;AAAA,QAC/D;AACA,cAAM,IAAI;AAAA,UACR,WAAW;AAAA,UACX,2BAA2B,MAAM,OAAO;AAAA,QAAA;AAAA,MAE5C;AAAA,IACF;AAGA,QAAI,UAAU,WAAW,gBAAgB,SAAS;AAEhD,UAAI,UAAU,WAAW,gBAAgB,aAAa,UAAU,WAAW,gBAAgB,QAAQ;AACjG,cAAM,EAAE,kBAAAA,mBAAkB,cAAAD,kBAAiB,IAAI,IAAI;AAGnD,cAAME,iBAAgB,KAAK;AAAA,UACzBD,kBAAiB,iBAAA;AAAA,UACjB;AAAA,UACA,QAAQ,WAAW;AAAA,QAAA;AAGrB,YAAI;AACF,gBAAMlB,SAAG,OAAOmB,cAAa;AAC7BpB,mBAAO,KAAK,sBAAsB,WAAW,wBAAwB;AAGrE,gBAAM,GAAG;AAAA,YACP;AAAA,YACA,CAAC,gBAAgB,SAAS,WAAW;AAAA,UAAA;AAIvC,gBAAMqB,gBAAe,MAAM,eAAe;AAAA,YACxC;AAAA,YACA,UAAU;AAAA,YACV;AAAA,YACAD;AAAAA,YACA;AAAA;AAAA,UAAA;AAIF,gBAAME,iBAAgB,IAAI,IAAI,OAAO;AAGrCD,wBAAa,OAAO,GAAG,QAAQ,CAAC,SAAS;AACvCrB,qBAAO,KAAK,kBAAkB,EAAE,aAAa,QAAQ,KAAK,QAAQ,SAAS,KAAK,WAAW,UAAU,GAAG,GAAG,GAAG;AAC9GsB,2BAAc,aAAa,aAAa,UAAU,IAAI;AAAA,UACxD,CAAC;AAEDD,wBAAa,OAAO,GAAG,QAAQ,CAAC,SAAS;AACvCrB,qBAAO,KAAK,kBAAkB,EAAE,aAAa,QAAQ,KAAK,QAAQ,SAAS,KAAK,WAAW,UAAU,GAAG,GAAG,GAAG;AAC9GsB,2BAAc,aAAa,aAAa,UAAU,IAAI;AAAA,UACxD,CAAC;AAGDJ,wBAAa,KAAK,iBAAiB,EAAE,aAAa,KAAKG,cAAa,KAAK;AAGzE,cAAI,KAAK;AAAA,YACP,SAAS;AAAA,YACT,SAAS;AAAA,YACT,YAAW,oBAAI,KAAA,GAAO,YAAA;AAAA,UAAY,CACnC;AACD;AAAA,QAEF,SAAS,OAAO;AAEd,gBAAM,IAAI;AAAA,YACR,WAAW;AAAA,YACX,kEAAkE,UAAU,MAAM;AAAA,UAAA;AAAA,QAEtF;AAAA,MACF,OAAO;AACL,cAAM,IAAI;AAAA,UACR,WAAW;AAAA,UACX,mCAAmC,UAAU,MAAM;AAAA,QAAA;AAAA,MAEvD;AAAA,IACF;AAIA,QAAI,CAAC,gBAAgB;AACnB,YAAM,IAAI;AAAA,QACR,WAAW;AAAA,QACX;AAAA,MAAA;AAAA,IAEJ;AAEArB,aAAO,KAAK,kCAAkC,WAAW,+BAA+B;AAGxF,UAAM,eAAe,YAAY,WAAW;AAG5C,UAAM,mBAAmB,MAAM,GAAG;AAAA,MAChC;AAAA,MACA,CAAC,WAAW;AAAA,IAAA;AAId,UAAM,EAAE,kBAAkB,eAAe,aAAA,IAAiB,IAAI,IAAI;AAClE,UAAM,gBAAgB,iBAAiB,eAAe,KAAK;AAAA,MACzD,iBAAiB,iBAAA;AAAA,MACjB;AAAA,MACA,QAAQ,WAAW;AAAA,IAAA;AAIrB,UAAM,eAAe,MAAM,eAAe;AAAA,MACxC;AAAA,MACA,iBAAiB;AAAA,MACjB;AAAA,MACA;AAAA,MACA;AAAA;AAAA,IAAA;AAIF,iBAAa,OAAO,GAAG,QAAQ,CAAC,SAAS;AACvCA,eAAO,KAAK,kBAAkB,EAAE,aAAa,QAAQ,KAAK,QAAQ,SAAS,KAAK,WAAW,UAAU,GAAG,GAAG,GAAG;AAC9G,oBAAc,aAAa,aAAa,UAAU,IAAI;AAAA,IACxD,CAAC;AAED,iBAAa,OAAO,GAAG,QAAQ,CAAC,SAAS;AACvCA,eAAO,KAAK,kBAAkB,EAAE,aAAa,QAAQ,KAAK,QAAQ,SAAS,KAAK,WAAW,UAAU,GAAG,GAAG,GAAG;AAC9G,oBAAc,aAAa,aAAa,UAAU,IAAI;AAAA,IACxD,CAAC;AAGD,iBAAa,KAAK,iBAAiB,EAAE,aAAa,KAAK,aAAa,KAAK;AAGzE,QAAI,KAAK;AAAA,MACP,SAAS;AAAA,MACT,WAAW;AAAA,MACX,YAAW,oBAAI,KAAA,GAAO,YAAA;AAAA,IAAY,CACnC;AAAA,EAEH,SAAS,OAAO;AACd,QAAI,MAAM,SAAS,mBAAmB;AACpC,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK,oBAAoB,KAAK,CAAC;AAAA,IACxD;AACA,QAAI,MAAM,SAAS,iBAAiB;AAClC,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK,oBAAoB,KAAK,CAAC;AAAA,IACxD;AACA,QAAI,MAAM,SAAS,gBAAgB;AACjC,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK,oBAAoB,KAAK,CAAC;AAAA,IACxD;AACA,SAAK,KAAK;AAAA,EACZ;AACF,CAAC;AC7MD,MAAMA,WAAS,aAAa,aAAa;AAEzC,MAAMW,WAAS,QAAQ,OAAA;AAEvBA,SAAO,IAAI,sBAAsB,OAAO,KAAK,KAAK,SAAS;;AACzD,MAAI;AAEF,UAAM,cAAcK,oBAA+B,IAAI,OAAO,WAAW;AAEzE,UAAM,EAAE,IAAI,cAAc,QAAAb,QAAA,IAAW,IAAI,IAAI;AAG7C,UAAM,YAAY,MAAM,GAAG;AAAA,MACzB;AAAA,MACA,CAAC,WAAW;AAAA,IAAA;AAGd,QAAI,CAAC,WAAW;AACd,YAAM,IAAI,cAAc,wBAAwB,WAAW,EAAE;AAAA,IAC/D;AAEAH,aAAO,KAAK,uBAAuB,EAAE,YAAA,CAAa;AAGlD,QAAI,UAAU,KAAK;AAAA,MACjB,gBAAgB;AAAA,MAChB,iBAAiB;AAAA,MACjB,cAAc;AAAA,MACd,qBAAqB;AAAA;AAAA,IAAA,CACtB;AAGD,UAAM,iBAAiB,MAAM,GAAG;AAAA,MAC9B;AAAA,MACA,CAAC,WAAW;AAAA,IAAA;AAGd,eAAW,OAAO,gBAAgB;AAChC,UAAI,MAAM;AAAA,CAAc;AACxB,UAAI,MAAM,SAAS,KAAK,UAAU;AAAA,QAChC,WAAW,IAAI;AAAA,QACf,MAAM,IAAI;AAAA,QACV,SAAS,IAAI;AAAA,MAAA,CACd,CAAC;AAAA;AAAA,CAAM;AAAA,IACV;AAGA,UAAM,aAAa,CAAC,UAAU;AAC5B,UAAI,MAAM,gBAAgB,aAAa;AACrC,YAAI,MAAM;AAAA,CAAc;AACxB,YAAI,MAAM,SAAS,KAAK,UAAU;AAAA,UAChC,WAAW,MAAM;AAAA,UACjB,MAAM,MAAM;AAAA,UACZ,SAAS,MAAM;AAAA,QAAA,CAChB,CAAC;AAAA;AAAA,CAAM;AAAA,MACV;AAAA,IACF;AAGA,iBAAa,GAAG,OAAO,WAAW,UAAU;AAG5C,UAAM,oBAAoB,YAAY,MAAM;AAC1C,UAAI,MAAM,gBAAgB;AAAA,IAC5B,KAAG,KAAAG,WAAA,gBAAAA,QAAQ,cAAR,mBAAmB,sBAAqB,GAAK;AAGhD,QAAI,GAAG,SAAS,MAAM;AACpBH,eAAO,KAAK,2BAA2B,EAAE,YAAA,CAAa;AACtD,mBAAa,eAAe,OAAO,WAAW,UAAU;AACxD,oBAAc,iBAAiB;AAAA,IACjC,CAAC;AAGD,UAAM,cAAc,CAAC,UAAU;AAC7B,UAAI,MAAM,gBAAgB,aAAa;AACrC,YAAI,MAAM;AAAA,CAAc;AACxB,YAAI,MAAM,SAAS,KAAK,UAAU;AAAA,UAChC,MAAM,MAAM;AAAA,UACZ,QAAQ,MAAM;AAAA,QAAA,CACf,CAAC;AAAA;AAAA,CAAM;AAGR,qBAAa,eAAe,OAAO,WAAW,UAAU;AACxD,qBAAa,eAAe,OAAO,cAAc,WAAW;AAC5D,sBAAc,iBAAiB;AAC/B,YAAI,IAAA;AAAA,MACN;AAAA,IACF;AAEA,iBAAa,GAAG,OAAO,cAAc,WAAW;AAAA,EAElD,SAAS,OAAO;AACd,QAAI,MAAM,SAAS,mBAAmB;AACpC,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK,oBAAoB,KAAK,CAAC;AAAA,IACxD;AACA,QAAI,MAAM,SAAS,iBAAiB;AAClC,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK,oBAAoB,KAAK,CAAC;AAAA,IACxD;AACA,SAAK,KAAK;AAAA,EACZ;AACF,CAAC;AC1GD,MAAMW,WAAS,QAAQ,OAAA;ACAvB,MAAMA,WAAS,QAAQ,OAAA;AAIvB,MAAMX,WAAS,aAAa,gBAAgB;AAE5C,IAAI;AAEJW,SAAO,IAAI,CAAC,KAAK,KAAK,SAAS;AAC7B,MAAI,CAAC,gBAAgB;AACnB,qBAAiB,IAAI,eAAe,IAAI,IAAI,OAAO,IAAI,IAAI,IAAI,OAAO,gBAAgB,IAAI,IAAI,OAAO,YAAY;AAAA,EACnH;AACA,OAAA;AACF,CAAC;AAEDA,SAAO,IAAI,yBAAyB,OAAO,KAAK,QAAQ;AACtD,MAAI;AACF,UAAM,EAAE,gBAAgB,IAAI;AAC5B,UAAM,EAAE,SAAS,MAAA,IAAU,IAAI;AAE/BX,aAAO,KAAK,mCAAmC,WAAW,IAAI,EAAE,SAAS,OAAO;AAEhF,UAAM,WAAW,MAAM,eAAe,eAAe,aAAa,EAAE,SAAS,OAAO;AAEpF,QAAI,KAAK,QAAQ;AAAA,EACnB,SAAS,OAAO;AACdA,aAAO,MAAM,4BAA4B,KAAK;AAC9C,QAAI,OAAO,MAAM,YAAY,wBAAwB,MAAM,GAAG,EAAE,KAAK;AAAA,MACnE,OAAO;AAAA,QACL,MAAM,MAAM,YAAY,wBAAwB,wBAAwB;AAAA,QACxE,SAAS,MAAM;AAAA,QACf,SAAS,MAAM;AAAA,MAAA;AAAA,IACjB,CACD;AAAA,EACH;AACF,CAAC;AAEDW,SAAO,KAAK,uBAAuB,OAAO,KAAK,QAAQ;AACrD,MAAI;AACF,UAAM,EAAE,gBAAgB,IAAI;AAC5B,UAAM,EAAE,SAAS,MAAA,IAAU,IAAI;AAC/B,UAAM,UAAU,EAAE,GAAG,IAAI,MAAM,SAAS,MAAA;AAExCX,aAAO,KAAK,kCAAkC,WAAW,IAAI;AAAA,MAC3D;AAAA,MACA;AAAA,MACA,aAAa,IAAI;AAAA,MACjB,SAAS,IAAI;AAAA,MACb;AAAA,IAAA,CACD;AAED,UAAM,SAAS,MAAM,eAAe,aAAa,aAAa,OAAO;AAErE,QAAI,KAAK,MAAM;AAAA,EACjB,SAAS,OAAO;AACdA,aAAO,MAAM,2BAA2B,KAAK;AAE7C,QAAI,YAAY;AAChB,QAAI,aAAa;AAEjB,QAAI,MAAM,YAAY,uBAAuB;AAC3C,kBAAY;AACZ,mBAAa;AAAA,IACf,WAAW,MAAM,QAAQ,SAAS,oBAAoB,GAAG;AACvD,kBAAY;AACZ,mBAAa;AAAA,IACf,WAAW,MAAM,YAAY,qCAAqC;AAChE,kBAAY;AACZ,mBAAa;AAAA,IACf;AAEA,QAAI,OAAO,UAAU,EAAE,KAAK;AAAA,MAC1B,OAAO;AAAA,QACL,MAAM;AAAA,QACN,SAAS,MAAM;AAAA,QACf,SAAS,MAAM;AAAA,MAAA;AAAA,IACjB,CACD;AAAA,EACH;AACF,CAAC;AAEDW,SAAO,IAAI,wBAAwB,OAAO,KAAK,QAAQ;AACrD,MAAI;AACF,UAAM,EAAE,gBAAgB,IAAI;AAC5B,UAAM,EAAE,SAAS,MAAA,IAAU,IAAI;AAE/BX,aAAO,KAAK,wCAAwC,WAAW,IAAI,EAAE,SAAS,OAAO;AAErF,UAAM,SAAS,MAAM,eAAe,iBAAiB,aAAa,EAAE,SAAS,OAAO;AAEpF,QAAI,KAAK,MAAM;AAAA,EACjB,SAAS,OAAO;AACdA,aAAO,MAAM,iCAAiC,KAAK;AACnD,QAAI,OAAO,GAAG,EAAE,KAAK;AAAA,MACnB,OAAO;AAAA,QACL,MAAM;AAAA,QACN,SAAS,MAAM;AAAA,QACf,SAAS,MAAM;AAAA,MAAA;AAAA,IACjB,CACD;AAAA,EACH;AACF,CAAC;AAEDW,SAAO,KAAK,sBAAsB,OAAO,KAAK,QAAQ;AACpD,MAAI;AACF,UAAM,EAAE,gBAAgB,IAAI;AAC5B,UAAM,EAAE,SAAS,MAAA,IAAU,IAAI;AAC/B,UAAM,EAAE,WAAW,QAAA,IAAY,IAAI;AAEnCX,aAAO,KAAK,kCAAkC,WAAW,IAAI,EAAE,WAAW,SAAS,SAAS,OAAO;AAEnG,UAAM,SAAS,MAAM,eAAe,YAAY,aAAa,WAAW,EAAE,SAAS,OAAO;AAE1F,QAAI,KAAK,MAAM;AAAA,EACjB,SAAS,OAAO;AACdA,aAAO,MAAM,2BAA2B,KAAK;AAC7C,QAAI,OAAO,GAAG,EAAE,KAAK;AAAA,MACnB,OAAO;AAAA,QACL,MAAM;AAAA,QACN,SAAS,MAAM;AAAA,QACf,SAAS,MAAM;AAAA,MAAA;AAAA,IACjB,CACD;AAAA,EACH;AACF,CAAC;AAEDW,SAAO,KAAK,yBAAyB,OAAO,KAAK,QAAQ;AACvD,MAAI;AACF,UAAM,EAAE,gBAAgB,IAAI;AAC5B,UAAM,EAAE,SAAS,MAAA,IAAU,IAAI;AAC/B,UAAM,EAAE,WAAW,QAAQ,MAAA,IAAU,IAAI;AAEzCX,aAAO,KAAK,oCAAoC,WAAW,IAAI,EAAE,WAAW,SAAS,OAAO,OAAO;AAGnG,QAAI,WAAW;AACb,YAAM,UAAU,MAAM,IAAI,IAAI,OAAO,GAAG;AAAA,QACtC;AAAA,QACA,CAAC,WAAW,WAAW;AAAA,MAAA;AAGzB,UAAI,CAAC,SAAS;AACZ,eAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,UAC1B,OAAO;AAAA,YACL,MAAM;AAAA,YACN,SAAS;AAAA,UAAA;AAAA,QACX,CACD;AAAA,MACH;AAGA,UAAI,CAAC,cAAc,YAAY,SAAS,EAAE,SAAS,QAAQ,MAAM,GAAG;AAClE,cAAM,eAAe,YAAY,aAAa,SAAS;AAEvD,cAAM,IAAI,QAAQ,CAAA,YAAW,WAAW,SAAS,GAAI,CAAC;AAAA,MACxD;AAGA,YAAM,SAAS,MAAM,eAAe,aAAa,aAAa;AAAA,QAC5D,SAAS,QAAQ;AAAA,QACjB,OAAO,QAAQ;AAAA,QACf,qBAAqB,CAAC;AAAA;AAAA,MAAA,CACvB;AAED,UAAI,KAAK;AAAA,QACP,GAAG;AAAA,QACH,WAAW;AAAA,QACX,mBAAmB;AAAA,MAAA,CACpB;AAAA,IACH,WAAW,WAAW,OAAO;AAG3B,YAAM,mBAAmB,MAAM,IAAI,IAAI,OAAO,GAAG;AAAA,QAC/C;AAAA,QACA,CAAC,aAAa,SAAS,KAAK;AAAA,MAAA;AAI9B,iBAAW,WAAW,kBAAkB;AACtC,YAAI,CAAC,cAAc,YAAY,SAAS,EAAE,SAAS,QAAQ,MAAM,GAAG;AAClE,gBAAM,eAAe,YAAY,aAAa,QAAQ,EAAE;AAAA,QAC1D;AAAA,MACF;AAGA,UAAI,iBAAiB,SAAS,GAAG;AAC/B,cAAM,IAAI,QAAQ,CAAA,YAAW,WAAW,SAAS,GAAI,CAAC;AAAA,MACxD;AAGA,YAAM,SAAS,MAAM,eAAe,aAAa,aAAa;AAAA,QAC5D;AAAA,QACA;AAAA,QACA,qBAAqB,CAAC;AAAA,MAAA,CACvB;AAED,UAAI,KAAK;AAAA,QACP,GAAG;AAAA,QACH,WAAW;AAAA,QACX,qBAAqB,iBAAiB,SAAS;AAAA,MAAA,CAChD;AAAA,IACH,OAAO;AACL,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,QAC1B,OAAO;AAAA,UACL,MAAM;AAAA,UACN,SAAS;AAAA,QAAA;AAAA,MACX,CACD;AAAA,IACH;AAAA,EACF,SAAS,OAAO;AACdA,aAAO,MAAM,6BAA6B,KAAK;AAE/C,QAAI,YAAY;AAChB,QAAI,aAAa;AAEjB,QAAI,MAAM,YAAY,uBAAuB;AAC3C,kBAAY;AACZ,mBAAa;AAAA,IACf,WAAW,MAAM,QAAQ,SAAS,oBAAoB,GAAG;AACvD,kBAAY;AACZ,mBAAa;AAAA,IACf;AAEA,QAAI,OAAO,UAAU,EAAE,KAAK;AAAA,MAC1B,OAAO;AAAA,QACL,MAAM;AAAA,QACN,SAAS,MAAM;AAAA,QACf,SAAS,MAAM;AAAA,MAAA;AAAA,IACjB,CACD;AAAA,EACH;AACF,CAAC;AAEDW,SAAO,IAAI,sBAAsB,OAAO,KAAK,QAAQ;AACnD,MAAI;AACF,UAAM,EAAE,gBAAgB,IAAI;AAC5B,UAAM,EAAE,cAAc,IAAI;AAE1B,QAAI,CAAC,WAAW;AACd,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,QAC1B,OAAO;AAAA,UACL,MAAM;AAAA,UACN,SAAS;AAAA,QAAA;AAAA,MACX,CACD;AAAA,IACH;AAEAX,aAAO,KAAK,mCAAmC,SAAS,EAAE;AAE1D,QAAI,UAAU,KAAK;AAAA,MACjB,gBAAgB;AAAA,MAChB,iBAAiB;AAAA,MACjB,cAAc;AAAA,MACd,+BAA+B;AAAA,IAAA,CAChC;AAED,mBAAe,iBAAiB,WAAW,GAAG;AAE9C,UAAM,UAAU,MAAM,IAAI,IAAI,OAAO,GAAG;AAAA,MACtC;AAAA,MACA,CAAC,WAAW,WAAW;AAAA,IAAA;AAGzB,QAAI,CAAC,SAAS;AACZ,UAAI,MAAM;AAAA,QAAuB,KAAK,UAAU,EAAE,SAAS,oBAAA,CAAqB,CAAC;AAAA;AAAA,CAAM;AACvF,UAAI,IAAA;AACJ;AAAA,IACF;AAEA,UAAM,aAAa,MAAM,IAAI,IAAI,OAAO,GAAG;AAAA,MACzC;AAAA,MACA,CAAC,SAAS;AAAA,IAAA;AAGZ,eAAW,QAAA,EAAU,QAAQ,CAAA,QAAO;AAClC,UAAI,MAAM;AAAA,QAAqB,KAAK,UAAU;AAAA,QAC5C,WAAW,IAAI;AAAA,QACf,MAAM,IAAI;AAAA,QACV,SAAS,IAAI;AAAA,MAAA,CACd,CAAC;AAAA;AAAA,CAAM;AAAA,IACV,CAAC;AAED,UAAM,OAAO,KAAK,MAAM,QAAQ,QAAQ,IAAI;AAC5C,QAAI,MAAM;AAAA,QAAwB,KAAK,UAAU;AAAA,MAC/C,QAAQ,QAAQ;AAAA,MAChB,MAAM,QAAQ;AAAA,MACd,KAAK,KAAK;AAAA,IAAA,CACX,CAAC;AAAA;AAAA,CAAM;AAER,UAAM,YAAY,YAAY,MAAM;AAClC,UAAI,MAAM,gBAAgB;AAAA,IAC5B,GAAG,GAAK;AAER,QAAI,GAAG,SAAS,MAAM;AACpB,oBAAc,SAAS;AACvB,qBAAe,oBAAoB,WAAW,GAAG;AACjDA,eAAO,KAAK,iCAAiC,SAAS,EAAE;AAAA,IAC1D,CAAC;AAAA,EACH,SAAS,OAAO;AACdA,aAAO,MAAM,yBAAyB,KAAK;AAC3C,QAAI,OAAO,GAAG,EAAE,KAAK;AAAA,MACnB,OAAO;AAAA,QACL,MAAM;AAAA,QACN,SAAS,MAAM;AAAA,QACf,SAAS,MAAM;AAAA,MAAA;AAAA,IACjB,CACD;AAAA,EACH;AACF,CAAC;AAEDW,SAAO,KAAK,yBAAyB,OAAO,KAAK,QAAQ;AACvD,MAAI;AACF,UAAM,EAAE,gBAAgB,IAAI;AAC5B,UAAM,EAAE,SAAS,MAAA,IAAU,IAAI;AAC/B,UAAM,UAAU,EAAE,GAAG,IAAI,MAAM,SAAS,MAAA;AAExCX,aAAO,KAAK,yCAAyC,WAAW,IAAI,OAAO;AAE3E,UAAM,SAAS,MAAM,eAAe,oBAAoB,aAAa,OAAO;AAE5E,QAAI,KAAK,MAAM;AAAA,EACjB,SAAS,OAAO;AACdA,aAAO,MAAM,kCAAkC,KAAK;AAEpD,QAAI,YAAY;AAChB,QAAI,aAAa;AAEjB,QAAI,MAAM,YAAY,uBAAuB;AAC3C,kBAAY;AACZ,mBAAa;AAAA,IACf,WAAW,MAAM,YAAY,+BAA+B;AAC1D,kBAAY;AACZ,mBAAa;AAAA,IACf;AAEA,QAAI,OAAO,UAAU,EAAE,KAAK;AAAA,MAC1B,OAAO;AAAA,QACL,MAAM;AAAA,QACN,SAAS,MAAM;AAAA,QACf,SAAS,MAAM;AAAA,MAAA;AAAA,IACjB,CACD;AAAA,EACH;AACF,CAAC;ACvVD,MAAMW,WAAS,QAAQ,OAAA;AAMvB,MAAMX,WAAS,aAAa,aAAa;AAGzC,IAAI;AACJ,SAAS,cAAc,KAAK;AAC1B,MAAI,CAAC,YAAY;AACf,iBAAa,IAAI,WAAW,IAAI,IAAI,OAAO,UAAU,SAAS;AAAA,EAChE;AACA,SAAO;AACT;AAGAW,SAAO,IAAI,SAAS,OAAO,KAAK,KAAK,SAAS;AAC5C,MAAI;AACF,UAAM,UAAU,cAAc,GAAG;AACjC,UAAM,UAAU,KAAK,KAAK,IAAI,IAAI,OAAO,UAAU,WAAW,MAAM;AAGpE,UAAM,OAAO,CAAA;AACb,QAAI;AACF,YAAM,UAAU,MAAMV,SAAG,QAAQ,SAAS,EAAE,eAAe,MAAM;AAEjE,iBAAW,SAAS,SAAS;AAC3B,YAAI,MAAM,eAAe;AACvB,gBAAM,QAAQ,MAAM;AACpB,gBAAM,UAAU,KAAK,KAAK,SAAS,KAAK;AAExC,cAAI;AAEF,kBAAM,aAAa,MAAM,QAAQ,aAAa,KAAK;AACnD,kBAAM,WAAW,WAAW;AAC5B,kBAAM,gBAAgB,WAAW;AAGjC,kBAAM,aAAa,MAAM,QAAQ;AAAA,cAAQ;AAAA,cACvC;AAAA,YAAA;AAEF,kBAAM,CAAC,MAAM,QAAQ,OAAO,WAAW,OAAO,IAAI,WAAW,MAAM,IAAI;AAGvE,kBAAM,YAAY,MAAM,QAAQ,cAAc,KAAK;AACnD,kBAAM,mBAAmB,UACtB,OAAO,OAAK,EAAE,UAAU,EAAE,OAAO,WAAW,OAAO,CAAC,EACpD,IAAI,CAAA,MAAK,EAAE,OAAO,QAAQ,SAAS,EAAE,CAAC;AAEzC,iBAAK,KAAK;AAAA,cACR;AAAA,cACA;AAAA,cACA,UAAU,SAAS,IAAI,CAAA,MAAK,EAAE,IAAI;AAAA,cAClC,YAAY;AAAA,gBACV;AAAA,gBACA;AAAA,gBACA;AAAA,gBACA,WAAW,IAAI,KAAK,SAAS,SAAS,IAAI,GAAI,EAAE,YAAA;AAAA,gBAChD,SAAS;AAAA,cAAA;AAAA,cAEX;AAAA,YAAA,CACD;AAAA,UACH,SAAS,OAAO;AACdD,qBAAO,MAAM,8BAA8B,KAAK,KAAK,KAAK;AAC1D,iBAAK,KAAK;AAAA,cACR;AAAA,cACA,OAAO;AAAA,YAAA,CACR;AAAA,UACH;AAAA,QACF;AAAA,MACF;AAAA,IACF,SAAS,OAAO;AACd,UAAI,MAAM,SAAS,UAAU;AAE3B,eAAO,IAAI,KAAK,EAAE,MAAM,CAAA,GAAI;AAAA,MAC9B;AACA,YAAM;AAAA,IACR;AAEA,QAAI,KAAK,EAAE,MAAM;AAAA,EACnB,SAAS,OAAO;AACd,SAAK,KAAK;AAAA,EACZ;AACF,CAAC;AAGDW,SAAO,IAAI,qBAAqB,OAAO,KAAK,KAAK,SAAS;AACxD,MAAI;AACF,UAAM,EAAE,UAAU,IAAI;AACtB,UAAM,UAAU,cAAc,GAAG;AAEjC,QAAI,CAAC,MAAM,QAAQ,UAAU,KAAK,GAAG;AACnC,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,QAC1B,OAAO;AAAA,UACL,MAAM;AAAA,UACN,SAAS,cAAc,KAAK;AAAA,QAAA;AAAA,MAC9B,CACD;AAAA,IACH;AAEA,UAAM,UAAU,KAAK,KAAK,IAAI,IAAI,OAAO,UAAU,WAAW,QAAQ,KAAK;AAG3E,UAAM,gBAAgB,MAAM,QAAQ,QAAQ,SAAS,6BAA6B;AAGlF,UAAM,aAAa,MAAM,QAAQ,aAAa,KAAK;AACnD,UAAM,WAAW,WAAW;AAC5B,UAAM,gBAAgB,CAAA;AAEtB,eAAW,UAAU,UAAU;AAC7B,YAAM,aAAa,MAAM,QAAQ;AAAA,QAAQ;AAAA,QACvC,+BAA+B,OAAO,IAAI;AAAA,MAAA;AAE5C,YAAM,CAAC,MAAM,WAAW,OAAO,IAAI,WAAW,MAAM,IAAI;AAExD,oBAAc,KAAK;AAAA,QACjB,MAAM,OAAO;AAAA,QACb,QAAQ,OAAO;AAAA,QACf,YAAY;AAAA,UACV;AAAA,UACA,WAAW,IAAI,KAAK,SAAS,SAAS,IAAI,GAAI,EAAE,YAAA;AAAA,UAChD,SAAS;AAAA,QAAA;AAAA,MACX,CACD;AAAA,IACH;AAGA,UAAM,gBAAgB,MAAM,QAAQ;AAAA,MAAQ;AAAA,MAC1C;AAAA,IAAA;AAEF,UAAM,UAAU,CAAA;AAChB,UAAM,QAAQ,cAAc,KAAA,EAAO,MAAM,IAAI;AAE7C,aAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK,GAAG;AACxC,UAAI,MAAM,CAAC,GAAG;AACZ,gBAAQ,KAAK;AAAA,UACX,MAAM,MAAM,CAAC;AAAA,UACb,QAAQ,MAAM,IAAI,CAAC;AAAA,UACnB,OAAO,MAAM,IAAI,CAAC;AAAA,UAClB,WAAW,IAAI,KAAK,SAAS,MAAM,IAAI,CAAC,CAAC,IAAI,GAAI,EAAE,YAAA;AAAA,UACnD,SAAS,MAAM,IAAI,CAAC;AAAA,QAAA,CACrB;AAAA,MACH;AAAA,IACF;AAGA,UAAM,YAAY,MAAM,QAAQ,cAAc,KAAK;AACnD,UAAM,mBAAmB,UACtB,OAAO,CAAA,MAAK,EAAE,UAAU,EAAE,OAAO,WAAW,OAAO,CAAC,EACpD,IAAI,CAAA,OAAM;AAAA,MACT,aAAa,EAAE,OAAO,QAAQ,SAAS,EAAE;AAAA,MACzC,QAAQ,EAAE;AAAA,MACV,MAAM,EAAE;AAAA,IAAA,EACR;AAGJ,UAAM,YAAY,MAAM,QAAQ,QAAQ,SAAS,kBAAkB;AACnE,UAAM,OAAO,MAAM,QAAQ,QAAQ,SAAS,kBAAkB;AAC9D,UAAM,YAAY,KAAK,MAAM,aAAa;AAE1C,QAAI,KAAK;AAAA,MACP;AAAA,MACA;AAAA,MACA,UAAU;AAAA,MACV,eAAe;AAAA,MACf;AAAA,MACA,OAAO;AAAA,QACL,WAAW,SAAS,UAAU,MAAM;AAAA,QACpC,QAAQ,YAAY,SAAS,UAAU,CAAC,CAAC,IAAI;AAAA,MAAA;AAAA,IAC/C,CACD;AAAA,EACH,SAAS,OAAO;AACd,SAAK,KAAK;AAAA,EACZ;AACF,CAAC;AAGDA,SAAO,IAAI,yBAAyB,OAAO,KAAK,KAAK,SAAS;AAC5D,MAAI;AACF,UAAM,EAAE,UAAU,IAAI;AACtB,UAAM,UAAU,cAAc,GAAG;AAEjC,QAAI,CAAC,MAAM,QAAQ,UAAU,KAAK,GAAG;AACnC,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,QAC1B,OAAO;AAAA,UACL,MAAM;AAAA,UACN,SAAS,cAAc,KAAK;AAAA,QAAA;AAAA,MAC9B,CACD;AAAA,IACH;AAEA,UAAM,aAAa,MAAM,QAAQ,aAAa,KAAK;AACnD,UAAM,WAAW,WAAW;AAC5B,UAAM,gBAAgB,WAAW;AACjC,UAAM,UAAU,KAAK,KAAK,IAAI,IAAI,OAAO,UAAU,WAAW,QAAQ,KAAK;AAG3E,UAAM,gBAAgB,CAAA;AACtB,eAAW,UAAU,UAAU;AAC7B,YAAM,aAAa,MAAM,QAAQ;AAAA,QAAQ;AAAA,QACvC,oCAAoC,OAAO,IAAI;AAAA,MAAA;AAEjD,YAAM,CAAC,MAAM,QAAQ,WAAW,OAAO,IAAI,WAAW,MAAM,IAAI;AAEhE,oBAAc,KAAK;AAAA,QACjB,MAAM,OAAO;AAAA,QACb,QAAQ,OAAO;AAAA,QACf,WAAW,OAAO,SAAS;AAAA,QAC3B,mBAAmB,OAAO,KAAK,WAAW,OAAO;AAAA,QACjD,YAAY;AAAA,UACV;AAAA,UACA;AAAA,UACA,WAAW,IAAI,KAAK,SAAS,SAAS,IAAI,GAAI,EAAE,YAAA;AAAA,UAChD,SAAS;AAAA,QAAA;AAAA,MACX,CACD;AAAA,IACH;AAEA,QAAI,KAAK;AAAA,MACP;AAAA,MACA,UAAU;AAAA,IAAA,CACX;AAAA,EACH,SAAS,OAAO;AACd,SAAK,KAAK;AAAA,EACZ;AACF,CAAC;AAGDA,SAAO,KAAK,yBAAyB,OAAO,KAAK,KAAK,SAAS;AAC7D,MAAI;AACF,UAAM,EAAE,UAAU,IAAI;AACtB,UAAM,EAAE,WAAW,IAAI;AACvB,UAAM,UAAU,cAAc,GAAG;AAEjC,QAAI,CAAC,QAAQ;AACX,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,QAC1B,OAAO;AAAA,UACL,MAAM;AAAA,UACN,SAAS;AAAA,QAAA;AAAA,MACX,CACD;AAAA,IACH;AAEA,QAAI,CAAC,MAAM,QAAQ,UAAU,KAAK,GAAG;AACnC,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,QAC1B,OAAO;AAAA,UACL,MAAM;AAAA,UACN,SAAS,cAAc,KAAK;AAAA,QAAA;AAAA,MAC9B,CACD;AAAA,IACH;AAEA,UAAM,UAAU,KAAK,KAAK,IAAI,IAAI,OAAO,UAAU,WAAW,QAAQ,KAAK;AAG3E,UAAM,aAAa,MAAM,QAAQ,aAAa,KAAK;AACnD,UAAM,eAAe,WAAW,SAAS,KAAK,CAAA,MAAK,EAAE,SAAS,MAAM;AAEpE,QAAI,CAAC,cAAc;AACjB,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,QAC1B,OAAO;AAAA,UACL,MAAM;AAAA,UACN,SAAS,WAAW,MAAM,6BAA6B,KAAK;AAAA,QAAA;AAAA,MAC9D,CACD;AAAA,IACH;AAGA,UAAM,QAAQ,QAAQ,SAAS,YAAY,QAAQ,UAAU,MAAM,CAAC,EAAE;AAEtE,QAAI,KAAK;AAAA,MACP;AAAA,MACA;AAAA,MACA,SAAS;AAAA,IAAA,CACV;AAAA,EACH,SAAS,OAAO;AACd,SAAK,KAAK;AAAA,EACZ;AACF,CAAC;AAGDA,SAAO,IAAI,sBAAsB,OAAO,KAAK,KAAK,SAAS;AACzD,MAAI;AACF,UAAM,EAAE,UAAU,IAAI;AACtB,UAAM,EAAE,SAAS,QAAQ,MAAM,UAAU,IAAI,YAAY,UAAU,IAAI;AACvE,UAAM,UAAU,cAAc,GAAG;AAEjC,QAAI,CAAC,MAAM,QAAQ,UAAU,KAAK,GAAG;AACnC,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,QAC1B,OAAO;AAAA,UACL,MAAM;AAAA,UACN,SAAS,cAAc,KAAK;AAAA,QAAA;AAAA,MAC9B,CACD;AAAA,IACH;AAEA,QAAI,cAAc,UAAU,cAAc,MAAM;AAE9C,YAAM,QAAQ,MAAM,QAAQ,UAAU,OAAO,QAAQ,OAAO;AAC5D,UAAI,KAAK,EAAE,OAAO;AAAA,IACpB,OAAO;AAEL,YAAM,UAAU,MAAM,QAAQ,cAAc,OAAO,QAAQ,OAAO;AAClE,UAAI,KAAK,EAAE,SAAS;AAAA,IACtB;AAAA,EACF,SAAS,OAAO;AAEd,QAAK,MAAM,QAAQ,SAAS,UAAU,KAAK,MAAM,QAAQ,SAAS,eAAe,KAC5E,MAAM,QAAQ,SAAS,QAAQ,KAAK,MAAM,QAAQ,SAAS,SAAS,KAAK,MAAM,QAAQ,SAAS,WAAW,GAAI;AAClH,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,QAC1B,OAAO;AAAA,UACL,MAAM;AAAA,UACN,SAAS;AAAA,QAAA;AAAA,MACX,CACD;AAAA,IACH;AAEA,QAAI,MAAM,QAAQ,SAAS,kBAAkB,GAAG;AAC9C,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,QAC1B,OAAO;AAAA,UACL,MAAM;AAAA,UACN,SAAS;AAAA,QAAA;AAAA,MACX,CACD;AAAA,IACH;AAEA,SAAK,KAAK;AAAA,EACZ;AACF,CAAC;AAGDA,SAAO,IAAI,qBAAqB,OAAO,KAAK,KAAK,SAAS;AACxD,MAAI;AACF,UAAM,EAAE,UAAU,IAAI;AACtB,UAAM,EAAE,SAAS,QAAQ,MAAM,SAAA,IAAa,IAAI;AAChD,UAAM,UAAU,cAAc,GAAG;AAEjC,QAAI,CAAC,UAAU;AACb,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,QAC1B,OAAO;AAAA,UACL,MAAM;AAAA,UACN,SAAS;AAAA,QAAA;AAAA,MACX,CACD;AAAA,IACH;AAEA,QAAI,CAAC,MAAM,QAAQ,UAAU,KAAK,GAAG;AACnC,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,QAC1B,OAAO;AAAA,UACL,MAAM;AAAA,UACN,SAAS,cAAc,KAAK;AAAA,QAAA;AAAA,MAC9B,CACD;AAAA,IACH;AAEA,QAAI;AAEF,YAAM,WAAW,MAAM,QAAQ,YAAY,OAAO,QAAQ,QAAQ;AAElE,UAAI,CAAC,UAAU;AACb,eAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,UAC1B,OAAO;AAAA,YACL,MAAM;AAAA,YACN,SAAS;AAAA,UAAA;AAAA,QACX,CACD;AAAA,MACH;AAEA,UAAI,SAAS,SAAS,QAAQ;AAC5B,eAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,UAC1B,OAAO;AAAA,YACL,MAAM;AAAA,YACN,SAAS;AAAA,UAAA;AAAA,QACX,CACD;AAAA,MACH;AAGA,YAAM,WAAW,MAAM,QAAQ,SAAS,OAAO,QAAQ,QAAQ;AAE/D,UAAI,CAAC,SAAS,OAAO;AACnB,eAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,UAC1B,OAAO;AAAA,YACL,MAAM;AAAA,YACN,SAAS;AAAA,UAAA;AAAA,QACX,CACD;AAAA,MACH;AAEA,YAAM,SAAS,SAAS;AACxB,YAAM,WAAW,SAAS;AAE1B,UAAI,UAAU;AAEZ,YAAI,KAAK;AAAA,UACP,MAAM;AAAA,UACN,UAAU;AAAA,UACV,SAAS,OAAO,SAAS,QAAQ;AAAA,UACjC,MAAM,SAAS;AAAA,UACf,MAAM,SAAS;AAAA,QAAA,CAChB;AAAA,MACH,OAAO;AAEL,YAAI,KAAK;AAAA,UACP,MAAM;AAAA,UACN,UAAU;AAAA,UACV,SAAS,OAAO,SAAS,MAAM;AAAA,UAC/B,MAAM,SAAS;AAAA,UACf,MAAM,SAAS;AAAA,QAAA,CAChB;AAAA,MACH;AAAA,IACF,SAAS,OAAO;AACd,UAAI,MAAM,QAAQ,SAAS,UAAU,KAAK,MAAM,QAAQ,SAAS,eAAe,GAAG;AACjF,eAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,UAC1B,OAAO;AAAA,YACL,MAAM;AAAA,YACN,SAAS;AAAA,UAAA;AAAA,QACX,CACD;AAAA,MACH;AACA,YAAM;AAAA,IACR;AAAA,EACF,SAAS,OAAO;AACd,SAAK,KAAK;AAAA,EACZ;AACF,CAAC;AAGDA,SAAO,IAAI,2BAA2B,OAAO,KAAK,KAAK,SAAS;AAC9D,MAAI;AACF,UAAM,EAAE,UAAU,IAAI;AACtB,UAAM,EAAE,GAAA,IAAO,IAAI,IAAI;AAGvB,UAAM,aAAa,MAAM,GAAG,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAe7B,CAAC,KAAK,CAAC;AAGV,UAAM,qBAAqB,MAAM,QAAQ,IAAI,WAAW,IAAI,OAAOY,UAAS;AAC1E,YAAM,WAAW,MAAM,GAAG,IAAI;AAAA;AAAA;AAAA;AAAA,SAI3B,CAACA,MAAK,EAAE,CAAC;AAEZ,aAAO;AAAA,QACL,GAAGA;AAAA,QACH,gBAAgB,SAAS,IAAI,CAAA,MAAK,EAAE,MAAM;AAAA,MAAA;AAAA,IAE9C,CAAC,CAAC;AAEF,QAAI,KAAK;AAAA,MACP;AAAA,MACA,YAAY;AAAA,IAAA,CACb;AAAA,EACH,SAAS,OAAO;AACdvB,aAAO,MAAM,oCAAoC,EAAE,OAAO,IAAI,OAAO,OAAO,OAAO,MAAM,QAAA,CAAS;AAClG,SAAK,KAAK;AAAA,EACZ;AACF,CAAC;AAGDW,SAAO,KAAK,sBAAsB,OAAO,KAAK,KAAK,SAAS;AAC1D,MAAI;AACF,UAAM,EAAE,UAAU,IAAI;AACtB,UAAM,EAAE,cAAc,eAAe,QAAQ,WAAW,SAAS,kBAAkB,IAAI;AACvF,UAAM,UAAU,cAAc,GAAG;AAGjC,QAAI,CAAC,cAAc;AACjB,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,QAC1B,OAAO;AAAA,UACL,MAAM;AAAA,UACN,SAAS;AAAA,QAAA;AAAA,MACX,CACD;AAAA,IACH;AAEA,QAAI,CAAC,MAAM,QAAQ,UAAU,KAAK,GAAG;AACnC,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,QAC1B,OAAO;AAAA,UACL,MAAM;AAAA,UACN,SAAS,cAAc,KAAK;AAAA,QAAA;AAAA,MAC9B,CACD;AAAA,IACH;AAEA,UAAM,UAAU,KAAK,KAAK,IAAI,IAAI,OAAO,UAAU,WAAW,QAAQ,KAAK;AAG3E,UAAM,aAAa,MAAM,QAAQ,aAAa,KAAK;AACnD,UAAM,WAAW,WAAW,SAAS,IAAI,CAAA,MAAK,EAAE,IAAI;AAEpD,QAAI,CAAC,SAAS,SAAS,YAAY,GAAG;AACpC,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,QAC1B,OAAO;AAAA,UACL,MAAM;AAAA,UACN,SAAS,kBAAkB,YAAY;AAAA,QAAA;AAAA,MACzC,CACD;AAAA,IACH;AAEA,QAAI,CAAC,SAAS,SAAS,YAAY,GAAG;AACpC,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,QAC1B,OAAO;AAAA,UACL,MAAM;AAAA,UACN,SAAS,kBAAkB,YAAY;AAAA,QAAA;AAAA,MACzC,CACD;AAAA,IACH;AAGA,UAAM,uBAAuB,MAAM,QAAQ,QAAQ,SAAS,aAAa,QAAQ,UAAU,YAAY,CAAC,EAAE;AAG1G,UAAM,QAAQ,QAAQ,SAAS,YAAY,QAAQ,UAAU,YAAY,CAAC,EAAE;AAE5E,QAAI;AACF,UAAI;AACJ,UAAI;AAEJ,UAAI,aAAa,UAAU;AAEzB,sBAAc,MAAM,QAAQ,QAAQ,SAAS,UAAU,QAAQ,UAAU,YAAY,CAAC,EAAE;AACxF,sBAAc,MAAM,QAAQ,QAAQ,SAAS,gBAAgB;AAAA,MAC/D,WAAW,aAAa,UAAU;AAEhC,sBAAc,MAAM,QAAQ,QAAQ,SAAS,kBAAkB,QAAQ,UAAU,YAAY,CAAC,EAAE;AAChG,cAAM,UAAU,iBAAiB,mBAAmB,YAAY,SAAS,YAAY;AACrF,cAAM,QAAQ,QAAQ,SAAS,aAAa,QAAQ,UAAU,OAAO,CAAC,EAAE;AACxE,sBAAc,MAAM,QAAQ,QAAQ,SAAS,gBAAgB;AAAA,MAC/D,WAAW,aAAa,WAAW;AAEjC,sBAAc,MAAM,QAAQ,QAAQ,SAAS,mBAAmB,QAAQ,UAAU,YAAY,CAAC,EAAE;AACjG,sBAAc,MAAM,QAAQ,QAAQ,SAAS,gBAAgB;AAAA,MAC/D,OAAO;AAEL,cAAM,UAAU,iBAAiB,SAAS,YAAY,SAAS,YAAY;AAC3E,sBAAc,MAAM,QAAQ;AAAA,UAAQ;AAAA,UAClC,SAAS,QAAQ,UAAU,YAAY,CAAC,OAAO,QAAQ,UAAU,OAAO,CAAC;AAAA,QAAA;AAE3E,sBAAc,MAAM,QAAQ,QAAQ,SAAS,gBAAgB;AAAA,MAC/D;AAGA,YAAM,aAAa,MAAM,QAAQ,QAAQ,SAAS,uCAAuC;AACzF,YAAM,CAAC,MAAM,QAAQ,OAAO,WAAW,OAAO,IAAI,WAAW,MAAM,IAAI;AAGvE,YAAM,aAAa,MAAM,QAAQ,QAAQ,SAAS,eAAe,oBAAoB,QAAQ;AAG7F,UAAI,IAAI,IAAI,OAAO,IAAI;AACrB,YAAI;AACF,gBAAM,IAAI,IAAI,OAAO,GAAG;AAAA,YACtB;AAAA;AAAA,YAEA,CAAC,MAAM,OAAO,SAAS,cAAc,aAAa,SAAS,SAAS;AAAA,UAAA;AAAA,QAExE,SAAS,SAAS;AAChBX,mBAAO,KAAK,uCAAuC,OAAO;AAAA,QAE5D;AAAA,MACF;AAEA,UAAI,KAAK;AAAA,QACP,SAAS;AAAA,QACT;AAAA,QACA,OAAO;AAAA,UACL;AAAA,UACA;AAAA,UACA;AAAA,UACA,QAAQ;AAAA,YACN;AAAA,YACA;AAAA,YACA;AAAA,YACA,WAAW,IAAI,KAAK,SAAS,SAAS,IAAI,GAAI,EAAE,YAAA;AAAA,YAChD,SAAS;AAAA,UAAA;AAAA,UAEX,MAAM;AAAA,YACJ,SAAS;AAAA,YACT,gBAAgB;AAAA,YAChB;AAAA,UAAA;AAAA,UAEF,QAAQ;AAAA,QAAA;AAAA,MACV,CACD;AAAA,IAEH,SAAS,OAAO;AAEd,UAAI,MAAM,QAAQ,SAAS,UAAU,KAAK,MAAM,QAAQ,SAAS,UAAU,GAAG;AAE5E,YAAI,eAAe,CAAA;AAEnB,YAAI;AACF,gBAAM,SAAS,MAAM,QAAQ,QAAQ,SAAS,oBAAoB;AAClE,gBAAM,gBAAgB,OAAO,MAAM,IAAI,EACpC,OAAO,CAAA,SAAQ,KAAK,WAAW,KAAK,KAAK,KAAK,WAAW,KAAK,KAAK,KAAK,WAAW,KAAK,CAAC,EACzF,IAAI,CAAA,SAAQ,KAAK,UAAU,CAAC,EAAE,KAAA,CAAM;AAEvC,yBAAe;AAAA,YACb,OAAO;AAAA,YACP,OAAO,cAAc;AAAA,UAAA;AAIvB,cAAI,cAAc,SAAS,GAAG;AAC5B,kBAAM,kBAAkB,CAAA;AACxB,uBAAW,QAAQ,cAAc,MAAM,GAAG,CAAC,GAAG;AAC5C,kBAAI;AACF,sBAAM,UAAU,MAAMC,SAAG,SAAS,KAAK,KAAK,SAAS,IAAI,GAAG,MAAM;AAClE,sBAAM,YAAY,CAAA;AAClB,sBAAM,QAAQ,QAAQ,MAAM,IAAI;AAEhC,oBAAI,aAAa;AACjB,oBAAI,gBAAgB;AACpB,yBAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,sBAAI,MAAM,CAAC,EAAE,WAAW,SAAS,GAAG;AAClC,iCAAa;AACb,oCAAgB;AAAA,kBAClB,WAAW,MAAM,CAAC,EAAE,WAAW,SAAS,KAAK,YAAY;AACvD,8BAAU,KAAK;AAAA,sBACb,WAAW,gBAAgB;AAAA,sBAC3B,SAAS,IAAI;AAAA,sBACb,OAAO,MAAM,MAAM,eAAe,IAAI,CAAC;AAAA,oBAAA,CACxC;AACD,iCAAa;AAAA,kBACf;AAAA,gBACF;AAEA,gCAAgB,KAAK;AAAA,kBACnB;AAAA,kBACA;AAAA,gBAAA,CACD;AAAA,cACH,SAAS,WAAW;AAClB,gCAAgB,KAAK;AAAA,kBACnB;AAAA,kBACA,OAAO;AAAA,gBAAA,CACR;AAAA,cACH;AAAA,YACF;AAEA,yBAAa,UAAU;AAAA,UACzB;AAGA,cAAI;AACF,gBAAI,aAAa,UAAU;AACzB,oBAAM,QAAQ,QAAQ,SAAS,gBAAgB;AAAA,YACjD,OAAO;AACL,oBAAM,QAAQ,QAAQ,SAAS,eAAe;AAAA,YAChD;AAAA,UACF,SAAS,YAAY;AACnBD,qBAAO,KAAK,0BAA0B,UAAU;AAAA,UAClD;AAAA,QAEF,SAAS,aAAa;AACpBA,mBAAO,KAAK,mCAAmC,WAAW;AAAA,QAC5D;AAEA,eAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,UAC1B,SAAS;AAAA,UACT,OAAO;AAAA,YACL,MAAM;AAAA,YACN,SAAS;AAAA,YACT,WAAW;AAAA,UAAA;AAAA,UAEb;AAAA,UACA,OAAO;AAAA,YACL;AAAA,YACA;AAAA,YACA;AAAA,YACA,SAAS;AAAA,UAAA;AAAA,QACX,CACD;AAAA,MACH;AAGA,YAAM;AAAA,IACR;AAAA,EAEF,SAAS,OAAO;AACdA,aAAO,MAAM,oBAAoB,IAAI,OAAO,KAAK,KAAK,KAAK;AAG3D,QAAI;AACF,YAAM,UAAU,cAAc,GAAG;AACjC,YAAM,UAAU,KAAK,KAAK,IAAI,IAAI,OAAO,UAAU,WAAW,QAAQ,IAAI,OAAO,KAAK;AACtF,YAAM,QAAQ,QAAQ,SAAS,eAAe;AAAA,IAChD,SAAS,cAAc;AACrBA,eAAO,KAAK,wCAAwC,YAAY;AAAA,IAClE;AAEA,QAAI,OAAO,GAAG,EAAE,KAAK;AAAA,MACnB,SAAS;AAAA,MACT,OAAO;AAAA,QACL,MAAM;AAAA,QACN,SAAS,MAAM;AAAA,MAAA;AAAA,MAEjB,OAAO,IAAI,OAAO;AAAA,IAAA,CACnB;AAAA,EACH;AACF,CAAC;AAGDW,SAAO,IAAI,qBAAqB,OAAO,KAAK,KAAK,SAAS;AACxD,MAAI;AACF,UAAM,EAAE,UAAU,IAAI;AACtB,UAAM,EAAE,MAAM,KAAK,QAAQ,SAAS,UAAA,IAAc,IAAI;AACtD,UAAM,UAAU,cAAc,GAAG;AAEjC,QAAI,CAAC,MAAM;AACT,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,QAC1B,OAAO;AAAA,UACL,MAAM;AAAA,UACN,SAAS;AAAA,QAAA;AAAA,MACX,CACD;AAAA,IACH;AAEA,QAAI,CAAC,MAAM,QAAQ,UAAU,KAAK,GAAG;AACnC,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,QAC1B,OAAO;AAAA,UACL,MAAM;AAAA,UACN,SAAS,cAAc,KAAK;AAAA,QAAA;AAAA,MAC9B,CACD;AAAA,IACH;AAEA,UAAM,UAAU,KAAK,KAAK,IAAI,IAAI,OAAO,UAAU,WAAW,QAAQ,KAAK;AAG3E,UAAM,aAAa,MAAM,QAAQ,aAAa,KAAK;AACnD,UAAM,WAAW,WAAW,SAAS,IAAI,CAAA,MAAK,EAAE,IAAI;AAEpD,QAAI,CAAC,SAAS,SAAS,IAAI,GAAG;AAC5B,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,QAC1B,OAAO;AAAA,UACL,MAAM;AAAA,UACN,SAAS,gBAAgB,IAAI;AAAA,QAAA;AAAA,MAC/B,CACD;AAAA,IACH;AAEA,QAAI,CAAC,SAAS,SAAS,EAAE,GAAG;AAC1B,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,QAC1B,OAAO;AAAA,UACL,MAAM;AAAA,UACN,SAAS,cAAc,EAAE;AAAA,QAAA;AAAA,MAC3B,CACD;AAAA,IACH;AAGA,UAAM,WAAW,MAAM,QAAQ;AAAA,MAAQ;AAAA,MACrC,eAAe,QAAQ,UAAU,EAAE,CAAC,KAAK,QAAQ,UAAU,IAAI,CAAC;AAAA,IAAA;AAIlE,UAAM,cAAc,MAAM,QAAQ;AAAA,MAAQ;AAAA,MACxC,oBAAoB,QAAQ,UAAU,EAAE,CAAC,KAAK,QAAQ,UAAU,IAAI,CAAC;AAAA,IAAA;AAGvE,QAAI;AACJ,QAAI,WAAW,aAAa;AAC1B,oBAAc,MAAM,QAAQ;AAAA,QAAQ;AAAA,QAClC,oBAAoB,QAAQ,UAAU,EAAE,CAAC,KAAK,QAAQ,UAAU,IAAI,CAAC;AAAA,MAAA;AAAA,IAEzE,WAAW,WAAW,eAAe;AACnC,oBAAc,MAAM,QAAQ;AAAA,QAAQ;AAAA,QAClC,sBAAsB,QAAQ,UAAU,EAAE,CAAC,KAAK,QAAQ,UAAU,IAAI,CAAC;AAAA,MAAA;AAAA,IAE3E,OAAO;AAEL,oBAAc,MAAM,QAAQ;AAAA,QAAQ;AAAA,QAClC,QAAQ,QAAQ,UAAU,EAAE,CAAC,KAAK,QAAQ,UAAU,IAAI,CAAC;AAAA,MAAA;AAAA,IAE7D;AAGA,UAAM,eAAe,CAAA;AACrB,QAAI,UAAU;AACZ,YAAM,YAAY,SAAS,MAAM,IAAI,EAAE,MAAM,GAAG,EAAE;AAClD,iBAAW,QAAQ,WAAW;AAC5B,cAAM,QAAQ,KAAK,MAAM,mCAAmC;AAC5D,YAAI,OAAO;AACT,gBAAM,GAAG,UAAU,SAAS,UAAU,IAAI;AAC1C,gBAAM,aAAa,WAAW,MAAM,KAAK,KAAK,CAAA,GAAI;AAClD,gBAAM,aAAa,WAAW,MAAM,IAAI,KAAK,CAAA,GAAI;AAEjD,uBAAa,KAAK;AAAA,YAChB;AAAA,YACA,SAAS,SAAS,OAAO;AAAA,YACzB;AAAA,YACA;AAAA,UAAA,CACD;AAAA,QACH;AAAA,MACF;AAAA,IACF;AAEA,QAAI,KAAK;AAAA,MACP;AAAA,MACA,MAAM;AAAA,QACJ;AAAA,QACA;AAAA,QACA;AAAA,QACA,aAAa,SAAS,WAAW,KAAK;AAAA,QACtC;AAAA,QACA,SAAS;AAAA,QACT,SAAS;AAAA,MAAA;AAAA,IACX,CACD;AAAA,EAEH,SAAS,OAAO;AACd,SAAK,KAAK;AAAA,EACZ;AACF,CAAC;AAGDA,SAAO,IAAI,iCAAiC,OAAO,KAAK,KAAK,SAAS;AACpE,MAAI;AACF,UAAM,EAAE,gBAAgB,IAAI;AAC5B,UAAM,EAAE,GAAA,IAAO,IAAI,IAAI;AAGvB,UAAM,OAAO,MAAM,GAAG,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA,OAKvB,CAAC,WAAW,CAAC;AAEhB,QAAI,KAAK;AAAA,MACP;AAAA,MACA,MAAM,KAAK,IAAI,CAAA,SAAQ;AAAA,QACrB,WAAW,IAAI;AAAA,QACf,MAAM,IAAI;AAAA,QACV,SAAS,OAAO,IAAI,YAAY,WAAW,KAAK,MAAM,IAAI,OAAO,IAAI,IAAI;AAAA,MAAA,EACzE;AAAA,IAAA,CACH;AAAA,EACH,SAAS,OAAO;AACdX,aAAO,MAAM,oCAAoC,EAAE,aAAa,IAAI,OAAO,aAAa,OAAO,MAAM,QAAA,CAAS;AAC9G,SAAK,KAAK;AAAA,EACZ;AACF,CAAC;ACt1BD,MAAMA,WAAS,aAAa,oBAAoB;AAChD,MAAMW,WAAS,QAAQ,OAAA;AAGvB,MAAM,qCAAqB,IAAA;AAG3B,IAAI,cAAc;AAClB,MAAM,WAAW;AAEjB,SAAS,uBAAuB;AAC9B;AACA,MAAI,cAAc,UAAU;AAC1B,kBAAc;AAAA,EAChB;AACA,SAAO;AACT;AAGA,eAAe,qBAAqB,SAAS;AAC3C,MAAI;AACF,UAAMV,SAAG,OAAO,KAAK,KAAK,SAAS,mBAAmB,CAAC;AACvD,WAAO;AAAA,EACT,QAAQ;AAAA,EAAC;AAET,MAAI;AACF,UAAMA,SAAG,OAAO,KAAK,KAAK,SAAS,WAAW,CAAC;AAC/C,WAAO;AAAA,EACT,QAAQ;AAAA,EAAC;AAET,MAAI;AACF,UAAMA,SAAG,OAAO,KAAK,KAAK,SAAS,gBAAgB,CAAC;AACpD,WAAO;AAAA,EACT,QAAQ;AAAA,EAAC;AAET,MAAI;AACF,UAAMA,SAAG,OAAO,KAAK,KAAK,SAAS,WAAW,CAAC;AAC/C,WAAO;AAAA,EACT,QAAQ;AAAA,EAAC;AAGT,MAAI;AACF,UAAMA,SAAG,OAAO,KAAK,KAAK,SAAS,cAAc,CAAC;AAClD,WAAO;AAAA,EACT,QAAQ;AAAA,EAAC;AAET,SAAO;AACT;AAGA,SAAS,WAAW,WAAW,OAAO;AACpC,SAAO,KAAK,KAAK,WAAW,QAAQ,KAAK;AAC3C;AAGAU,SAAO,KAAK,8BAA8B,OAAO,KAAK,QAAQ;AAC5D,MAAI;AACF,UAAM,EAAE,UAAU,IAAI;AACtB,UAAM,EAAE,UAAA,IAAc,IAAI,IAAI;AAE9BX,aAAO,KAAK,4BAA4B,KAAK,EAAE;AAG/C,QAAI,eAAe,IAAI,KAAK,GAAG;AAC7B,YAAMwB,WAAU,eAAe,IAAI,KAAK;AACxC,UAAIA,SAAQ,WAAW,WAAW;AAChC,eAAO,IAAI,KAAK;AAAA,UACd,SAAS;AAAA,UACT,WAAWA,SAAQ;AAAA,UACnB,MAAMA,SAAQ;AAAA,UACd,KAAK,oBAAoBA,SAAQ,IAAI;AAAA,UACrC,QAAQ;AAAA,QAAA,CACT;AAAA,MACH;AAAA,IACF;AAEA,UAAM,UAAU,WAAW,UAAU,WAAW,KAAK;AAGrD,QAAI;AACF,YAAMvB,SAAG,OAAO,OAAO;AAAA,IACzB,QAAQ;AACN,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,QAC1B,OAAO;AAAA,UACL,MAAM;AAAA,UACN,SAAS,aAAa,KAAK;AAAA,QAAA;AAAA,MAC7B,CACD;AAAA,IACH;AAGA,UAAM,iBAAiB,MAAM,qBAAqB,OAAO;AACzD,QAAI,CAAC,gBAAgB;AACnB,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,QAC1B,OAAO;AAAA,UACL,MAAM;AAAA,UACN,SAAS;AAAA,QAAA;AAAA,MACX,CACD;AAAA,IACH;AAGA,UAAM,YAAYQ,GAAA;AAClB,UAAM,OAAO,qBAAA;AACb,UAAM,UAAU;AAAA,MACd,IAAI;AAAA,MACJ;AAAA,MACA;AAAA,MACA,QAAQ;AAAA,MACR,MAAM,CAAA;AAAA,MACN,SAAS;AAAA,MACT,cAAc,IAAI,aAAA;AAAA,IAAa;AAGjC,mBAAe,IAAI,OAAO,OAAO;AAGjCT,aAAO,KAAK,gCAAgC,cAAc,YAAY,KAAK,EAAE;AAE7E,UAAM,aAAa,mBAAmB,QAAQ,QAAQ;AACtD,UAAM,cAAc,CAAC,SAAS;AAE9B,UAAM,iBAAiB,MAAM,YAAY,aAAa;AAAA,MACpD,KAAK;AAAA,MACL,KAAK,EAAE,GAAG,QAAA,KAAa,IAAI,OAAA;AAAA,IAAO,CACnC;AAED,mBAAe,OAAO,GAAG,QAAQ,CAAC,SAAS;AACzC,YAAM,MAAM,EAAE,YAAW,oBAAI,KAAA,GAAO,eAAe,MAAM,QAAQ,SAAS,KAAK,WAAS;AACxF,cAAQ,KAAK,KAAK,GAAG;AACrB,cAAQ,aAAa,KAAK,OAAO,GAAG;AAAA,IACtC,CAAC;AAED,mBAAe,OAAO,GAAG,QAAQ,CAAC,SAAS;AACzC,YAAM,MAAM,EAAE,YAAW,oBAAI,KAAA,GAAO,eAAe,MAAM,SAAS,SAAS,KAAK,WAAS;AACzF,cAAQ,KAAK,KAAK,GAAG;AACrB,cAAQ,aAAa,KAAK,OAAO,GAAG;AAAA,IACtC,CAAC;AAED,mBAAe,GAAG,SAAS,CAAC,SAAS;AACnC,UAAI,SAAS,GAAG;AACd,gBAAQ,SAAS;AACjB,gBAAQ,aAAa,KAAK,UAAU,EAAE,QAAQ,SAAS;AACvD;AAAA,MACF;AAGA,cAAQ,SAAS;AACjB,cAAQ,aAAa,KAAK,UAAU,EAAE,QAAQ,YAAY;AAE1DA,eAAO,KAAK,+BAA+B,IAAI,YAAY,KAAK,EAAE;AAElE,YAAM,SAAS,mBAAmB,QAAQ,QAAQ;AAClD,YAAM,UAAU,CAAC,OAAO,KAAK;AAE7B,YAAM,aAAa,MAAM,QAAQ,SAAS;AAAA,QACxC,KAAK;AAAA,QACL,KAAK;AAAA,UACH,GAAG,QAAA;AAAA,UACH,MAAM,KAAK,SAAA;AAAA,UACX,WAAW,KAAK,SAAA;AAAA;AAAA,UAChB,WAAW,KAAK,SAAA;AAAA;AAAA,UAChB,gBAAgB,KAAK,SAAA;AAAA;AAAA,QAAS;AAAA,MAChC,CACD;AAED,cAAQ,UAAU;AAElB,iBAAW,OAAO,GAAG,QAAQ,CAAC,SAAS;AACrC,cAAM,MAAM,EAAE,YAAW,oBAAI,KAAA,GAAO,eAAe,MAAM,QAAQ,SAAS,KAAK,WAAS;AACxF,gBAAQ,KAAK,KAAK,GAAG;AACrB,gBAAQ,aAAa,KAAK,OAAO,GAAG;AAGpC,cAAM,SAAS,KAAK,SAAA,EAAW,YAAA;AAC/B,YAAI,OAAO,SAAS,OAAO,KAAK,OAAO,SAAS,SAAS,KAAK,OAAO,SAAS,SAAS,KAAK,OAAO,SAAS,aAAa,IAAI,EAAE,GAAG;AAChI,kBAAQ,SAAS;AACjB,kBAAQ,aAAa,KAAK,UAAU;AAAA,YAClC,QAAQ;AAAA,YACR,MAAM,QAAQ;AAAA,YACd,KAAK,oBAAoB,QAAQ,IAAI;AAAA,UAAA,CACtC;AAAA,QACH;AAAA,MACF,CAAC;AAED,iBAAW,OAAO,GAAG,QAAQ,CAAC,SAAS;AACrC,cAAM,MAAM,EAAE,YAAW,oBAAI,KAAA,GAAO,eAAe,MAAM,SAAS,SAAS,KAAK,WAAS;AACzF,gBAAQ,KAAK,KAAK,GAAG;AACrB,gBAAQ,aAAa,KAAK,OAAO,GAAG;AAAA,MACtC,CAAC;AAED,iBAAW,GAAG,SAAS,CAACyB,UAAS;AAC/BzB,iBAAO,KAAK,sBAAsB,KAAK,qBAAqByB,KAAI,EAAE;AAClE,gBAAQ,SAAS;AACjB,gBAAQ,aAAa,KAAK,UAAU,EAAE,QAAQ,WAAW;AACzD,uBAAe,OAAO,KAAK;AAAA,MAC7B,CAAC;AAAA,IACH,CAAC;AAED,QAAI,KAAK;AAAA,MACP,SAAS;AAAA,MACT;AAAA,MACA;AAAA,MACA,QAAQ;AAAA,IAAA,CACT;AAAA,EACH,SAAS,OAAO;AACdzB,aAAO,MAAM,2BAA2B,KAAK;AAC7C,QAAI,OAAO,GAAG,EAAE,KAAK;AAAA,MACnB,OAAO;AAAA,QACL,MAAM;AAAA,QACN,SAAS,MAAM;AAAA,MAAA;AAAA,IACjB,CACD;AAAA,EACH;AACF,CAAC;AAGDW,SAAO,IAAI,+BAA+B,OAAO,KAAK,QAAQ;AAC5D,MAAI;AACF,UAAM,EAAE,UAAU,IAAI;AAEtB,UAAM,UAAU,eAAe,IAAI,KAAK;AACxC,QAAI,CAAC,SAAS;AACZ,aAAO,IAAI,KAAK;AAAA,QACd,QAAQ;AAAA,QACR,SAAS;AAAA,MAAA,CACV;AAAA,IACH;AAEA,QAAI,KAAK;AAAA,MACP,QAAQ,QAAQ;AAAA,MAChB,SAAS,QAAQ,WAAW;AAAA,MAC5B,MAAM,QAAQ;AAAA,MACd,KAAK,QAAQ,WAAW,YAAY,oBAAoB,QAAQ,IAAI,KAAK;AAAA,MACzE,WAAW,QAAQ;AAAA,IAAA,CACpB;AAAA,EACH,SAAS,OAAO;AACdX,aAAO,MAAM,iCAAiC,KAAK;AACnD,QAAI,OAAO,GAAG,EAAE,KAAK;AAAA,MACnB,OAAO;AAAA,QACL,MAAM;AAAA,QACN,SAAS,MAAM;AAAA,MAAA;AAAA,IACjB,CACD;AAAA,EACH;AACF,CAAC;AAGDW,SAAO,KAAK,6BAA6B,OAAO,KAAK,QAAQ;AAC3D,MAAI;AACF,UAAM,EAAE,UAAU,IAAI;AAEtB,UAAM,UAAU,eAAe,IAAI,KAAK;AACxC,QAAI,CAAC,SAAS;AACZ,aAAO,IAAI,KAAK,EAAE,SAAS,MAAM;AAAA,IACnC;AAEA,QAAI,QAAQ,SAAS;AACnB,cAAQ,QAAQ,KAAK,SAAS;AAE9B,iBAAW,MAAM;AACf,YAAI,QAAQ,WAAW,CAAC,QAAQ,QAAQ,QAAQ;AAC9C,kBAAQ,QAAQ,KAAK,SAAS;AAAA,QAChC;AAAA,MACF,GAAG,GAAI;AAAA,IACT;AAEA,mBAAe,OAAO,KAAK;AAE3B,QAAI,KAAK,EAAE,SAAS,KAAA,CAAM;AAAA,EAC5B,SAAS,OAAO;AACdX,aAAO,MAAM,2BAA2B,KAAK;AAC7C,QAAI,OAAO,GAAG,EAAE,KAAK;AAAA,MACnB,OAAO;AAAA,QACL,MAAM;AAAA,QACN,SAAS,MAAM;AAAA,MAAA;AAAA,IACjB,CACD;AAAA,EACH;AACF,CAAC;AAGDW,SAAO,IAAI,6BAA6B,OAAO,KAAK,QAAQ;AAC1D,MAAI;AACF,UAAM,EAAE,UAAU,IAAI;AACtB,UAAM,EAAE,cAAc,IAAI;AAE1B,UAAM,UAAU,eAAe,IAAI,KAAK;AACxC,QAAI,CAAC,WAAW,QAAQ,OAAO,WAAW;AACxC,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,QAC1B,OAAO;AAAA,UACL,MAAM;AAAA,UACN,SAAS;AAAA,QAAA;AAAA,MACX,CACD;AAAA,IACH;AAEAX,aAAO,KAAK,+BAA+B,KAAK,YAAY,SAAS,EAAE;AAEvE,QAAI,UAAU,KAAK;AAAA,MACjB,gBAAgB;AAAA,MAChB,iBAAiB;AAAA,MACjB,cAAc;AAAA,MACd,+BAA+B;AAAA,IAAA,CAChC;AAGD,YAAQ,KAAK,MAAM,GAAG,EAAE,QAAQ,CAAA,QAAO;AACrC,UAAI,MAAM;AAAA,QAAqB,KAAK,UAAU,GAAG,CAAC;AAAA;AAAA,CAAM;AAAA,IAC1D,CAAC;AAGD,QAAI,MAAM;AAAA,QAAwB,KAAK,UAAU;AAAA,MAC/C,QAAQ,QAAQ;AAAA,MAChB,MAAM,QAAQ;AAAA,MACd,KAAK,QAAQ,WAAW,YAAY,oBAAoB,QAAQ,IAAI,KAAK;AAAA,IAAA,CAC1E,CAAC;AAAA;AAAA,CAAM;AAGR,UAAM,aAAa,CAAC,QAAQ;AAC1B,UAAI,MAAM;AAAA,QAAqB,KAAK,UAAU,GAAG,CAAC;AAAA;AAAA,CAAM;AAAA,IAC1D;AAEA,UAAM,gBAAgB,CAAC,WAAW;AAChC,UAAI,MAAM;AAAA,QAAwB,KAAK,UAAU,MAAM,CAAC;AAAA;AAAA,CAAM;AAAA,IAChE;AAEA,YAAQ,aAAa,GAAG,OAAO,UAAU;AACzC,YAAQ,aAAa,GAAG,UAAU,aAAa;AAG/C,UAAM,YAAY,YAAY,MAAM;AAClC,UAAI,MAAM,gBAAgB;AAAA,IAC5B,GAAG,GAAK;AAGR,QAAI,GAAG,SAAS,MAAM;AACpB,oBAAc,SAAS;AACvB,cAAQ,aAAa,IAAI,OAAO,UAAU;AAC1C,cAAQ,aAAa,IAAI,UAAU,aAAa;AAChDA,eAAO,KAAK,6BAA6B,KAAK,EAAE;AAAA,IAClD,CAAC;AAAA,EACH,SAAS,OAAO;AACdA,aAAO,MAAM,yBAAyB,KAAK;AAC3C,QAAI,OAAO,GAAG,EAAE,KAAK;AAAA,MACnB,OAAO;AAAA,QACL,MAAM;AAAA,QACN,SAAS,MAAM;AAAA,MAAA;AAAA,IACjB,CACD;AAAA,EACH;AACF,CAAC;ACnWD,MAAMA,WAAS,aAAa,gBAAgB;AAE5C,MAAM,eAAe;AAAA,EACnB,YAAY,kBAAkBM,aAAY,gBAAgB,IAAI;AAC5D,SAAK,mBAAmB;AACxB,SAAK,aAAaA;AAClB,SAAK,iBAAiB;AACtB,SAAK,KAAK;AAAA,EACZ;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,iBAAiB,aAAa,UAAU,IAAI;AAChDN,aAAO,KAAK,kCAAkC,WAAW,EAAE;AAC3D,UAAM,UAAU;AAAA,MACd,SAAS;AAAA,MACT,WAAW,EAAE,SAAS,GAAG,QAAQ,EAAA;AAAA,MACjC,WAAW,EAAE,SAAS,MAAA;AAAA,MACtB,UAAU,EAAE,SAAS,GAAG,QAAQ,EAAA;AAAA,MAChC,QAAQ,CAAA;AAAA,IAAC;AAGX,QAAI;AAEF,YAAM,WAAW,MAAM,KAAK,eAAe,qBAAqB,WAAW;AAC3E,UAAI,CAAC,UAAU;AACbA,iBAAO,KAAK,mCAAmC,WAAW,2BAA2B;AACrF,eAAO,MAAM,KAAK,qBAAqB,aAAa,OAAO;AAAA,MAC7D;AAGA,UAAI,SAAS,WAAW;AACtB,cAAM,kBAAkB,MAAM,KAAK,iBAAiB,aAAa,SAAS,WAAW,OAAO;AAC5F,gBAAQ,YAAY;AAAA,MACtB;AAGA,UAAI,CAAC,QAAQ,gBAAgB,SAAS,WAAW;AAC/C,cAAM,gBAAgB,MAAM,KAAK,gBAAgB,aAAa,SAAS,SAAS;AAChF,gBAAQ,WAAW;AAAA,MACrB;AAGA,UAAI,CAAC,QAAQ,eAAe;AAC1B,YAAI;AACF,gBAAM,KAAK,eAAe,0BAA0B,WAAW;AAC/D,kBAAQ,UAAU,UAAU;AAAA,QAC9B,SAAS,OAAO;AACdA,mBAAO,MAAM,mCAAmC,WAAW,KAAK,KAAK;AACrE,kBAAQ,OAAO,KAAK,EAAE,MAAM,aAAa,OAAO,MAAM,SAAS;AAC/D,kBAAQ,UAAU;AAAA,QACpB;AAAA,MACF;AAGA,UAAI,QAAQ,mBAAmB,OAAO;AACpC,cAAM,KAAK,oBAAoB,aAAa,OAAO;AAAA,MACrD;AAAA,IAEF,SAAS,OAAO;AACdA,eAAO,MAAM,gCAAgC,WAAW,KAAK,KAAK;AAClE,cAAQ,UAAU;AAClB,cAAQ,OAAO,KAAK,EAAE,MAAM,WAAW,OAAO,MAAM,SAAS;AAAA,IAC/D;AAEAA,aAAO,KAAK,mCAAmC,WAAW,IAAI,OAAO;AACrE,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,iBAAiB,aAAa,WAAW,UAAU,CAAA,GAAI;AAC3D,UAAM,UAAU,EAAE,SAAS,GAAG,QAAQ,GAAG,SAAS,GAAC;AAEnD,eAAW,CAAC,OAAO,YAAY,KAAK,OAAO,QAAQ,SAAS,GAAG;AAC7D,UAAI;AACFA,iBAAO,KAAK,6BAA6B,KAAK,iBAAiB,WAAW,EAAE;AAG5E,YAAI,QAAQ,OAAO;AAEjB,cAAI;AACF,kBAAM,KAAK,WAAW,QAAQ,aAAa,cAAc,mBAAmB;AAC5E,kBAAM,KAAK,WAAW,QAAQ,aAAa,cAAc,WAAW;AAAA,UACtE,SAAS,GAAG;AAAA,UAEZ;AAAA,QACF;AAEA,cAAM,KAAK,WAAW,eAAe,OAAO,aAAa,YAAY;AACrE,gBAAQ;AACR,gBAAQ,QAAQ,KAAK,IAAI,EAAE,SAAS,KAAA;AAAA,MACtC,SAAS,OAAO;AACdA,iBAAO,MAAM,qCAAqC,KAAK,KAAK,KAAK;AACjE,gBAAQ;AACR,gBAAQ,QAAQ,KAAK,IAAI,EAAE,SAAS,OAAO,OAAO,MAAM,QAAA;AAAA,MAC1D;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,gBAAgB,aAAa,WAAW;AAC5C,UAAM,UAAU,EAAE,SAAS,GAAG,QAAQ,GAAG,SAAS,GAAC;AACnD,UAAM,aAAa,QAAQ,WAAW;AAItCA,aAAO,KAAK,+BAA+B,UAAU,kBAAkB;AAEvE,eAAW,CAAC,OAAO,YAAY,KAAK,OAAO,QAAQ,SAAS,GAAG;AAC7D,cAAQ,QAAQ,KAAK,IAAI;AAAA,QACvB,SAAS;AAAA,QACT,QAAQ;AAAA,QACR,SAAS;AAAA,MAAA;AAAA,IAEb;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,qBAAqB,aAAa,UAAU,IAAI;AACpD,UAAM,UAAU;AAAA,MACd,SAAS;AAAA,MACT,WAAW,EAAE,SAAS,MAAA;AAAA,MACtB,QAAQ,CAAA;AAAA,IAAC;AAGX,QAAI,CAAC,QAAQ,eAAe;AAC1B,UAAI;AACF,cAAM,gBAAgB,KAAK,KAAK,KAAK,iBAAiB,oBAAoB,cAAc,QAAQ,WAAW,EAAE;AAC7G,cAAMC,SAAG,GAAG,eAAe,EAAE,WAAW,MAAM,OAAO,MAAM;AAC3D,gBAAQ,UAAU,UAAU;AAAA,MAC9B,SAAS,OAAO;AACdD,iBAAO,MAAM,mCAAmC,WAAW,KAAK,KAAK;AACrE,gBAAQ,UAAU;AAClB,gBAAQ,OAAO,KAAK,EAAE,MAAM,aAAa,OAAO,MAAM,SAAS;AAAA,MACjE;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,0BAA0B,iBAAiB,IAAI;AACnDA,aAAO,KAAK,8CAA8C,cAAc,QAAQ;AAChF,UAAM,UAAU;AAAA,MACd,SAAS;AAAA,MACT,SAAS;AAAA,MACT,QAAQ;AAAA,MACR,QAAQ,CAAA;AAAA,IAAC;AAGX,QAAI;AAEF,YAAM,gBAAgB,KAAK,KAAK,KAAK,iBAAiB,iBAAA,GAAoB,YAAY;AACtF,YAAM,UAAU,MAAMC,SAAG,QAAQ,eAAe,EAAE,eAAe,MAAM;AAEvE,YAAM,aAAa,KAAK,IAAA,IAAS,iBAAiB,KAAK,KAAK;AAE5D,iBAAW,SAAS,SAAS;AAC3B,YAAI,MAAM,iBAAiB,MAAM,KAAK,WAAW,OAAO,GAAG;AACzD,kBAAQ;AACR,gBAAM,cAAc,MAAM,KAAK,UAAU,CAAC;AAC1C,gBAAM,gBAAgB,KAAK,KAAK,eAAe,MAAM,IAAI;AAEzD,cAAI;AAEF,kBAAM,YAAY,MAAM,KAAK,GAAG;AAAA,cAC9B;AAAA,cACA,CAAC,WAAW;AAAA,YAAA;AAGd,kBAAM,OAAO,MAAMA,SAAG,KAAK,aAAa;AACxC,kBAAM,QAAQ,KAAK,UAAU;AAK7B,gBAAI,CAAC,aAAa,OAAO;AACvBD,uBAAO,KAAK,+BAA+B,WAAW,oBAAoB;AAC1E,oBAAM,KAAK,iBAAiB,aAAa,EAAE,OAAO,MAAM;AACxD,sBAAQ;AAAA,YACV,WAAW,aAAa,SAAS,CAAC,aAAa,QAAQ,EAAE,SAAS,UAAU,MAAM,GAAG;AAEnF,kBAAI,UAAU,wBAAwB,GAAG;AACvCA,yBAAO,KAAK,gCAAgC,WAAW,EAAE;AAAA,cAC3D,OAAO;AACLA,yBAAO,KAAK,gBAAgB,UAAU,MAAM,cAAc,WAAW,EAAE;AACvE,sBAAM,KAAK,iBAAiB,aAAa,EAAE,OAAO,MAAM;AACxD,wBAAQ;AAAA,cACV;AAAA,YACF;AAAA,UACF,SAAS,OAAO;AACdA,qBAAO,MAAM,+BAA+B,WAAW,KAAK,KAAK;AACjE,oBAAQ;AACR,oBAAQ,OAAO,KAAK,EAAE,aAAa,OAAO,MAAM,SAAS;AAAA,UAC3D;AAAA,QACF;AAAA,MACF;AAAA,IACF,SAAS,OAAO;AACdA,eAAO,MAAM,yCAAyC,KAAK;AAC3D,cAAQ,OAAO,KAAK,EAAE,MAAM,QAAQ,OAAO,MAAM,SAAS;AAAA,IAC5D;AAEAA,aAAO,KAAK,wCAAwC,OAAO;AAC3D,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,kBAAkB,aAAa,SAAS,2BAA2B;AACvEA,aAAO,KAAK,0BAA0B,WAAW,KAAK,MAAM,EAAE;AAE9D,QAAI;AAEF,YAAM,YAAY,MAAM,KAAK,GAAG;AAAA,QAC9B;AAAA,QACA,CAAC,WAAW;AAAA,MAAA;AAGd,UAAI,CAAC,WAAW;AACd,cAAM,IAAI,MAAM,aAAa,WAAW,YAAY;AAAA,MACtD;AAGA,YAAM,KAAK,GAAG;AAAA,QACZ;AAAA;AAAA,QAEA,CAAC,aAAa,MAAM,YAAY,MAAM;AAAA,MAAA;AAIxC,YAAM,UAAU,MAAM,KAAK,iBAAiB,aAAa;AAAA,QACvD,OAAO;AAAA,QACP,cAAc;AAAA,QACd,eAAe;AAAA,MAAA,CAChB;AAGD,YAAM,KAAK,GAAG;AAAA,QACZ;AAAA,QACA,CAAC,eAAe,WAAW;AAAA,MAAA;AAG7B,aAAO;AAAA,QACL,SAAS;AAAA,QACT;AAAA,QACA;AAAA,QACA,SAAS;AAAA,MAAA;AAAA,IAGb,SAAS,OAAO;AACdA,eAAO,MAAM,iCAAiC,WAAW,KAAK,KAAK;AACnE,aAAO;AAAA,QACL,SAAS;AAAA,QACT;AAAA,QACA,OAAO,MAAM;AAAA,MAAA;AAAA,IAEjB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,oBAAoB,aAAa,SAAS;AAC9C,QAAI;AACF,YAAM,cAAc,KAAK,UAAU;AAAA,QACjC,YAAW,oBAAI,KAAA,GAAO,YAAA;AAAA,QACtB;AAAA,MAAA,CACD;AAED,YAAM,KAAK,GAAG;AAAA,QACZ;AAAA;AAAA;AAAA,QAGA,CAAC,aAAa,WAAW;AAAA,MAAA;AAAA,IAE7B,SAAS,OAAO;AACdA,eAAO,MAAM,uCAAuC,WAAW,KAAK,KAAK;AAAA,IAC3E;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,iBAAiB,aAAa;AAClC,UAAM,YAAY,MAAM,KAAK,GAAG;AAAA,MAC9B;AAAA,MACA,CAAC,WAAW;AAAA,IAAA;AAGd,QAAI,CAAC,aAAa,CAAC,UAAU,gBAAgB;AAC3C,aAAO;AAAA,IACT;AAEA,QAAI;AACF,aAAO,KAAK,MAAM,UAAU,cAAc;AAAA,IAC5C,SAAS,OAAO;AACd,aAAO,UAAU;AAAA,IACnB;AAAA,EACF;AACF;ACpTA,MAAMA,WAAS,aAAa,gBAAgB;AAC5C,MAAMW,WAAS,QAAQ,OAAA;AAGvBA,SAAO,KAAK,oCAAoC,OAAO,KAAK,KAAK,SAAS;AACxE,MAAI;AACF,UAAM,EAAE,gBAAgB,IAAI;AAC5B,UAAM,EAAE,QAAQ,OAAO,eAAe,OAAO,gBAAgB,UAAU,IAAI;AAE3E,UAAM,EAAE,kBAAkB,GAAA,IAAO,IAAI,IAAI;AACzC,UAAML,cAAa,IAAI,WAAW,iBAAiB,kBAAkB;AACrE,UAAM,iBAAiB,IAAI,wBAAwB,kBAAkBA,WAAU;AAC/E,UAAM,iBAAiB,IAAI,eAAe,kBAAkBA,aAAY,gBAAgB,EAAE;AAE1FN,aAAO,KAAK,0CAA0C,WAAW,IAAI,EAAE,OAAO,cAAc,eAAe;AAE3G,UAAM,UAAU,MAAM,eAAe,iBAAiB,aAAa;AAAA,MACjE;AAAA,MACA;AAAA,MACA;AAAA,IAAA,CACD;AAED,QAAI,KAAK;AAAA,MACP;AAAA,MACA,SAAS;AAAA,IAAA,CACV;AAAA,EAEH,SAAS,OAAO;AACdA,aAAO,MAAM,kBAAkB,KAAK;AACpC,SAAK,KAAK;AAAA,EACZ;AACF,CAAC;AAGDW,SAAO,KAAK,qCAAqC,OAAO,KAAK,KAAK,SAAS;AACzE,MAAI;AACF,UAAM,EAAE,gBAAgB,IAAI;AAC5B,UAAM,EAAE,SAAS,4BAAA,IAAgC,IAAI;AAErD,UAAM,EAAE,kBAAkB,GAAA,IAAO,IAAI,IAAI;AACzC,UAAML,cAAa,IAAI,WAAW,iBAAiB,kBAAkB;AACrE,UAAM,iBAAiB,IAAI,wBAAwB,kBAAkBA,WAAU;AAC/E,UAAM,iBAAiB,IAAI,eAAe,kBAAkBA,aAAY,gBAAgB,EAAE;AAE1FN,aAAO,KAAK,oCAAoC,WAAW,IAAI,EAAE,QAAQ;AAEzE,UAAM,SAAS,MAAM,eAAe,kBAAkB,aAAa,MAAM;AAEzE,QAAI,OAAO,SAAS;AAClB,UAAI,KAAK,MAAM;AAAA,IACjB,OAAO;AACL,UAAI,OAAO,GAAG,EAAE,KAAK;AAAA,QACnB,OAAO;AAAA,UACL,MAAM;AAAA,UACN,SAAS,OAAO;AAAA,QAAA;AAAA,MAClB,CACD;AAAA,IACH;AAAA,EAEF,SAAS,OAAO;AACdA,aAAO,MAAM,mBAAmB,KAAK;AACrC,SAAK,KAAK;AAAA,EACZ;AACF,CAAC;AAGDW,SAAO,IAAI,2CAA2C,OAAO,KAAK,KAAK,SAAS;AAC9E,MAAI;AACF,UAAM,EAAE,gBAAgB,IAAI;AAE5B,UAAM,EAAE,kBAAkB,GAAA,IAAO,IAAI,IAAI;AACzC,UAAML,cAAa,IAAI,WAAW,iBAAiB,kBAAkB;AACrE,UAAM,iBAAiB,IAAI,wBAAwB,kBAAkBA,WAAU;AAC/E,UAAM,iBAAiB,IAAI,eAAe,kBAAkBA,aAAY,gBAAgB,EAAE;AAE1F,UAAM,SAAS,MAAM,eAAe,iBAAiB,WAAW;AAEhE,QAAI,QAAQ;AACV,UAAI,KAAK;AAAA,QACP;AAAA,QACA,eAAe;AAAA,MAAA,CAChB;AAAA,IACH,OAAO;AACL,UAAI,OAAO,GAAG,EAAE,KAAK;AAAA,QACnB,OAAO;AAAA,UACL,MAAM;AAAA,UACN,SAAS;AAAA,QAAA;AAAA,MACX,CACD;AAAA,IACH;AAAA,EAEF,SAAS,OAAO;AACdN,aAAO,MAAM,6BAA6B,KAAK;AAC/C,SAAK,KAAK;AAAA,EACZ;AACF,CAAC;AAGDW,SAAO,KAAK,qBAAqB,OAAO,KAAK,KAAK,SAAS;AACzD,MAAI;AACF,UAAM,EAAE,iBAAiB,GAAA,IAAO,IAAI;AAEpC,UAAM,EAAE,kBAAkB,GAAA,IAAO,IAAI,IAAI;AACzC,UAAML,cAAa,IAAI,WAAW,iBAAiB,kBAAkB;AACrE,UAAM,iBAAiB,IAAI,wBAAwB,kBAAkBA,WAAU;AAC/E,UAAM,iBAAiB,IAAI,eAAe,kBAAkBA,aAAY,gBAAgB,EAAE;AAE1FN,aAAO,KAAK,2CAA2C,cAAc,QAAQ;AAE7E,UAAM,UAAU,MAAM,eAAe,0BAA0B,cAAc;AAE7E,QAAI,KAAK;AAAA,MACP;AAAA,MACA;AAAA,IAAA,CACD;AAAA,EAEH,SAAS,OAAO;AACdA,aAAO,MAAM,2BAA2B,KAAK;AAC7C,SAAK,KAAK;AAAA,EACZ;AACF,CAAC;AAKDW,SAAO,OAAO,sCAAsC,OAAO,KAAK,KAAK,SAAS;AAC5E,MAAI;AACF,UAAM,cAAcK,oBAA+B,IAAI,OAAO,WAAW;AACzE,UAAM,EAAE,kBAAkB,GAAA,IAAO,IAAI,IAAI;AAGzC,UAAM,YAAY,MAAM,GAAG;AAAA,MACzB;AAAA,MACA,CAAC,WAAW;AAAA,IAAA;AAGd,QAAI,CAAC,WAAW;AACd,YAAM,IAAI,cAAc,wBAAwB,WAAW,EAAE;AAAA,IAC/D;AAGA,QAAI,UAAU,WAAW,gBAAgB,WAAW,UAAU,WAAW,gBAAgB,UAAU;AACjG,YAAM,IAAI;AAAA,QACR,WAAW;AAAA,QACX,0DAA0D,UAAU,MAAM;AAAA,MAAA;AAAA,IAE9E;AAEAhB,aAAO,KAAK,qDAAqD,WAAW,EAAE;AAG9E,UAAMM,cAAa,IAAI,WAAW,iBAAiB,kBAAkB;AACrE,UAAM,iBAAiB,IAAI,wBAAwB,kBAAkBA,WAAU;AAC/E,UAAM,iBAAiB,IAAI,eAAe,kBAAkBA,aAAY,gBAAgB,EAAE;AAG1F,UAAM,UAAU,MAAM,eAAe,iBAAiB,aAAa;AAAA,MACjE,cAAc;AAAA;AAAA,MACd,eAAe;AAAA,MACf,gBAAgB;AAAA,IAAA,CACjB;AAGD,UAAM,GAAG;AAAA,MACP;AAAA,MACA,CAAC,WAAW;AAAA,IAAA;AAGd,QAAI,KAAK;AAAA,MACP,SAAS,QAAQ;AAAA,MACjB;AAAA,MACA,SAAS;AAAA,IAAA,CACV;AAAA,EAEH,SAAS,OAAO;AACd,QAAI,MAAM,SAAS,mBAAmB;AACpC,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK,oBAAoB,KAAK,CAAC;AAAA,IACxD;AACA,QAAI,MAAM,SAAS,iBAAiB;AAClC,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK,oBAAoB,KAAK,CAAC;AAAA,IACxD;AACA,QAAI,MAAM,SAAS,gBAAgB;AACjC,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK,oBAAoB,KAAK,CAAC;AAAA,IACxD;AACA,SAAK,KAAK;AAAA,EACZ;AACF,CAAC;AChMD,MAAMN,WAAS,aAAa,kBAAkB;AAC9C,MAAMW,WAAS,QAAQ,OAAA;AAGvBA,SAAO,IAAI,qBAAqB,OAAO,KAAK,KAAK,SAAS;AACxD,MAAI;AACF,UAAM,EAAE,gBAAA,IAAoB,IAAI,IAAI;AAEpC,QAAI,CAAC,iBAAiB;AACpB,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,QAC1B,OAAO;AAAA,UACL,MAAM;AAAA,UACN,SAAS;AAAA,QAAA;AAAA,MACX,CACD;AAAA,IACH;AAEA,UAAM,SAAS,MAAM,gBAAgB,kBAAA;AAErC,QAAI,KAAK;AAAA,MACP,QAAQ,OAAO,UAAU,YAAY;AAAA,MACrC,WAAW,OAAO;AAAA,MAClB,QAAQ,OAAO;AAAA,MACf,OAAO,OAAO;AAAA,IAAA,CACf;AAAA,EAEH,SAAS,OAAO;AACdX,aAAO,MAAM,0BAA0B,KAAK;AAC5C,SAAK,KAAK;AAAA,EACZ;AACF,CAAC;AAGDW,SAAO,IAAI,0BAA0B,OAAO,KAAK,KAAK,SAAS;AAC7D,MAAI;AACF,UAAM,EAAE,gBAAA,IAAoB,IAAI,IAAI;AAEpC,QAAI,CAAC,iBAAiB;AACpB,aAAO,IAAI,KAAK;AAAA,QACd,YAAY;AAAA,QACZ,QAAQ;AAAA,MAAA,CACT;AAAA,IACH;AAEA,UAAM,aAAa,MAAM,gBAAgB,kBAAA;AACzC,UAAM,SAAS,MAAM,QAAQ,IAAI;AAAA,MAC/B,gBAAgB,0BAAA;AAAA,MAChB,gBAAgB,eAAA;AAAA,MAChB,gBAAgB,qBAAA;AAAA,IAAqB,CACtC;AAED,UAAM,YAAY,OAAO,OAAO,CAAA,UAAS,CAAC,MAAM,OAAO;AAEvD,QAAI,KAAK;AAAA,MACP;AAAA,MACA,QAAQ,OAAO,OAAO,CAAC,KAAK,UAAU;AACpC,YAAI,MAAM,IAAI,IAAI;AAAA,UAChB,SAAS,MAAM;AAAA,UACf,SAAS,MAAM;AAAA,UACf,OAAO,MAAM;AAAA,UACb,SAAS,MAAM;AAAA,QAAA;AAEjB,eAAO;AAAA,MACT,GAAG,CAAA,CAAE;AAAA,MACL,WAAW,UAAU,IAAI,CAAA,UAAS,MAAM,IAAI;AAAA,IAAA,CAC7C;AAAA,EAEH,SAAS,OAAO;AACdX,aAAO,MAAM,4BAA4B,KAAK;AAC9C,SAAK,KAAK;AAAA,EACZ;AACF,CAAC;AAGDW,SAAO,IAAI,4BAA4B,OAAO,KAAK,KAAK,SAAS;AAC/D,MAAI;AACF,UAAM,EAAE,GAAA,IAAO,IAAI,IAAI;AACvB,UAAM;AAAA,MACJ,QAAQ;AAAA,MACR,OAAO;AAAA,MACP,QAAQ;AAAA,IAAA,IACN,IAAI;AAER,QAAI,MAAM;AAAA;AAAA,4CAE8B,SAAS,KAAK,CAAC;AAAA;AAEvD,UAAM,SAAS,CAAA;AAEf,QAAI,MAAM;AACR,aAAO;AACP,aAAO,KAAK,IAAI;AAAA,IAClB;AAEA,WAAO;AACP,WAAO,KAAK,SAAS,KAAK,CAAC;AAE3B,UAAM,UAAU,MAAM,GAAG,IAAI,KAAK,MAAM;AAExC,QAAI,KAAK;AAAA,MACP,SAAS,QAAQ,IAAI,CAAA,YAAW;AAAA,QAC9B,WAAW,OAAO;AAAA,QAClB,MAAM,OAAO;AAAA,QACb,SAAS,OAAO;AAAA,QAChB,OAAO,OAAO;AAAA,QACd,UAAU,QAAQ,OAAO,QAAQ;AAAA,QACjC,SAAS,OAAO,UAAU,KAAK,MAAM,OAAO,OAAO,IAAI;AAAA,MAAA,EACvD;AAAA,MACF,cAAc,QAAQ;AAAA,MACtB,WAAW,SAAS,KAAK;AAAA,IAAA,CAC1B;AAAA,EAEH,SAAS,OAAO;AACdX,aAAO,MAAM,2BAA2B,KAAK;AAC7C,SAAK,KAAK;AAAA,EACZ;AACF,CAAC;ACpHD,MAAM,SAAS,aAAa,mBAAmB;AAC/C,MAAMW,WAAS,QAAQ,OAAA;AAGvBA,SAAO,IAAI,uBAAuB,OAAO,KAAK,KAAK,SAAS;AAC1D,MAAI;AACF,UAAM,EAAE,mBAAA,IAAuB,IAAI,IAAI;AAEvC,QAAI,CAAC,oBAAoB;AACvB,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,QAC1B,OAAO;AAAA,UACL,MAAM;AAAA,UACN,SAAS;AAAA,QAAA;AAAA,MACX,CACD;AAAA,IACH;AAEA,UAAM,UAAU,mBAAmB,WAAA;AACnC,UAAM,UAAU,mBAAmB,kBAAkB,SAAS,IAAI,MAAM,aAAa,KAAK,GAAI;AAC9F,UAAM,YAAY,mBAAmB,oBAAA;AACrC,UAAM,WAAW,mBAAmB,mBAAmB,SAAS,IAAI,MAAM,cAAc,KAAK,GAAM;AAEnG,QAAI,KAAK;AAAA,MACP,SAAS,QAAQ;AAAA,MACjB,SAAS;AAAA,QACP,kBAAkB,QAAQ;AAAA,QAC1B,gBAAgB,QAAQ;AAAA,QACxB,iBAAiB,SAAS;AAAA,QAC1B,aAAa,QAAQ;AAAA,MAAA;AAAA,MAEvB,gBAAgB;AAAA,MAChB,kBAAkB;AAAA,MAClB,iBAAiB;AAAA,IAAA,CAClB;AAAA,EAEH,SAAS,OAAO;AACd,WAAO,MAAM,sBAAsB,KAAK;AACxC,SAAK,KAAK;AAAA,EACZ;AACF,CAAC;AAGDA,SAAO,IAAI,kCAAkC,OAAO,KAAK,KAAK,SAAS;AACrE,MAAI;AACF,UAAM,EAAE,gBAAgB,IAAI;AAC5B,UAAM,EAAE,YAAA,IAAgB,IAAI,IAAI;AAEhC,QAAI,CAAC,aAAa;AAChB,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,QAC1B,OAAO;AAAA,UACL,MAAM;AAAA,UACN,SAAS;AAAA,QAAA;AAAA,MACX,CACD;AAAA,IACH;AAEA,UAAM,aAAa,MAAM,YAAY,uBAAuB,WAAW;AAEvE,QAAI,KAAK;AAAA,MACP,WAAW;AAAA,MACX;AAAA,IAAA,CACD;AAAA,EAEH,SAAS,OAAO;AACd,WAAO,MAAM,0BAA0B,KAAK;AAC5C,SAAK,KAAK;AAAA,EACZ;AACF,CAAC;AAGDA,SAAO,IAAI,sBAAsB,OAAO,KAAK,KAAK,SAAS;AACzD,MAAI;AACF,UAAM,EAAE,YAAA,IAAgB,IAAI,IAAI;AAChC,UAAM,EAAE,aAAa,WAAA,IAAe,IAAI;AAExC,QAAI,CAAC,aAAa;AAChB,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,QAC1B,OAAO;AAAA,UACL,MAAM;AAAA,UACN,SAAS;AAAA,QAAA;AAAA,MACX,CACD;AAAA,IACH;AAEA,UAAM,gBAAgB,MAAM,YAAY,iBAAiB,UAAU;AAEnE,QAAI,KAAK,aAAa;AAAA,EAExB,SAAS,OAAO;AACd,WAAO,MAAM,6BAA6B,KAAK;AAC/C,SAAK,KAAK;AAAA,EACZ;AACF,CAAC;AAGDA,SAAO,IAAI,oBAAoB,OAAO,KAAK,KAAK,SAAS;AACvD,MAAI;AACF,UAAM,EAAE,GAAA,IAAO,IAAI,IAAI;AACvB,UAAM;AAAA,MACJ,OAAO;AAAA;AAAA,MACP,cAAc;AAAA,MACd,YAAY;AAAA,MACZ,UAAU;AAAA,MACV,QAAQ;AAAA,MACR,SAAS;AAAA,MACT,aAAa;AAAA,IAAA,IACX,IAAI;AAER,UAAM,UAAU,CAAA;AAChB,UAAM,iBAAiB,iCAAiC,UAAU;AAGlE,UAAM,UAAU,CAAA;AAEhB,QAAI,SAAS,SAAS,SAAS,OAAO;AACpC,UAAI,WAAW;AAAA;AAAA,gBAEL,cAAc;AAAA;AAExB,YAAM,YAAY,CAAA;AAElB,UAAI,aAAa;AACf,oBAAY;AACZ,kBAAU,KAAK,WAAW;AAAA,MAC5B;AACA,UAAI,WAAW;AACb,oBAAY;AACZ,kBAAU,KAAK,SAAS;AAAA,MAC1B;AACA,UAAI,YAAY,MAAM;AACpB,oBAAY;AACZ,kBAAU,KAAK,YAAY,SAAS,IAAI,CAAC;AAAA,MAC3C;AAEA,kBAAY;AACZ,gBAAU,KAAK,SAAS,KAAK,GAAG,SAAS,MAAM,CAAC;AAEhD,cAAQ,KAAK,EAAE,MAAM,OAAO,OAAO,UAAU,QAAQ,WAAW;AAAA,IAClE;AAEA,QAAI,SAAS,SAAS,SAAS,UAAU;AACvC,UAAI,cAAc;AAAA;AAAA,gBAER,cAAc;AAAA;AAExB,YAAM,eAAe,CAAA;AAErB,UAAI,aAAa;AACf,uBAAe;AACf,qBAAa,KAAK,WAAW;AAAA,MAC/B;AACA,UAAI,WAAW;AACb,uBAAe;AACf,qBAAa,KAAK,SAAS;AAAA,MAC7B;AACA,UAAI,YAAY,MAAM;AACpB,uBAAe;AACf,qBAAa,KAAK,YAAY,SAAS,IAAI,CAAC;AAAA,MAC9C;AAEA,qBAAe;AACf,mBAAa,KAAK,SAAS,KAAK,GAAG,SAAS,MAAM,CAAC;AAEnD,cAAQ,KAAK,EAAE,MAAM,UAAU,OAAO,aAAa,QAAQ,cAAc;AAAA,IAC3E;AAEA,QAAI,SAAS,SAAS,SAAS,eAAe;AAC5C,UAAI,YAAY;AAAA;AAAA,gBAEN,cAAc;AAAA;AAExB,YAAM,aAAa,CAAA;AAEnB,UAAI,aAAa;AACf,qBAAa;AACb,mBAAW,KAAK,WAAW;AAAA,MAC7B;AACA,UAAI,WAAW;AACb,qBAAa;AACb,mBAAW,KAAK,SAAS;AAAA,MAC3B;AACA,UAAI,YAAY,MAAM;AACpB,qBAAa;AACb,mBAAW,KAAK,YAAY,SAAS,IAAI,CAAC;AAAA,MAC5C;AAEA,mBAAa;AACb,iBAAW,KAAK,SAAS,KAAK,GAAG,SAAS,MAAM,CAAC;AAEjD,cAAQ,KAAK,EAAE,MAAM,eAAe,OAAO,WAAW,QAAQ,YAAY;AAAA,IAC5E;AAEA,QAAI,SAAS,SAAS,SAAS,aAAa;AAC1C,UAAI,gBAAgB;AAAA;AAAA,gBAEV,cAAc;AAAA;AAExB,YAAM,iBAAiB,CAAA;AAEvB,UAAI,aAAa;AACf,yBAAiB;AACjB,uBAAe,KAAK,WAAW;AAAA,MACjC;AAEA,uBAAiB;AACjB,qBAAe,KAAK,SAAS,KAAK,GAAG,SAAS,MAAM,CAAC;AAErD,cAAQ,KAAK,EAAE,MAAM,aAAa,OAAO,eAAe,QAAQ,gBAAgB;AAAA,IAClF;AAGA,eAAW,EAAE,MAAM,OAAAD,QAAO,OAAA,KAAY,SAAS;AAC7C,YAAM,OAAO,MAAM,GAAG,IAAIA,QAAO,MAAM;AACvC,cAAQ,IAAI,IAAI,KAAK,IAAI,CAAA,QAAO;AAE9B,YAAI,IAAI,UAAU;AAChB,cAAI;AACF,gBAAI,WAAW,KAAK,MAAM,IAAI,QAAQ;AAAA,UACxC,SAAS,GAAG;AAAA,UAEZ;AAAA,QACF;AACA,YAAI,IAAI,SAAS;AACf,cAAI;AACF,gBAAI,UAAU,KAAK,MAAM,IAAI,OAAO;AAAA,UACtC,SAAS,GAAG;AAAA,UAEZ;AAAA,QACF;AACA,eAAO;AAAA,MACT,CAAC;AAAA,IACH;AAEA,QAAI,KAAK;AAAA,MACP,SAAS;AAAA,QACP;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA,OAAO,SAAS,KAAK;AAAA,QACrB,QAAQ,SAAS,MAAM;AAAA,MAAA;AAAA,MAEzB;AAAA,MACA,aAAa,OAAO,KAAK,OAAO,EAAE,OAAO,CAAC,KAAK,QAAQ;AACrD,YAAI,GAAG,IAAI,QAAQ,GAAG,EAAE;AACxB,eAAO;AAAA,MACT,GAAG,CAAA,CAAE;AAAA,IAAA,CACN;AAAA,EAEH,SAAS,OAAO;AACd,WAAO,MAAM,qBAAqB,KAAK;AACvC,SAAK,KAAK;AAAA,EACZ;AACF,CAAC;AAGDC,SAAO,KAAK,uBAAuB,OAAO,KAAK,KAAK,SAAS;AAC3D,MAAI;AACF,UAAM,EAAE,YAAA,IAAgB,IAAI,IAAI;AAChC,UAAM,EAAE,gBAAgB,GAAA,IAAO,IAAI;AAEnC,QAAI,CAAC,aAAa;AAChB,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,QAC1B,OAAO;AAAA,UACL,MAAM;AAAA,UACN,SAAS;AAAA,QAAA;AAAA,MACX,CACD;AAAA,IACH;AAEA,UAAM,SAAS,MAAM,YAAY,eAAe,SAAS,aAAa,CAAC;AAEvE,QAAI,KAAK;AAAA,MACP,SAAS;AAAA,MACT;AAAA,IAAA,CACD;AAAA,EAEH,SAAS,OAAO;AACd,WAAO,MAAM,uBAAuB,KAAK;AACzC,SAAK,KAAK;AAAA,EACZ;AACF,CAAC;AAGDA,SAAO,KAAK,6BAA6B,OAAO,KAAK,KAAK,SAAS;AACjE,MAAI;AACF,UAAM,EAAE,mBAAA,IAAuB,IAAI,IAAI;AAEvC,QAAI,CAAC,oBAAoB;AACvB,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,QAC1B,OAAO;AAAA,UACL,MAAM;AAAA,UACN,SAAS;AAAA,QAAA;AAAA,MACX,CACD;AAAA,IACH;AAEA,uBAAmB,aAAA;AAEnB,QAAI,KAAK;AAAA,MACP,SAAS;AAAA,MACT,UAAS,oBAAI,KAAA,GAAO,YAAA;AAAA,IAAY,CACjC;AAAA,EAEH,SAAS,OAAO;AACd,WAAO,MAAM,wBAAwB,KAAK;AAC1C,SAAK,KAAK;AAAA,EACZ;AACF,CAAC;ACjTc,aAAa,uBAAuB;AACnD,MAAM,SAAS,QAAQ,OAAA;AAKvB,OAAO,IAAI,kCAAkC,OAAO,KAAK,KAAK,SAAS;AACrE,MAAI;AACF,UAAM,cAAcK,oBAA+B,IAAI,OAAO,WAAW;AACzE,UAAM,EAAE,MAAM,UAAU,IAAI,YAAY,MAAA,IAAU,IAAI;AACtD,UAAM,EAAE,IAAI,iBAAA,IAAqB,IAAI,IAAI;AAGzC,UAAM,YAAY,MAAM,GAAG;AAAA,MACzB;AAAA,MACA,CAAC,WAAW;AAAA,IAAA;AAGd,QAAI,CAAC,WAAW;AACd,YAAM,IAAI,cAAc,wBAAwB,WAAW,EAAE;AAAA,IAC/D;AAGA,UAAM,gBAAgB,KAAK;AAAA,MACzB,iBAAiB,iBAAA;AAAA,MACjB;AAAA,MACA,QAAQ,WAAW;AAAA,IAAA;AAIrB,QAAI;AACF,YAAMf,SAAG,OAAO,aAAa;AAAA,IAC/B,SAAS,OAAO;AACd,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,QAC1B,OAAO;AAAA,UACL,MAAM;AAAA,UACN,SAAS;AAAA,QAAA;AAAA,MACX,CACD;AAAA,IACH;AAGA,UAAM,WAAW,KAAK,KAAK,eAAe,OAAO;AAGjD,QAAI,CAAC,SAAS,WAAW,aAAa,GAAG;AACvC,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,QAC1B,OAAO;AAAA,UACL,MAAM;AAAA,UACN,SAAS;AAAA,QAAA;AAAA,MACX,CACD;AAAA,IACH;AAEA,QAAI;AACF,YAAM,QAAQ,MAAMA,SAAG,KAAK,QAAQ;AAEpC,UAAI,CAAC,MAAM,eAAe;AACxB,eAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,UAC1B,OAAO;AAAA,YACL,MAAM;AAAA,YACN,SAAS;AAAA,UAAA;AAAA,QACX,CACD;AAAA,MACH;AAEA,UAAI,cAAc,UAAU,cAAc,MAAM;AAE9C,cAAM,QAAQ,MAAM,mBAAmB,UAAU,aAAa;AAC9D,YAAI,KAAK,EAAE,OAAO;AAAA,MACpB,OAAO;AAEL,cAAM,UAAU,MAAM,cAAc,UAAU,aAAa;AAC3D,YAAI,KAAK,EAAE,SAAS;AAAA,MACtB;AAAA,IAEF,SAAS,OAAO;AACd,UAAI,MAAM,SAAS,UAAU;AAC3B,eAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,UAC1B,OAAO;AAAA,YACL,MAAM;AAAA,YACN,SAAS;AAAA,UAAA;AAAA,QACX,CACD;AAAA,MACH;AACA,YAAM;AAAA,IACR;AAAA,EAEF,SAAS,OAAO;AACd,QAAI,MAAM,SAAS,mBAAmB;AACpC,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK,oBAAoB,KAAK,CAAC;AAAA,IACxD;AACA,QAAI,MAAM,SAAS,iBAAiB;AAClC,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK,oBAAoB,KAAK,CAAC;AAAA,IACxD;AACA,SAAK,KAAK;AAAA,EACZ;AACF,CAAC;AAKD,OAAO,IAAI,iCAAiC,OAAO,KAAK,KAAK,SAAS;AACpE,MAAI;AACF,UAAM,cAAce,oBAA+B,IAAI,OAAO,WAAW;AACzE,UAAM,EAAE,MAAM,SAAA,IAAa,IAAI;AAC/B,UAAM,EAAE,IAAI,iBAAA,IAAqB,IAAI,IAAI;AAEzC,QAAI,CAAC,UAAU;AACb,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,QAC1B,OAAO;AAAA,UACL,MAAM;AAAA,UACN,SAAS;AAAA,QAAA;AAAA,MACX,CACD;AAAA,IACH;AAGA,UAAM,YAAY,MAAM,GAAG;AAAA,MACzB;AAAA,MACA,CAAC,WAAW;AAAA,IAAA;AAGd,QAAI,CAAC,WAAW;AACd,YAAM,IAAI,cAAc,wBAAwB,WAAW,EAAE;AAAA,IAC/D;AAGA,UAAM,gBAAgB,KAAK;AAAA,MACzB,iBAAiB,iBAAA;AAAA,MACjB;AAAA,MACA,QAAQ,WAAW;AAAA,IAAA;AAIrB,QAAI;AACF,YAAMf,SAAG,OAAO,aAAa;AAAA,IAC/B,SAAS,OAAO;AACd,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,QAC1B,OAAO;AAAA,UACL,MAAM;AAAA,UACN,SAAS;AAAA,QAAA;AAAA,MACX,CACD;AAAA,IACH;AAGA,UAAM,WAAW,KAAK,KAAK,eAAe,QAAQ;AAGlD,QAAI,CAAC,SAAS,WAAW,aAAa,GAAG;AACvC,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,QAC1B,OAAO;AAAA,UACL,MAAM;AAAA,UACN,SAAS;AAAA,QAAA;AAAA,MACX,CACD;AAAA,IACH;AAEA,QAAI;AACF,YAAM,QAAQ,MAAMA,SAAG,KAAK,QAAQ;AAEpC,UAAI,CAAC,MAAM,UAAU;AACnB,eAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,UAC1B,OAAO;AAAA,YACL,MAAM;AAAA,YACN,SAAS;AAAA,UAAA;AAAA,QACX,CACD;AAAA,MACH;AAGA,YAAM,UAAU,KAAK,OAAO;AAC5B,UAAI,MAAM,OAAO,SAAS;AACxB,eAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,UAC1B,OAAO;AAAA,YACL,MAAM;AAAA,YACN,SAAS,uBAAuB,OAAO;AAAA,UAAA;AAAA,QACzC,CACD;AAAA,MACH;AAGA,YAAM,UAAU,MAAMA,SAAG,SAAS,UAAU,MAAM;AAElD,UAAI,KAAK;AAAA,QACP,MAAM,KAAK,SAAS,eAAe,QAAQ;AAAA,QAC3C,MAAM,MAAM;AAAA,QACZ,UAAU,MAAM;AAAA,QAChB;AAAA,MAAA,CACD;AAAA,IAEH,SAAS,OAAO;AACd,UAAI,MAAM,SAAS,UAAU;AAC3B,eAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,UAC1B,OAAO;AAAA,YACL,MAAM;AAAA,YACN,SAAS;AAAA,UAAA;AAAA,QACX,CACD;AAAA,MACH;AACA,UAAI,MAAM,SAAS,UAAU;AAC3B,eAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,UAC1B,OAAO;AAAA,YACL,MAAM;AAAA,YACN,SAAS;AAAA,UAAA;AAAA,QACX,CACD;AAAA,MACH;AACA,YAAM;AAAA,IACR;AAAA,EAEF,SAAS,OAAO;AACd,QAAI,MAAM,SAAS,mBAAmB;AACpC,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK,oBAAoB,KAAK,CAAC;AAAA,IACxD;AACA,QAAI,MAAM,SAAS,iBAAiB;AAClC,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK,oBAAoB,KAAK,CAAC;AAAA,IACxD;AACA,SAAK,KAAK;AAAA,EACZ;AACF,CAAC;AAKD,eAAe,cAAc,SAAS,UAAU;AAC9C,QAAM,UAAU,CAAA;AAChB,QAAM,QAAQ,MAAMA,SAAG,QAAQ,SAAS,EAAE,eAAe,MAAM;AAE/D,aAAW,QAAQ,OAAO;AACxB,UAAM,WAAW,KAAK,KAAK,SAAS,KAAK,IAAI;AAC7C,UAAM,eAAe,KAAK,SAAS,UAAU,QAAQ;AACrD,UAAM,QAAQ,MAAMA,SAAG,KAAK,QAAQ;AAEpC,YAAQ,KAAK;AAAA,MACX,MAAM,KAAK;AAAA,MACX,MAAM;AAAA,MACN,MAAM,KAAK,YAAA,IAAgB,cAAc;AAAA,MACzC,MAAM,MAAM;AAAA,MACZ,UAAU,MAAM;AAAA,IAAA,CACjB;AAAA,EACH;AAGA,UAAQ,KAAK,CAAC,GAAG,MAAM;AACrB,QAAI,EAAE,SAAS,EAAE,MAAM;AACrB,aAAO,EAAE,KAAK,cAAc,EAAE,IAAI;AAAA,IACpC;AACA,WAAO,EAAE,SAAS,cAAc,KAAK;AAAA,EACvC,CAAC;AAED,SAAO;AACT;AAKA,eAAe,mBAAmB,SAAS,UAAU,QAAQ,CAAA,GAAI;AAC/D,QAAM,QAAQ,MAAMA,SAAG,QAAQ,SAAS,EAAE,eAAe,MAAM;AAE/D,aAAW,QAAQ,OAAO;AACxB,UAAM,WAAW,KAAK,KAAK,SAAS,KAAK,IAAI;AAC7C,UAAM,eAAe,KAAK,SAAS,UAAU,QAAQ;AAErD,QAAI,KAAK,eAAe;AACtB,YAAM,mBAAmB,UAAU,UAAU,KAAK;AAAA,IACpD,OAAO;AACL,YAAM,KAAK,YAAY;AAAA,IACzB;AAAA,EACF;AAEA,SAAO;AACT;ACnPkB,KAAK,QAAQ,cAAc,YAAY,GAAG,CAAC;AAOtD,MAAM,aAAa;AAAA,EAOxB,YAAY,UAAyB,IAAI;AALzC,SAAQ,KAAsB;AAE9B,SAAQ,YAAqB;AAI3B,SAAK,OAAO,QAAQ,QAAQ;AAC5B,SAAK,eAAe,IAAI,aAAA;AAAA,EAC1B;AAAA,EAEA,MAAM,QAAuB;AAC3B,QAAI,KAAK,WAAW;AAClB,cAAQ,IAAI,kCAAkC;AAC9C;AAAA,IACF;AAEA,QAAI;AACF,YAAMD,UAAS,aAAa,mBAAmB;AAG/C,YAAM0B,QAAM,QAAA;AAGZA,YAAI,IAAI,QAAQ,MAAM;AACtBA,YAAI,IAAI,KAAK;AAAA,QACX,QAAQ,CAAC,yBAAyB,uBAAuB;AAAA;AAAA,QACzD,aAAa;AAAA,MAAA,CACd,CAAC;AAGFA,YAAI,IAAI,CAAC,KAAU,KAAU,SAAc;AACzC,gBAAQ,IAAI,IAAG,oBAAI,KAAA,GAAO,YAAA,CAAa,IAAI,IAAI,MAAM,IAAI,IAAI,IAAI,EAAE;AACnE,aAAA;AAAA,MACF,CAAC;AAGDA,YAAI,IAAI,WAAW,CAAC,KAAU,QAAa;AACzC,YAAI,KAAK;AAAA,UACP,QAAQ;AAAA,UACR,YAAW,oBAAI,KAAA,GAAO,YAAA;AAAA,UACtB,SAAS;AAAA,UACT,UAAU;AAAA,QAAA,CACX;AAAA,MACH,CAAC;AAGD,YAAM,eAAeC,IAAY,QAAQ,UAAU;AACnD,YAAM,gBAAgB,KAAK,KAAK,cAAc,kBAAkB;AAKhE,YAAM,mBAAmB,IAAI,iBAAiB,aAAa;AAC3D,YAAM,YAAY,MAAM,iBAAiB,WAAA;AAGzCD,YAAI,OAAO,YAAY;AACvBA,YAAI,OAAO,mBAAmB;AAG9B,YAAM,SAAS,KAAK,KAAK,UAAU,SAAS,kBAAkB;AAC9D,WAAK,KAAK,IAAI,SAAS,MAAM;AAC7B,YAAM,KAAK,GAAG,WAAA;AAGdA,YAAI,OAAO,KAAK,KAAK;AACrBA,YAAI,OAAO,eAAe,KAAK;AAC/BA,YAAI,OAAO,SAAS;AAGpBA,YAAI,OAAO,iBAAiB,IAAI,eAAe,KAAK,IAAI,QAAQ,KAAK,YAAY;AACjFA,YAAI,OAAO,gBAAgB,IAAI,cAAc,KAAK,IAAI,KAAK,YAAY;AAGvEA,YAAI,OAAO,cAAc,IAAI,YAAY,KAAK,EAAE;AAGhDA,YAAI,OAAO,qBAAqB,IAAI,mBAAmBA,MAAI,OAAO,WAAW;AAG7E,YAAMpB,cAAa,IAAI,WAAW,UAAU,WAAWoB,MAAI,OAAO,kBAAkB;AACpFA,YAAI,OAAO,qBAAqB,IAAI,mBAAmB,kBAAkBpB,aAAY,MAAM,MAAM,KAAK,EAAE;AAGxGoB,YAAI,OAAO,kBAAkB,IAAI,gBAAgB,kBAAkB,KAAK,IAAI;AAAA,QAC1E,yBAAyB,YAAY,6BAA6B;AAAA,QAClE,gBAAgB,YAAY,qBAAqB;AAAA,QACjD,yBAAyB,YAAY,8BAA8B;AAAA,QACnE,eAAe,YAAY,2BAA2B;AAAA;AAAA,MAAA,CACvD;AAGDA,YAAI,OAAO,gBAAgB,MAAA;AAI3BA,YAAI,IAAI,KAAKE,QAAa;AAC1BF,YAAI,IAAI,KAAKG,QAAY;AACzBH,YAAI,IAAI,KAAKI,QAAa;AAC1BJ,YAAI,IAAI,KAAKK,QAAU;AACvBL,YAAI,IAAI,KAAKM,QAAW;AACxBN,YAAI,IAAI,YAAYO,QAAa;AACjCP,YAAI,IAAI,KAAKQ,QAAU;AACvBR,YAAI,IAAI,KAAKS,QAAgB;AAC7BT,YAAI,IAAI,KAAKU,QAAa;AAC1BV,YAAI,IAAI,KAAKW,QAAe;AAC5BX,YAAI,IAAI,KAAKY,QAAgB;AAC7BZ,YAAI,IAAI,KAAKa,MAAoB;AAGjCb,YAAI,IAAI,CAAC,KAAU,KAAU,KAAU,SAAc;AACnD,gBAAQ,MAAM,UAAU,GAAG;AAG3B,YAAI,IAAI,SAAS,mBAAmB;AAClC,iBAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,YAC1B,OAAO;AAAA,cACL,MAAM;AAAA,cACN,SAAS,IAAI;AAAA,cACb,SAAS,IAAI,WAAW,CAAA;AAAA,YAAC;AAAA,UAC3B,CACD;AAAA,QACH;AAEA,YAAI,IAAI,SAAS,iBAAiB;AAChC,iBAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,YAC1B,OAAO;AAAA,cACL,MAAM;AAAA,cACN,SAAS,IAAI;AAAA,YAAA;AAAA,UACf,CACD;AAAA,QACH;AAGA,YAAI,OAAO,GAAG,EAAE,KAAK;AAAA,UACnB,OAAO;AAAA,YACL,MAAM;AAAA,YACN,SAAS;AAAA,YACT,SAAS,QAAA,IAAY,aAAa,gBAAgB,IAAI,UAAU;AAAA,UAAA;AAAA,QAClE,CACD;AAAA,MACH,CAAC;AAGDA,YAAI,IAAI,CAAC,KAAU,QAAa;AAC9B,YAAI,OAAO,GAAG,EAAE,KAAK;AAAA,UACnB,OAAO;AAAA,YACL,MAAM;AAAA,YACN,SAAS,YAAY,IAAI,MAAM,IAAI,IAAI,IAAI;AAAA,UAAA;AAAA,QAC7C,CACD;AAAA,MACH,CAAC;AAGD,WAAK,SAASA,MAAI,OAAO,KAAK,MAAM,MAAM;AACxC,QAAA1B,QAAO,KAAK,iCAAiC,KAAK,IAAI,EAAE;AACxD,QAAAA,QAAO,KAAK,cAAc,UAAU,SAAS,EAAE;AAC/C,aAAK,YAAY;AAAA,MACnB,CAAC;AAGD0B,YAAI,OAAO,mBAAmB,IAAI;AAAA,QAChC,KAAK;AAAA,QACL;AAAA,QACA,KAAK;AAAA,QACL;AAAA,MAAA;AAIFA,YAAI,OAAO,iBAAiB,IAAI,eAAe,KAAK,IAAIA,MAAI,OAAO,gBAAgB,KAAK,YAAY;AAGpG,WAAK,aAAa,GAAG,OAAO,cAAc,OAAO,EAAE,aAAa,WAAgB;AAC9E,QAAA1B,QAAO,KAAK,gCAAgC,WAAW,cAAc,IAAI,EAAE;AAG3E,YAAI,SAAS,GAAG;AAEd,gBAAM,OAAO,MAAM,KAAK,GAAG;AAAA,YACzB;AAAA,YACA,CAAC,WAAW;AAAA,UAAA;AAGd,cAAI,KAAK,SAAS,GAAG;AACnB,YAAAA,QAAO,KAAK,sCAAsC,WAAW,SAAS,KAAK,MAAM,aAAa;AAG9F,uBAAW,YAAY;AACrB,kBAAI;AACF,sBAAM,SAAS,MAAM0B,MAAI,OAAO,mBAAmB,0BAA0B,aAAa;AAAA,kBACxF,eAAe,0BAA0B,WAAW;AAAA,kBACpD,OAAO;AAAA,kBACP,SAAS;AAAA;AAAA,gBAAA,CACV;AAED,oBAAI,OAAO,SAAS;AAClB,kBAAA1B,QAAO,KAAK,oDAAoD,WAAW,EAAE;AAAA,gBAC/E,OAAO;AACL,kBAAAA,QAAO,MAAM,oCAAoC,WAAW,KAAK,OAAO,KAAK;AAAA,gBAC/E;AAAA,cACF,SAAS,OAAO;AACd,gBAAAA,QAAO,MAAM,mCAAmC,WAAW,KAAK,KAAK;AAAA,cACvE;AAAA,YACF,GAAG,GAAI;AAAA,UACT;AAAA,QACF;AAAA,MACF,CAAC;AAAA,IAEH,SAAS,OAAO;AACd,cAAQ,MAAM,kCAAkC,KAAK;AACrD,YAAM;AAAA,IACR;AAAA,EACF;AAAA,EAEA,MAAM,OAAsB;AAC1B,QAAI,CAAC,KAAK,WAAW;AACnB;AAAA,IACF;AAEA,UAAMA,UAAS,aAAa,mBAAmB;AAE/C,IAAAA,QAAO,KAAK,gCAAgC;AAE5C,QAAI,KAAK,QAAQ;AACf,YAAM,IAAI,QAAc,CAAC,YAAY;AACnC,aAAK,OAAO,MAAM,MAAM;AACtB,UAAAA,QAAO,KAAK,oBAAoB;AAChC,kBAAA;AAAA,QACF,CAAC;AAAA,MACH,CAAC;AAAA,IACH;AAEA,QAAI,KAAK,IAAI;AACX,YAAM,KAAK,GAAG,MAAA;AAAA,IAChB;AAEA,SAAK,YAAY;AAAA,EACnB;AAAA,EAEA,UAAkB;AAChB,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,kBAA2B;AACzB,WAAO,KAAK;AAAA,EACd;AACF;AC1RgB,cAAc,YAAY,GAAG;AAC7C,MAAM,YAAY,KAAK,QAAQ,cAAc,YAAY,GAAG,CAAC;AAY7D,QAAA,IAAY,WAAW,KAAK,KAAK,WAAW,OAAO;AAE5C,MAAM,YAAY,KAAK,KAAK,QAAA,IAAY,UAAU,eAAe;AACjE,MAAM,gBAAgB,KAAK,KAAK,QAAA,IAAY,UAAU,MAAM;AAC5D,MAAM,sBAAsB,QAAA,IAAY;AAE/C,QAAA,IAAY,cAAc,sBACtB,KAAK,KAAK,QAAA,IAAY,UAAU,QAAQ,IACxC;AAGJ,IAAI,GAAG,QAAA,EAAU,WAAW,KAAK,OAAO,4BAAA;AAGxC,IAAI,QAAQ,aAAa,aAAa,kBAAkB,IAAI,SAAS;AAErE,IAAI,CAAC,IAAI,6BAA6B;AACpC,MAAI,KAAA;AACJ,UAAQ,KAAK,CAAC;AAChB;AAEA,IAAI,MAA4B;AAChC,MAAM,UAAU,KAAK,KAAK,WAAW,sBAAsB;AAC3D,MAAM,YAAY,KAAK,KAAK,eAAe,YAAY;AAGvD,IAAI,eAAoC;AAExC,eAAe,eAAe;AAC5B,QAAM,IAAI,cAAc;AAAA,IACtB,OAAO;AAAA,IACP,MAAM,KAAK,KAAK,QAAA,IAAY,aAAa,aAAa;AAAA,IACtD,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,gBAAgB;AAAA,MACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAA;AAAA,EAOF,CACD;AAED,MAAI,qBAAqB;AACvB,QAAI,QAAQ,mBAAmB;AAAA,EAGjC,OAAO;AACL,QAAI,SAAS,SAAS;AAAA,EACxB;AAGA,MAAI,YAAY,GAAG,mBAAmB,MAAM;AAC1C,+BAAK,YAAY,KAAK,6CAA4B,KAAA,GAAO;EAC3D,CAAC;AAGD,MAAI,YAAY,qBAAqB,CAAC,EAAE,UAAU;AAChD,QAAI,IAAI,WAAW,QAAQ,EAAG,OAAM,aAAa,GAAG;AACpD,WAAO,EAAE,QAAQ,OAAA;AAAA,EACnB,CAAC;AAGD,SAAO,GAAG;AACZ;AAEA,IAAI,UAAA,EAAY,KAAK,YAAY;AAE/B,MAAI;AACF,UAAM,EAAE,OAAA,IAAW,MAAM,UAAU,eAAe;AAClD,YAAQ,IAAI,qBAAqB,OAAO,KAAA,CAAM;AAAA,EAChD,SAAS,OAAO;AACd,YAAQ,KAAK,4DAA4D;AAAA,EAE3E;AAGA,MAAI;AACF,mBAAe,IAAI,aAAa,EAAE,MAAM,MAAM;AAC9C,UAAM,aAAa,MAAA;AACnB,YAAQ,IAAI,iDAAiD;AAAA,EAC/D,SAAS,OAAO;AACd,YAAQ,MAAM,kCAAkC,KAAK;AAAA,EACvD;AAGA,eAAA;AACF,CAAC;AAED,IAAI,GAAG,qBAAqB,YAAY;AACtC,QAAM;AAGN,MAAI,cAAc;AAChB,QAAI;AACF,YAAM,aAAa,KAAA;AACnB,cAAQ,IAAI,uBAAuB;AAAA,IACrC,SAAS,OAAO;AACd,cAAQ,MAAM,iCAAiC,KAAK;AAAA,IACtD;AAAA,EACF;AAEA,MAAI,QAAQ,aAAa,SAAU,KAAI,KAAA;AACzC,CAAC;AAED,IAAI,GAAG,mBAAmB,MAAM;AAC9B,MAAI,KAAK;AAEP,QAAI,IAAI,cAAe,KAAI,QAAA;AAC3B,QAAI,MAAA;AAAA,EACN;AACF,CAAC;AAED,IAAI,GAAG,YAAY,MAAM;AACvB,QAAM,aAAa,cAAc,cAAA;AACjC,MAAI,WAAW,QAAQ;AACrB,eAAW,CAAC,EAAE,MAAA;AAAA,EAChB,OAAO;AACL,iBAAA;AAAA,EACF;AACF,CAAC;AAGD,QAAQ,OAAO,YAAY,CAAC,GAAG,QAAQ;AACrC,QAAM,cAAc,IAAI,cAAc;AAAA,IACpC,gBAAgB;AAAA,MACd;AAAA,MACA,iBAAiB;AAAA,MACjB,kBAAkB;AAAA,IAAA;AAAA,EACpB,CACD;AAED,MAAI,qBAAqB;AACvB,gBAAY,QAAQ,GAAG,mBAAmB,IAAI,GAAG,EAAE;AAAA,EACrD,OAAO;AACL,gBAAY,SAAS,WAAW,EAAE,MAAM,KAAK;AAAA,EAC/C;AACF,CAAC;AAGD,QAAQ,OAAO,wBAAwB,MAAM;AAC3C,SAAO;AAAA,IACL,UAAS,6CAAc,sBAAqB;AAAA,IAC5C,OAAM,6CAAc,cAAa;AAAA,EAAA;AAErC,CAAC;AAGD,QAAQ,OAAO,6BAA6B,MAAM;AAChD,QAAM,eAAe,IAAI,QAAQ,UAAU;AAC3C,SAAO,KAAK,KAAK,cAAc,oBAAoB,MAAM;AAC3D,CAAC;AAED,QAAQ,OAAO,qBAAqB,OAAO,OAAO,YAAY;AAC5D,QAAM,EAAE,UAAUC,QAAO,MAAM,OAAO,SAAS;AAC/C,QAAM,eAAe,IAAI,QAAQ,UAAU;AAC3C,QAAM,gBAAgB,KAAK,KAAK,cAAc,kBAAkB;AAGhE,QAAM,WAAW,KAAK,KAAK,eAAe,OAAO;AACjD,MAAI,CAAC,SAAS,WAAW,aAAa,GAAG;AACvC,UAAM,IAAI,MAAM,uCAAuC;AAAA,EACzD;AAEA,MAAI;AACF,UAAM,QAAQ,MAAMA,IAAG,QAAQ,UAAU,EAAE,eAAe,MAAM;AAChE,WAAO,MAAM,IAAI,CAAA,UAAS;AAAA,MACxB,MAAM,KAAK;AAAA,MACX,MAAM,KAAK,KAAK,SAAS,KAAK,IAAI;AAAA,MAClC,MAAM,KAAK,YAAA,IAAgB,cAAc;AAAA,IAAA,EACzC;AAAA,EACJ,SAAS,OAAO;AACd,YAAQ,MAAM,wBAAwB,KAAK;AAC3C,WAAO,CAAA;AAAA,EACT;AACF,CAAC;AAED,QAAQ,OAAO,oBAAoB,OAAO,OAAO,aAAa;AAC5D,QAAM,EAAE,UAAUA,QAAO,MAAM,OAAO,SAAS;AAC/C,QAAM,eAAe,IAAI,QAAQ,UAAU;AAC3C,QAAM,gBAAgB,KAAK,KAAK,cAAc,kBAAkB;AAEhE,QAAM,WAAW,KAAK,KAAK,eAAe,QAAQ;AAClD,MAAI,CAAC,SAAS,WAAW,aAAa,GAAG;AACvC,UAAM,IAAI,MAAM,uCAAuC;AAAA,EACzD;AAEA,SAAOA,IAAG,SAAS,UAAU,OAAO;AACtC,CAAC;AAED,QAAQ,OAAO,qBAAqB,OAAO,OAAO,UAAU,YAAY;AACtE,QAAM,EAAE,UAAUA,QAAO,MAAM,OAAO,SAAS;AAC/C,QAAM,eAAe,IAAI,QAAQ,UAAU;AAC3C,QAAM,gBAAgB,KAAK,KAAK,cAAc,kBAAkB;AAEhE,QAAM,WAAW,KAAK,KAAK,eAAe,QAAQ;AAClD,MAAI,CAAC,SAAS,WAAW,aAAa,GAAG;AACvC,UAAM,IAAI,MAAM,uCAAuC;AAAA,EACzD;AAEA,QAAMA,IAAG,UAAU,UAAU,SAAS,OAAO;AAC7C,SAAO;AACT,CAAC;AAED,QAAQ,OAAO,sBAAsB,OAAO,OAAO,UAAU,UAAU,OAAO;AAC5E,QAAM,EAAE,UAAUA,QAAO,MAAM,OAAO,SAAS;AAC/C,QAAM,eAAe,IAAI,QAAQ,UAAU;AAC3C,QAAM,gBAAgB,KAAK,KAAK,cAAc,kBAAkB;AAEhE,QAAM,WAAW,KAAK,KAAK,eAAe,QAAQ;AAClD,MAAI,CAAC,SAAS,WAAW,aAAa,GAAG;AACvC,UAAM,IAAI,MAAM,uCAAuC;AAAA,EACzD;AAGA,QAAMA,IAAG,MAAM,KAAK,QAAQ,QAAQ,GAAG,EAAE,WAAW,MAAM;AAC1D,QAAMA,IAAG,UAAU,UAAU,SAAS,OAAO;AAC7C,SAAO;AACT,CAAC;AAED,QAAQ,OAAO,sBAAsB,OAAO,OAAO,aAAa;AAC9D,QAAM,EAAE,UAAUA,QAAO,MAAM,OAAO,SAAS;AAC/C,QAAM,eAAe,IAAI,QAAQ,UAAU;AAC3C,QAAM,gBAAgB,KAAK,KAAK,cAAc,kBAAkB;AAEhE,QAAM,WAAW,KAAK,KAAK,eAAe,QAAQ;AAClD,MAAI,CAAC,SAAS,WAAW,aAAa,GAAG;AACvC,UAAM,IAAI,MAAM,uCAAuC;AAAA,EACzD;AAGA,QAAM,OAAO,MAAMA,IAAG,KAAK,QAAQ;AACnC,MAAI,KAAK,eAAe;AACtB,UAAMA,IAAG,GAAG,UAAU,EAAE,WAAW,MAAM,OAAO,MAAM;AAAA,EACxD,OAAO;AACL,UAAMA,IAAG,OAAO,QAAQ;AAAA,EAC1B;AACA,SAAO;AACT,CAAC;AAED,QAAQ,OAAO,2BAA2B,OAAO,OAAO,YAAY;AAClE,QAAM,EAAE,UAAUA,QAAO,MAAM,OAAO,SAAS;AAC/C,QAAM,eAAe,IAAI,QAAQ,UAAU;AAC3C,QAAM,gBAAgB,KAAK,KAAK,cAAc,kBAAkB;AAEhE,QAAM,WAAW,KAAK,KAAK,eAAe,OAAO;AACjD,MAAI,CAAC,SAAS,WAAW,aAAa,GAAG;AACvC,UAAM,IAAI,MAAM,uCAAuC;AAAA,EACzD;AAEA,QAAMA,IAAG,MAAM,UAAU,EAAE,WAAW,MAAM;AAC5C,SAAO;AACT,CAAC;AAED,QAAQ,OAAO,sBAAsB,OAAO,OAAO,SAAS,YAAY;AACtE,QAAM,EAAE,UAAUA,QAAO,MAAM,OAAO,SAAS;AAC/C,QAAM,eAAe,IAAI,QAAQ,UAAU;AAC3C,QAAM,gBAAgB,KAAK,KAAK,cAAc,kBAAkB;AAEhE,QAAM,cAAc,KAAK,KAAK,eAAe,OAAO;AACpD,QAAM,cAAc,KAAK,KAAK,eAAe,OAAO;AAEpD,MAAI,CAAC,YAAY,WAAW,aAAa,KAAK,CAAC,YAAY,WAAW,aAAa,GAAG;AACpF,UAAM,IAAI,MAAM,uCAAuC;AAAA,EACzD;AAEA,QAAMA,IAAG,OAAO,aAAa,WAAW;AACxC,SAAO;AACT,CAAC;AAGD,QAAQ,OAAO,oBAAoB,YAAY;AAC7C,QAAM,EAAE,UAAUA,QAAO,MAAM,OAAO,SAAS;AAC/C,QAAM,eAAe,IAAI,QAAQ,UAAU;AAC3C,QAAM,WAAW,KAAK,KAAK,cAAc,oBAAoB,MAAM;AAEnE,MAAI;AACF,UAAM,QAAQ,MAAMA,IAAG,QAAQ,UAAU,EAAE,eAAe,MAAM;AAChE,UAAM,OAAO,MACV,OAAO,CAAA,SAAQ,KAAK,aAAa,EACjC,IAAI,CAAA,UAAS;AAAA,MACZ,IAAI,KAAK;AAAA,MACT,MAAM,KAAK;AAAA,MACX,MAAM,KAAK,KAAK,QAAQ,KAAK,IAAI;AAAA,IAAA,EACjC;AACJ,WAAO;AAAA,EACT,SAAS,OAAO;AACd,YAAQ,MAAM,wBAAwB,KAAK;AAC3C,WAAO,CAAA;AAAA,EACT;AACF,CAAC;AAED,QAAQ,OAAO,gCAAgC,OAAO,OAAO,aAAa;AACxE,QAAM,EAAE,UAAUA,QAAO,MAAM,OAAO,SAAS;AAC/C,QAAM,eAAe,IAAI,QAAQ,UAAU;AAC3C,QAAM,gBAAgB,KAAK,KAAK,cAAc,kBAAkB;AAChE,QAAM,WAAW,KAAK,KAAK,eAAe,QAAQ;AAElD,MAAI;AACF,UAAMA,IAAG,OAAO,QAAQ;AACxB,WAAO;AAAA,EACT,QAAQ;AACN,WAAO;AAAA,EACT;AACF,CAAC;AAED,QAAQ,OAAO,oBAAoB,OAAO,OAAO,YAAY,aAAa;AACxE,QAAM,EAAE,UAAUA,QAAO,MAAM,OAAO,SAAS;AAC/C,QAAM,eAAe,IAAI,QAAQ,UAAU;AAC3C,QAAM,gBAAgB,KAAK,KAAK,cAAc,kBAAkB;AAEhE,QAAM,eAAe,KAAK,KAAK,eAAe,QAAQ;AACtD,MAAI,CAAC,aAAa,WAAW,aAAa,GAAG;AAC3C,UAAM,IAAI,MAAM,mDAAmD;AAAA,EACrE;AAGA,QAAM,UAAU,KAAK,QAAQ,YAAY;AACzC,QAAMA,IAAG,MAAM,SAAS,EAAE,WAAW,MAAM;AAG3C,QAAMA,IAAG,SAAS,YAAY,YAAY;AAC1C,SAAO;AACT,CAAC;AAED,QAAQ,OAAO,4BAA4B,OAAO,OAAO,UAAU,WAAW;AAC5E,QAAM,EAAE,UAAUA,QAAO,MAAM,OAAO,SAAS;AAC/C,QAAM,eAAe,IAAI,QAAQ,UAAU;AAC3C,QAAM,gBAAgB,KAAK,KAAK,cAAc,kBAAkB;AAEhE,QAAM,WAAW,KAAK,KAAK,eAAe,QAAQ;AAClD,MAAI,CAAC,SAAS,WAAW,aAAa,GAAG;AACvC,UAAM,IAAI,MAAM,uCAAuC;AAAA,EACzD;AAGA,QAAM,MAAM,KAAK,QAAQ,QAAQ;AACjC,QAAMA,IAAG,MAAM,KAAK,EAAE,WAAW,MAAM;AAGvC,QAAMA,IAAG,UAAU,UAAU,OAAO,KAAK,MAAM,CAAC;AAChD,SAAO;AACT,CAAC;AAED,QAAQ,OAAO,uBAAuB,OAAO,OAAO,aAAa;AAC/D,QAAM,EAAE,UAAUA,QAAO,MAAM,OAAO,SAAS;AAC/C,QAAM,eAAe,IAAI,QAAQ,UAAU;AAC3C,QAAM,gBAAgB,KAAK,KAAK,cAAc,kBAAkB;AAEhE,QAAM,WAAW,KAAK,KAAK,eAAe,QAAQ;AAClD,MAAI,CAAC,SAAS,WAAW,aAAa,GAAG;AACvC,UAAM,IAAI,MAAM,uCAAuC;AAAA,EACzD;AAGA,QAAM,SAAS,MAAMA,IAAG,SAAS,QAAQ;AACzC,QAAM,MAAM,KAAK,QAAQ,QAAQ,EAAE,YAAA,EAAc,MAAM,CAAC;AAGxD,MAAI,WAAW;AACf,QAAM,YAAoC;AAAA;AAAA,IAExC,KAAK;AAAA,IACL,MAAM;AAAA,IACN,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,MAAM;AAAA,IACN,KAAK;AAAA;AAAA,IAEL,KAAK;AAAA,IACL,MAAM;AAAA,IACN,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA;AAAA,IAEL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,MAAM;AAAA,IACN,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,EAAA;AAGP,MAAI,OAAO,WAAW;AACpB,eAAW,UAAU,GAAG;AAAA,EAC1B;AAGA,SAAO,QAAQ,QAAQ,WAAW,OAAO,SAAS,QAAQ,CAAC;AAC7D,CAAC;AAGD,MAAM,YAAYO,YAAU,IAAI;AAGhC,QAAQ,OAAO,oBAAoB,YAAY;AAC7C,MAAI;AACF,UAAM,EAAE,OAAA,IAAW,MAAM,UAAU,eAAe;AAClD,WAAO,EAAE,WAAW,MAAM,SAAS,OAAO,OAAK;AAAA,EACjD,SAAS,OAAO;AACd,WAAO,EAAE,WAAW,MAAA;AAAA,EACtB;AACF,CAAC;AAGD,QAAQ,OAAO,mBAAmB,OAAO,OAAO,YAAY;AAC1D,QAAM,eAAe,IAAI,QAAQ,UAAU;AAC3C,QAAM,gBAAgB,KAAK,KAAK,cAAc,kBAAkB;AAChE,QAAM,WAAW,KAAK,KAAK,eAAe,OAAO;AAEjD,MAAI,CAAC,SAAS,WAAW,aAAa,GAAG;AACvC,UAAM,IAAI,MAAM,uCAAuC;AAAA,EACzD;AAEA,MAAI;AAEF,UAAM,UAAU,YAAY,EAAE,KAAK,UAAU;AAG7C,UAAM,mBAAmB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOzB,UAAM,EAAE,UAAUP,QAAO,MAAM,OAAO,SAAS;AAC/C,UAAMA,IAAG,UAAU,KAAK,KAAK,UAAU,YAAY,GAAG,gBAAgB;AAGtE,UAAM,UAAU,aAAa,EAAE,KAAK,UAAU;AAC9C,UAAM,UAAU,kCAAkC,EAAE,KAAK,UAAU;AAEnE,WAAO,EAAE,SAAS,KAAA;AAAA,EACpB,SAAS,OAAO;AACd,YAAQ,MAAM,mBAAmB,KAAK;AACtC,WAAO,EAAE,SAAS,OAAO,OAAO,MAAM,QAAA;AAAA,EACxC;AACF,CAAC;AAGD,QAAQ,OAAO,0BAA0B,OAAO,OAAO,YAAY;AACjE,QAAM,eAAe,IAAI,QAAQ,UAAU;AAC3C,QAAM,gBAAgB,KAAK,KAAK,cAAc,kBAAkB;AAChE,QAAM,WAAW,KAAK,KAAK,eAAe,OAAO;AAEjD,MAAI,CAAC,SAAS,WAAW,aAAa,GAAG;AACvC,UAAM,IAAI,MAAM,uCAAuC;AAAA,EACzD;AAEA,MAAI;AACF,YAAQ,IAAI,qCAAqC,QAAQ,EAAE;AAE3D,UAAM,EAAE,OAAAuC,OAAA,IAAU,MAAM,OAAO,oBAAoB;AAEnD,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,YAAM,oBAAoBA,OAAM,OAAO;AAAA,QACrC;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QAAkB;AAAA,QAClB;AAAA,QACA;AAAA,QACA;AAAA,QAAa;AAAA,MAAA,GACZ;AAAA,QACD,KAAK;AAAA,QACL,OAAO;AAAA,QACP,OAAO;AAAA,MAAA,CACR;AAED,UAAI,SAAS;AAEb,wBAAkB,OAAO,GAAG,QAAQ,CAAC,SAAS;AAC5C,kBAAU,KAAK,SAAA;AACf,gBAAQ,IAAI,qBAAqB,KAAK,WAAW,KAAA,CAAM,EAAE;AAAA,MAC3D,CAAC;AAED,wBAAkB,OAAO,GAAG,QAAQ,CAAC,SAAS;AAC5C,kBAAU,KAAK,SAAA;AACf,gBAAQ,IAAI,4BAA4B,KAAK,WAAW,KAAA,CAAM,EAAE;AAAA,MAClE,CAAC;AAED,wBAAkB,GAAG,SAAS,CAAC,SAAS;AACtC,YAAI,SAAS,GAAG;AACd,kBAAQ,IAAI,+CAA+C;AAC3D,kBAAQ,EAAE,SAAS,MAAM;AAAA,QAC3B,OAAO;AACL,iBAAO,IAAI,MAAM,oCAAoC,IAAI,KAAK,MAAM,EAAE,CAAC;AAAA,QACzE;AAAA,MACF,CAAC;AAED,wBAAkB,GAAG,SAAS,CAAC,UAAU;AACvC,eAAO,IAAI,MAAM,kCAAkC,MAAM,OAAO,EAAE,CAAC;AAAA,MACrE,CAAC;AAAA,IACH,CAAC;AAAA,EACH,SAAS,OAAO;AACd,YAAQ,MAAM,0BAA0B,KAAK;AAC7C,WAAO,EAAE,SAAS,OAAO,OAAO,MAAM,QAAA;AAAA,EACxC;AACF,CAAC;AAGD,QAAQ,OAAO,sBAAsB,YAAY;AAC/C,QAAM,WAAW,GAAG,SAAA;AAEpB,MAAI;AACF,QAAI,aAAa,UAAU;AAGzB,YAAM,UAAU,wBAAwB;AACxC,aAAO,EAAE,SAAS,MAAM,SAAS,gEAAA;AAAA,IACnC,WAAW,aAAa,SAAS;AAE/B,YAAM,aAAa,kCAAkC;AACrD,aAAO,EAAE,SAAS,MAAM,SAAS,2DAAA;AAAA,IACnC,OAAO;AAEL,aAAO;AAAA,QACL,SAAS;AAAA,QACT,SAAS;AAAA,MAAA;AAAA,IAKb;AAAA,EACF,SAAS,OAAO;AACd,WAAO,EAAE,SAAS,OAAO,OAAO,MAAM,QAAA;AAAA,EACxC;AACF,CAAC;"}